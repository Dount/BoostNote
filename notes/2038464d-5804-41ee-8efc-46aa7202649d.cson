createdAt: "2022-01-20T02:36:31.286Z"
updatedAt: "2022-03-15T02:52:14.357Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "IOS 开发：从零基础到精通"
tags: []
content: '''
  # IOS 开发：从零基础到精通
  [TOC]
  
  
  # 第一部分
  ## 第一章 IOS介绍
  ### 1.1 Xcode 常用快捷键
  ```
  注释某行/取消注释某行:command+/
  代码整体向上移动:command+option+[(windows上option替换alt)
  代码整体向下移动:command+option+](windows上option替换alt)
  在单个文件中搜索关键字: command+F
  在整个工程中搜索关键字: command+shift+f
  查看方法实现: command+单击
  查看方法帮助: option+单击(windows上option替换alt)
  前一个打开的文件:ctrl+command+方向键
  后一个打开的文件:ctrl+command+方向键
  ```
  ### 1.2 Code Snippets快捷代码段
  创建自定义CodeSnippet
  ![2e8c2b33.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\2e8c2b33.png)
  
  自定义codeSnippet
  ![ebb4c2bb.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\ebb4c2bb.png)
  
  使用codeSnippet
  ![19e1bf87.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\19e1bf87.png)
  ![cc1a62c7.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\cc1a62c7.png)
  
  导出或导入CodeSnippet
  Xcode 的 CodeSnippet 目录 ~/Library/Developer/Xcode/UserData/CodeSnippet。
  如果你没有创建过自定义的CodeSnippet，那么就不会有CodeSnippet文件夹.
  
  把CodeSnippet文件夹的自定义CodeSnippet代码块全部保存到你想保存的地方,换电脑或者重装Xcode时,再导入到CodeSnippet文件夹,即可再次使用.
  
  ## 第二章 数据类型和表达式
  ### 2.1 数据类型与常量
  #### 2.1.1 基本数据类型
  ```
  int number = 10;
  NSLog(@"%d",number);
  
  float f = 10.1234;
  NSLog(@"%f",f);
          
  double d = 10.1234;
  NSLog(@"%f",d);
          
  char c = 'a';
  NSLog(@"%c",c);
          
  BOOL b1 = YES;
  BOOL b2 = NO;
  NSLog(@"b1:%d,b2:%d",b1,b2);
  ```
  #### 2.1.2 限定词
  ```
  将number声明为long的整形变量
  long int i1 = 100;
  NSLog(@"i1:%ld",i1);
  
  双长整形相当于双精度long
  long long int i2 = 100;
  NSLog(@"i2:%lld",i2);
          
  告诉编译器要声明的特定变量用来存储相当小的整数。
  short int i3 = 100;
  NSLog(@"i3:%d",i3);
  
  当整数变量只用来存储正数的情况下使用该限定符
  unsigned int i4 = 100;
  NSLog(@"i4:%d",i4);
  
  signed限定词可明确地告诉编译器该整型变量是有符号的。
  signed int i5 = 100;
  NSLog(@"i5:%d",i5);
  ```
  #### 2.1.3 id与instancetype
  id数据类型可存储任何类型的对象。从某种意义上说，它是通用对象类型。
  这和C语言中的void * 很相似。id是一个指向任意一个继承了NSObject类的对象。id是一个指针，所以在使用id的时候不需要加星号。
  
  id类型是Object-c中经常使用的一种重要数据类型，它是Object-C动态绑定的基础。
  ```
  NSArray *array = @[@123,@"99ios"];
  id obj = array[1];
  NSLog(@"%@",obj);
  ```
  在类方法中，例如，以alloc,new开头的方法，以及实例方法中autorelease,init,retain等方法的返回值类型就是instancetype类型。
  这些就称为关联返回类型的方法。这些方法的返回值是一个以方法所在的类为类型的对象。
  ```
  +(instancetype)alloc
  -(instancetype)init
  ```
  
  id和instancetype的异同
  id和instancetype的相同点在于都可以作为方法的返回值类型。
  两者不同点体现在：
  - id可以作为方法或函数的参数类型，也可以单独用这种类型定义变量，但是instancetype不行。
  - 如果方法的返回值类型是instancetype,那么它返回的一定是这个类型的对象，如果方法的返回值类型是id,那么它返回的是未知类型的对象。
  
  ### 2.2 算数表达式
  #### 2.2.1 基本运算符
  #### 2.2.2 数据类型转换
  在Objective-c语言中，类型转换的一般形式为(类型说明符)(表达式)
  该功能是吧表达式的运算结构强制转换成类型说明符所表示的类型。
  ```
  (float)a;
  (int)(x+y);
  ```
  类型转换时，存在以下几种常见形式。
  - 浮点值赋给整型变量，数值的小数部分会被删掉，整数部分不变。
  - 整型值赋给浮点型变量，数值大小不发生变化，数据类型变成浮点型。
  - id类型的对象转换成特定类型的对象。
  ```
  int a= 10,b=4;
  float c=2.0, d= 1.5;
          
  NSLog(@"(float)(a+b)=%f",(float)(a+b));
  NSLog(@"(int)(a+b)=%d",(int)(c+d));    
  NSLog(@"a=%d,b=%d,c=%f,d=%f",a,b,c,d);
          
  int intResult;
  intResult = d;
  NSLog(@"(intResult=d) --> initResult=%d",intResult);
          
  float floatResult;
  floatResult = a;
  NSLog(@"(floatResult=a)-->floatReuslt= %f",floatResult);
      
  id Object;
  NSString *string = @"99iOS";
  Object = (NSString *)string;
  NSLog(@"id object=%@",Object);
  ```
  ### 2.3 循环结构
  #### 2.3.1 for循环
  #### 2.3.2 for-in循环
  在Object-C编程中，for-in循环可以认为是一种增强型的for循环，这个是Objective-C中的一个重要语法。当遇到遍历数据的情况时经常会使用到for-in循环。
  ```
  NSMutableArray *array = [NSMutableArray arrayWithObjects:@"张三",@"李四",@"王五",@"赵六",nil];
  for(NSString *string in array){
  NSLog(@"%@",string);}
  ```
  在for-in循环使用中不允许改变容器中的对象，即不允许删除或者增加枚举容器中的对象。因为对于一个既定的枚举器来说，其内部的对象都已经对其进行了枚举排序，如果你私自添加或者删除对象，那么其既定的枚举序列就发生了改变，而这种改变是系统不能识别的。所以Objective-c中不允许这么做。
  
  若必须在for-in过程中删除一些对象，这时就需要在删除完一个对象时，对循环执行break操作.
  ```
  NSMutableArray *array = [NSMutableArray arrayWithObjects:@"张三",@"李四",@"王五",@"赵六",nil];
  for(NSString *string in array){
  if([string isEqualToString:@"张三"]){
  [array removeObject:string];
  break;
  }}
  ```
  #### 2.3.3 while循环
  #### 2.3.4 break与continue
  ### 2.4 选择结构
  #### 2.4.1 if语句
  #### 2.4.2 switch语句
  #### 2.4.3 条件运算符/三目运算符
  ### 2.5 typedef语句
  Objectvie-C允许开发者为已经定义过的数据类型指派一个别名。需要使用typedef语句。typedef可以定义任意的数据类型，可以是系统自带的数据类型，
  如int,float等。也可以是自定义的类，同时也可以支持枚举或者结构体。
  ```
  typedef int Integer;
  typedef MYPerson *Person;
  typedef CGRect MYRect;
  ```
  使用
  ```
  int number1 = 100;
  Integer number2 = 100;
          
  MYPerson *person1 = [[MYPerson alloc]init];
  Person person2 = [[MYPerson alloc]init];
          
  CGRect frame1 =CGRectMake(0, 0, 100, 100);
  MYRect frame2 =CGRectMake(0, 0, 100, 100);
  ```
  ## 第三章 类、对象与方法
  ### 3.1 类
  #### 3.1.1 类的定义
  在Objective-c中，每个类的定义包括两个部分：接口(interface)和实现(implementation)。接口部分定义在.h文件中，包含类的声明、属性以及方法，主要作用是对外提供访问解耦。实现部分定义在.m文件中，主要用于方法的功能实现。
  
  类定义是一种类型的对象原型，其声明了每个对象都具有的属性(Property),同时还定义了同一类的所有对象都使用的一系列方法(Method)。
  
  接口文件实现
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface Player : NSObject
  @property (nonatomic,assign)int healthPoint;
  @property (nonatomic,assign)int magicPoint;
  
  +(Player *)player; //初始化类方法
  -(void) normalAttack;
  -(void) magicAttack;
  
  @end
  NS_ASSUME_NONNULL_END
  ```
  
  实现文件实现
  ```
  #import "Player.h"
  @implementation Player
  +(Player *) player{
  //实例化对象
  Player *player = [[Player alloc]init];
  //设置属性初始化
  player.healthPoint =100;
  player.magicPoint = 100; 
  return player;
  }
  -(void)normalAttack{   
  }
  -(void)magicAttack{  
  }
  @end
  ```
  
  #### 3.1.2 类的继承
  在Objective-c中创建的类也遵循继承的原则。主要体现在两个方面。
  - 继承父类的属性：当创建一个新的类时，新的类不仅仅包含其自身定义的属性，并且还包括在其父类中定义的属性，以及其父类的父类的属性，并按照这个规则一直追溯到根类。NSObject是所有类的根类，因此，所有类都可以使用NSObject中定义的属性以及方法。
  
  - 继承父类的方法：一个对象既可以访问自身定义的方法，也可以访问所有父类的方法。当需要调用父类的方法时，需要使用到关键字super.
  
  接口文件实现
  ```
  #import "Player.h"
  NS_ASSUME_NONNULL_BEGIN
  @interface Magician : Player
  -(void) specialMagicAttack;
  -(void) mixAttack;
  @end
  NS_ASSUME_NONNULL_END
  ```
  
  实现文件实现
  ```
  #import "Magician.h"
  @implementation Magician
  -(void) specialMagicAttack{
      //调用父类的属性
      self.magicPoint -=50;
  }
  -(void)mixAttack{ 
      //调用父类的方法
      [super normalAttack];
      [super magicAttack];
  }
  @end
  ```
  ### 3.2 属性
  #### 3.2.1 属性的定义
  属性在类的定义中使用非常普遍，属性定义后，会创建一个与该属性名称同名且带下划线的实例变量，与此同时，编译器会根据属性的特性，自动合成该属性对应实例变量的存取方法(getter和setter方法)。
  
  当在类中声明一个属性时，需要在类的@interface代码部分编写
  ```
  @property (attributes) type name;
  ```
  - @property 属性定义关键字
  - attribute 属性的特性，提供了该属性的存储方法以及属性行为的说明，常见的关键字有weak/strong,assign,copy,atomic/nonatomic。
  - type属性的类型说明。
  - name属性的名称。
  
  获取属性的值：在点语法中使用objectName.properyName来获取属性的值，其本至上是调用了属性对应的getter方法。
  
  设置属性的值: 在点语法中使用objectName.properyName = value来给属性直接设值，其本质上是调用了属性对应的setter方法。需要注意的是，属性定义中包含readonly关键字的属性是不能设置值的。
  ```
  MYClass *object = [[MYClass alloc]init];
  //获取属性的值，getter方法
  NSLog(@"name属性初始值:%@",object.name);
  //设置属性的值，setter方法
  NSLog(@"name属性最新值:%@",object.name);
  ```
  
  懒加载指系统不会在初始化时就加载某个对象，而是在第一次调用get方法时候才加载这个对象的内存。懒加载其实就是对属性的getter方法进行重写操作。在懒加载过程中，可以对属性进行一些初始化的操作。
  ```
  @property (nonatomic,strong)NSMutableArray *dataArray;
  -(NSMutableArray *)dataArray{
  if(!_dataArray){
  _dataArray = [NSMutableArray array];
  }
  return _dataArray;
  }
  ```
  #### 3.2.2 公有属性与私有属性
  **在自定义类中，既可以在.h文件中声明属性，也可以在.m文件中声明属性。在.h文件中声明的属性可以供外部调用，称为公有属性。在.m文件中声明的属性，即该类扩展中声明的属性，只能在该类的实现部分使用，称为私有属性。公有属性与私有属性的作用域是不同的，公有属性可以在整个工程中都被调用到，而私有属性只能在该类内部调用。**
  
  在实现文件中，可以定义供类内部使用的专有属性。专有属性的作用域只限于本类，即只能够在该类的内部使用，外部无法访问。
  ```
  @interface Player ()
  @property (nonatomic,copy)NSString *firstName;
  @property (nonatomic,copy)NSString *lastName;
  @end
  
  完成专有属性后，通常建议使用懒加载的方式。
  -(NSString *)firstName {
      if(_firstName == nil){
          _firstName = [NSString stringWithFormat:@""];
      }
      return _firstName;
  }
  
  -(NSString *)lastName {
      if(_lastName == nil){
          _lastName = [NSString stringWithFormat:@""];
      }
      return _lastName;
  }
  ```
  
  在接口文件中，公共属性是可以被外部进行访问和调用的。
  ```
  @property (nonatomic,copy) NSString *name;
  -(NSString *)name{
      if(_name ==nil){
          _name = [self.firstName stringByAppendingString:self.lastName];
      }
      return _name;
  }
  ```
  #### 3.2.3 属性关键字
  在定义属性的时候，需要在括号内说明该属性的特性(attribute)。属性的特性决定了属性在原子性，存取方法以及内存管理3个方面的特性。目前，常用的特性关键字有8个，分别由nonatomic,atomic,readonly,readwrite,strong,weak,assign,copy.
  
  原子性(atomic,nonatomic)
  atomic意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，
  - 当一个变量声明为atomic时，意味着在多线程中只能有一个线程能对它进行访问。
  - 当一个变量声明为atomic时，该变量为线程安全性，但是会影响访问速度。
  - 当一个变量声明为atomic时，在非ARC编译环境下，需要设置访问锁来保证对该变量进行正确的getter/setter.
  
  nonatomic表示非原子的，可以被多个线程访问，效率比atomic快，但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。
  - 当一个变量声明为nonatomic时，意味着多个线程可以同时对其进行访问。
  - 当一个变量声明为nonatomic时，它是非线程安全型，访问速度快。
  - 当一个变量声明为nonatomic时，当两个不同的线程对其访问时，容易失控。
  
  存取方法(readwrite,readonly)
  readwrite是默认值，表示该属性同时拥有setter和getter，即该属性即可以读，也可以写。
  readonly表示只有getter没有setter,即该属性只能读取，不能更新或写入。
  
  内存管理(strong,weak,assign,copy)
  - strong表示实例变量对传入对象要有所有权关系，引用计数加1.
  - weak弱引用在setter方法中，对传入的对象不进行引用计数加1的操作。简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用weak声明的实例变量指向nil.
  - assign简单复制，不更改索引计数，适合简单数据类型。如 int、float、double和NSInteger,CGFloat等。
  - copy 用于希望在内存中保留一份传入值的复制，而不是值自身的情况，即把原来的对象完整地复制到另外一个新的内存区，当副本改变时，原对象并不同时改变，同样，当原对象发送改变时，其副本也不会发生改变，因为原对象与原复制对象存储在独立的两个内存区域中。
  
  copy与strong的区别在于实例对象是对传入对象的副本拥有所有权，而非对象本身。
  
  - strong 自定义对象，控制器对象使用strong,如果不指定，属性默认取值strong.
  - weak代理对象，IBOutlet使用weak.
  - assign基本数据类型，int,float,double,NSInteger,CGFloat使用assgin.
  - copy NSString,NSArray,NSDictionary及其可变子类，Block块代码使用copy
  ```
  @property (nonatomic,strong) MYClass *myclass;
  @property (nonatomic,weak) id delegate;
  @property (nonatomic,assign) int age ;
  @property (nonatomic,copy) NSString *name;
  @property (nonatomic,copy) NSArray *courseResults;
  @property (nonatomic,copy) void (^blockProperty)(void);
  ```
  
  ### 3.3 方法
  #### 3.3.1 方法的定义
  在IOS开发中，调用某个对象定义的方法是通过向对象发送消息的方式进行的，消息的名称对应类中定义的方法名称。消息机制是Objective-C语言区别其它编程语言的一个特性。在Object-c中，有两种类型的方法，分别是实例方法与类方法。
  
  1. 有关方法的基本概念
  ```
  [receiver message];消息传递模型
  ```
  - 消息message: 在iOS开发中，调用一个方法相当于传递一个消息，这里的消息指的是方法名（选择器selector）和参数。
  - 接收者receiver: 通常为一个对象，消息告诉接收者需要去做什么事情。当消息发送的时候，系统从接收者的方法列表中选择最合适的方法并调用。
  - 方法method: 方法都包括方法声明和方法实现两部分，相关代码分别编写在.h和.m文件中。
  - 发送消息：当需要调用一个方法时，通过给实现该方法的对象发送一条消息来实现，简单来说。就是通知对象去调用其定义的某个方法或者其父类的某个方法。
  - 选择器selector: 因为方法在消息中负责在对象的方法列表中选择一个方法执行，因此方法名在消息中通常成为选择器。
  
  2. 方法的定义
  方法声明包含了以下几个部分：方法类型标识符，返回类型，方法名称，参数类型和参数名称。
  ```
  - (void)insertString:(NSString *)astring atIndex:(NSInteger)loc;
  ```
  - 方法类型标识符(-) 表示一个实例方法
  - 返回类型(void) 即没有返回值
  - 方法名称(insertString:atIndex:) 一个方法的实际名称是所有签名关键词的串联，包括冒号字符。
  - 参数类型 该方法中包括了两个参数，两个参数的类型为NSString和NSUInteger.
  - 参数名称 该方法中包含了两个参数，两个参数的名称分别为astring和loc
  
  3. 方法的类型
  在iOS开发中，方法一共有两种类型，分别为实例方法和类方法。
  - 实例方法:消息的接收者必须为一个已经实例化的对象，实例方法在定义时以-开头。
  ```
  -(void)appendString:(NSString *)aString;
  ```
  - 类方法:有时也称为工厂方法，类方法通常用于创建类的新实例。消息的接收者为一个类对象，类方法在定义时以+开头，类方法是一般情况下是有返回值的，返回类型通常为instancetype.
  ```
  +(instancetype)stringWithFormat:(NSString *)format....;
  ```
  #### 3.3.2 方法的调用
  在Objective-C中，调用一个方法相当于传递一个消息，这里的消息指的是方法名和参数。
  所有消息的分派都是动态的，所谓动态指的是所有消息处理直到执行时(runtime)才会动态决定，而不是在编译时就绑定，这也体现了Objective-C对象的多态行为。
  
  1. 方法调用的方式
  - 普通调用 使用方括号将消息本身与参数放到括号内，同时将接受消息的对象放在最前面。
  ```
  NSString *str = [NSString stringWithFormat:@"九九学院"]; //类方法调用
  NSString *str2 = [NSString stringWithFormat:@"www.99ios.com"]; //类方法调用
  str = [str stringByAppendingString:str2]; //实例方法调用
  NSLog(@"%@",str);
  ```
  - 嵌套调用 有时为了避免声明大量的局部变量来存储临时结果，Objective-C也支持嵌套消息表达式。
  ```
  NSString *str = [NSString stringWithFormat:@"九九学院"]; //类方法调用
  str = [str stringByAppendingString:[NSStringstringWithFormat:@"www.99ios.com"]]; //方法的嵌套调用
  NSLog(@"%@",str);
  ```
  - 调用父类的方法 子类可以直接调用父类的方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "myPerson.h"
  int main(int argc, char * argv[]) {
  @autoreleasepool {
  myPerson *myPerson1 = [[myPerson alloc] init];
  [myPerson copy];
  }
  return 0;
  }
  ```
  
  2. 点语法
  Objective-C中还提供专门用于调用存取方法(setter/getter)的点语法。开发者可以调用getter/setter方法来获取或设置对象的属性的值，同样的，可以使用点语法来更加简便地获取或设置对象属性的值。
  
  - 创建一个MyPerson类，并添加一个name属性
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  @interface myPerson : NSObject
  @property (nonatomic,copy) NSString *name;
  @end
  NS_ASSUME_NONNULL_END
  ```
  - 使用点语法对name属性进行赋值以及取值操作。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "myPerson.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          myPerson *myPerson1 = [[myPerson alloc] init];
          myPerson1.name = @"MYClass";
          NSLog(@"class name is %@",myPerson1.name);
      }
      return 0;
  }
  ```
  3. 消息处理机制
  在Objective-C中，消息是直到运行时才和方法进行绑定关联的。消息机制的关键在于编译器为类和对象生成的结构。其中类的结构中包含两个基本元素：**，指向父类的指针；第二，类的方法列表**,而对象被创建时，对象的第一个实例变量是一个指向该对象的类结构的指针，即isa指针。通过该指针，就可以访问到该类及其父类的方法列表。
  
  当向某个对象发送消息时:
  - 首先根据isa指针，找到该对象对应的类结构的方法列表，继而可找到具体的方法实现。当在本类的方法列表中找不到对应的方法时，会根据类结构中父类的指针去查找父类的方法列表，直至NSObject根类。
  - 将对象以及参数传递给找到的方法实现。
  - 执行方法中的代码，获取方法的返回值。 
  
  #### 3.3.3 方法的重写
  在Objective-C中，子类不仅可以继承父类的属性，同时还可以直接继承父类中的方法，而不需要重新编写相同的方法，但有时候在子类中并不想原封不动地继承父类中的方法，而是希望在子类中实现一些特定的功能，这时可以对父类进行方法重写或方法覆盖。
  
  1. 方法重写的规则
  一般来说，如果希望在子类中调用父类的某个方法，实现一些特定的功能时，可以考虑对父类的方法进行重写。当子类需要重写父类的方法时，必须保证重写的两个方法放回置，方法名，参数列表完全一致。
  
  2. 实例代码实现
  新增一个ClassA类，在ClassA.h文件中，添加webSite属性以及printWebSite方法#import 
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface ClassA : NSObject
  @property (nonatomic,copy) NSString *webSite;
  -(void) printWebSite;
  
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  在ClassA.m文件中，实现printWebSite方法的功能，即打印webSite属性的值。
  ```
  #import "ClassA.h"
  @implementation ClassA
  -(void) printWebSite {
      NSLog(@"classA 中打印webSite的只：%@",self.webSite);
  }
  @end
  ```
  新建一个ClassB,继承自ClassA,在ClassB.h文件中，同样添加一个printWebSite方法。
  ```
  #import <Foundation/Foundation.h>
  #import "ClassA.h"
  NS_ASSUME_NONNULL_BEGIN
  @interface ClassB : ClassA
  -(void)printWebSite;
  @end
  NS_ASSUME_NONNULL_END
  ```
  ClassB.m文件中，重写printWebSite方法，改变打印的内容。
  ```
  #import "ClassB.h"
  @implementation ClassB
  -(void)printWebSite{
      NSLog(@"ClassB中打印webSite的值:%@",[NSString stringWithFormat:@"http://%@",self.webSite]);
  }
  @end
  ```
  在main()中分别调用父类和子类的printwebSite方法。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "ClassA.h"
  #import "ClassB.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          ClassA *classA = [[ClassA alloc] init];
          classA.webSite = @"www.99ios.com";
          [classA printWebSite];
          ClassB *classB = [[ClassB alloc]init];
          classB.webSite = @"www.99ios.com";
          [classB printWebSite];
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  3. 子类方法调用父类方法
  在发开过程中，需要子类先调用父类的方法，然后再进行一些定制操作，因此在调用父类方法时需要用到super关键字
  ```
  #import "ClassB.h"
  @implementation ClassB
  -(void)printWebSite{
  [super printWebSite];
  NSLog(@"ClassB中打印webSite的值:%@",[NSString stringWithFormat:@"http://%@",self.webSite]);
  }
  @end
  ```
  ### 3.4 对象
  #### 3.4.1 创建对象
  对象是类Class运行时的实例，它包含了自己的实例变量的内存副本以及类方法的指针，在实际开发种可以采用分配内存地址alloc以及初始化init两个步骤来创建一个对象。
  
  对象的创建分为两个阶段：内存空间分配和初始化。通常情况下，初始化总是紧跟在内存空间分配之后进行的，但是在创建对象的过程种，这两个操作的作用是不同的。
  
  1. 分配内存空间alloc
  除了为对象在程序的内存区划定一块合适大小的内存空间之外,alloc方法还有以下几个重要作用：
  - 将对象的引用计数设置为1。其中，引用计数与对象的内存管理有关，在ARC模式下，当引用计数为0时，对象会被释放。
  - 初始化对象的isa指针并指向对象的类。在实际开发过程种，会遇到对象类的类对象两个概念，其中，对象类是一个根据类定义编译得到的运行对象。另外，每一个对象都有一个isa指针表示其是哪个类的实例。
  - 将类种定义的属性的值初始化为0或者nil.
  
  如果只执行了alloc操作，在内存种分配了内存空间，但未进行任何初始化操作。
  其对象的地址是存在的，但其属性的值为空。
  
  2. 初始化init
  初始化的过程将对象的实例变量设置为合理且有用的初始值，还可以分配和准备对象需要的其他全局资源，并在必要时加载诸如文件这样的资源。
  
  在对象调用init方法时，主要完成了以下工作。
  - 调用父类的初始化方法[super init]
  - 如果父类返回的对象不为空，则可以对对象进一步设置；
  - 如果父类返回的对象为nil,则直接返回nil。
  
  3. 类方法
  类方法是方法前面为+号的方法，类方法把创建对象过程中的两个步骤(alloc+init)合并，直接返回被创建的对象。在实际开发过程中，类方法的使用非常普遍。
  ![635dcb02.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\635dcb02.png)
  下方的示例代码中分别使用类方法和实例方法创建了NSString 类型的对象。
  ```
  //使用类方法创建字符串对象
  NSString *str = [NSString stringWithFormat:@"www.99ios.com"];
  //使用alloc+init方法创建字符串对象
  NSString *str2 = [[NSString alloc] initWithString:@"九九学院"];
  ```
  #### 3.4.2 对象操作
  针对对象的常见操作主要包括:判断对象的类型，判断对象是否响应消息，对象间的比较以及对象复制
  
  1. 判断对象的类型
  对象通过调用isKindOfClass:方法，可以判断对象的类型。isKindOfClass:方法是NSObject类的方法，将类型为Class的对象aClass作为参数传入，返回一个BOOL类型的返回值。
  ```
  -(BOOL)isKindOfClass:(Class)aclass;
  ```
  ```
  NSString *str = [NSString stringWithFormat:@"www.99ios.com"];
  if([str isKindOfClass:[NSString class]]){
  NSLog(@"str 是NSString类型的对象!");}
  ```
  
  2. 判断对象是否响应消息
  在Objective-C 中，调用对象的方法需要向对象发送消息，这是Objective-C语言的重要特征。要判断一个对象是否响应一条消息，则可以调用respondsToSelector：方法。应用程序通常在验证一个对象响应一则消息后，才将消息发送给该对象。
  
  定义MYClass.h文件中，添加一个name属性
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  
  @interface MYClass : NSObject
  @property (nonatomic,copy)NSString *name;
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  在自定义类MYClass.m文件中，对属性进行懒加载
  ```
  #import "MYClass.h"
  @implementation MYClass
  -(NSString *)name{
      if(_name ==nil){
          _name=@"99ios";
      }
      return _name;
  }
  @end
  ```
  在main()中，判断自定义类是否实现了属性的getter方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *obj = [[MYClass alloc]init];
          if([obj respondsToSelector:@selector(name)]){
              NSLog(@"obj可以响应名称为name的消息");
          }
      }
      return 0;
  }
  ```
  3. 对象间的比较
  当需要对比两个对象是否相同时，可以使用isEqual:方法。如果相同，则该方法返回YES。该方法是在NSObject类中定义的，因此所有的对象都可以调用这个方法。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *str1 = [NSString stringWithFormat:@"www.99ios.com"];
          NSString *str2 = @"九九学院";
          if([str1 isEqual:str2]){
              NSLog(@"str1与str2相同");
          }else{
              NSLog(@"str1与str2不相同");
          }
          if([str1 isEqualToString:@"www.99ios.com"]){
              NSLog(@"str1与字符串 wwww.99ios.com相同");
          }
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  4. 对象复制
  通过调用copy方法，可以创建对象的副本。调用copy方法，有个前提条件，即接受的对象的类必须遵守NSCopying协议。另外，在使用对象复制时，还需要考虑针对该对象是浅复制还是深复制。有关沈复制与浅复制后续会详细介绍。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *str = [NSString stringWithFormat:@"www.99ios.com"];
          //对象复制
          NSString *copyString = [str copy];
          NSLog(@"copyString的值:%@",copyString);
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  ### 3.5 变量
  #### 3.5.1 局部变量
  局部变量也称为内部变量，局部变量在方法内部声明，作用域仅仅限于方法内。有关局部变量在实际使用中，有以下几个常用的要点。
  - 局部变量在方法内部定义，只有在方法运行时才存在。
  - 局部变量没有默认的初始值，因此在使用前需要赋值。
  - 在一个方法中，方法中的输入参数也属于局部变量的范畴。
  
  示例代码
  定义一个MYClass类，在该类MYClass.h文件中添加一个printlocalVariable方法。
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  @interface MYClass : NSObject
  -(void) printLocalVariable;
  @end
  NS_ASSUME_NONNULL_END
  ```
  在类MYClass.m文件中，实现printLocalVariable方法。在printLocalVariable方法内部，定义个局部变量localVar,并赋初始值0.当方法被调用时，打印当前localVar的值，之后localVar值执行加1操作。
  ```
  #import "MYClass.h"
  @implementation MYClass
  -(void) printLocalVariable{
      int localVar = 0;
      NSLog(@"localVar value :%d",localVar);
      localVar++;
  }
  @end
  ```
  在main函数中反复调用printlocalVariable方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
      }
      return 0;
  }
  ```
  #### 3.5.2 全局变量
  全局变量也称为外部变量，它不属于任何一个方法，而是属于一个源程序文件或者特定的类。根据其作用区域来区分，全局变量包括内部全局变量以及外部全局变量，其中，**内部全局变量的作用域是整个类，而外部全局变量的作用域是整个程序。**
  
  1. 内部全局变量
  如果在程序开始处定义变量，那么久可以在类中任何位置都使用这个变量的值，且变量的值是累计变化的，这个时候，这个变量的作用域在于整个类的实现文件，称之为内部全局变量。
  
  在MYClass.m文件中定义一个内部全局变量gNum,并且赋初始值0，那么就可以在该类的所有方法中使用该变量，不需要重新声明，并且对于该变量值的修改是累加的。
  ```
  import "MYClass.h"
  @implementation MYClass
  int gNum = 0;
  -(void) printLocalVariable{
      NSLog(@"localVar value :%d",gNum);
      gNum++;
  }
  @end
  ```
  在main()函数中，调用printGlobalVariable方法，来检验内部全局变量gNum的值是累加的。
  ```
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
      }
      return 0;
  }
  ```
  2. 外部全局变量
  外部全局变量，也是可以在程序的其他任何方法以及函数中访问的。**这需要在访问外部全局变量的地方，声明变量类型以及名称，并添加extern关键字，即可访问该全局变量。**
  
  首先在classA.m classB.m文件中实现printExternVar方法，并对全局变量gNum进行声明。
  ```
  #import "ClassA.h"
  @implementation ClassA
  -(void)printLocalVariable{
      extern int gNum;
      NSLog(@"globalVar value (Class A):%d",gNum);
      gNum++;
  }
  @end
  ```
  
  ```
  #import "ClassB.h"
  @implementation ClassB
  -(void)printLocalVariable{
      extern int gNum;
      NSLog(@"globalVar value (Class B):%d",gNum);
  }
  @end
  ```
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "ClassA.h"
  #import "ClassB.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          
          ClassA *classA = [[ClassA alloc]init];
          [classA printLocalVariable];
          
          ClassB *classB = [[ClassB alloc]init];
          [classB printLocalVariable];
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  **注意 需要区分变量的声明和定义，变量的声明不会引起内存空间的分配，而定义会分配内存空间。处理外部变量时，变量可以在很多地方声明为extern,但只能定义一次。**
  
  #### 3.5.3 静态变量
  在Objective-C中，在变量声明前加上关键字static,该变量就成为静态变量。静态变量可以使局部变量保留多次调用同一个方法所取得的值。
  1. 在方法之内定义静态变量
  静态变量只在程序开始执行初始化一次。在不指定静态变量的值时，默认情况下，静态变量的初始值为0，并且多次调用方法时，保存这些数值。静态变量也可以在方法内部定义，此时，只能在该方法中使用定义的静态变量。
  
  在MYClass.m文件printStaticVariable方法中定义静态变量staticValue.该静态变量只能在printStaticVariable方法中使用。
  ```
  #import "MYClass.h"
  @implementation MYClass
  -(void)printStaticVariable{
      static int staticValue;
      NSLog(@"staticVar value: %d",staticValue);
      staticValue++;
  }
  @end
  ```
  当在main中多次调用printStaticVariable方法时，staticValue的值会累加。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printStaticVariable];
          [myclass printStaticVariable];
          [myclass printStaticVariable];
      }
      return 0;
  }
  ```
  2. 在方法之外定义静态变量
  静态变量除了可以在方法内部定义之外，还可以在方法之外定义，此时，该类的所有方法都可以访问该静态变量。
  
  在MYClass.m文件 @implementation之外定义一个静态变量staticValue2,并赋初始值100.
  ```
  #import "MYClass.h"
  static int staticValue2 = 100;
  @implementation MYClass
  -(void) testStaticVarValue1{
      NSLog(@"在方法1中打印静态变量的当前值:%d",staticValue2);
      staticValue2++;
  }
  -(void) testStaticVarValue2{
      NSLog(@"在方法2中打印静态变量的当前值:%d",staticValue2);
      staticValue2++;
  }
  @end
  ```
  在main函数中
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
      }
      return 0;
  }
  ```
  3. 静态变量的重要特性
  - 某个对象调用不同的方法，修改同一个静态变量时，则该静态变量的值使累加的。
  - 当同一个类的不同对象，修改同一个静态变量时，则该静态变量的值也是累加的。
  
  在main函数中，再创建一个MYClass对象,可以验证，此时静态变量staticValue2的值也是叠加的。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
          
          MYClass *myclass2 = [[MYClass alloc]init];
          [myclass2 testStaticVarValue1];
          [myclass2 testStaticVarValue2];
          [myclass2 testStaticVarValue1];
          [myclass2 testStaticVarValue2];
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  #### 3.5.4 const关键字
  
  1. const介绍
  如果不像让某些变量的值改变，可以使用const关键字来修饰这些变量。如果添加const关键字，这些变量的值从头到尾都不会改变了。在iOS开发中，经常把字符串常量添加const关键字，从而替代宏(#define),因为const的执行性能比宏定义要高。给变量添加const关键字，主要目的是防止定义的对象被修改，在定义有const关键字的对象时，需要设置初始值。
  
  const在不同位置情况下的变量
  ```
  int main() {
      @autoreleasepool {
          int a = 10;
          const int *p = &a;
          int const *p2 = &a;
          int * const p3 = &a;
          
          int b = 20;
          *p = 12;
          p = &b;
          
          *p2 = 12;
          p2 = &b;
          
          *p3 = 12;
          p3 = &b;
  
          printf("%d",*p);
          printf("%d",*p2);
          printf("%d",*p3);
      }
  }
  ```
  结果如下：
  ![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDQ0ODk2LTRmZmFhNWYxNWEzZDVkNzgucG5n.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\25b94e62.png)
  
  情况1: 
  ```
  const int *p = &a
  此时const修饰的是*p,*p的意义是指针所指向的内存地址的值，所以此时的意思是指针p所指向的内存地址的值是不可变的，但是指向的内存地址可变。
  ```
  情况2：
  ```
  int const *p = &a
  此时const修饰的仍然是*p,同情况1一样。
  ```
  情况3：
  ```
  int *const p = &a
  此时const修饰的是变量p,也就是局部变量p的值不能被改变，所以当尝试使用*p改变p所指向的内存地址a中的值时是可行的，但是当尝试重新给p赋值，让其指向b的内存地址时会报错。
  ```
  2. const使用方法
  在实际的iOS开发中，const最常用于定义字符串常量，并且为了维护方便，会把工程中所有的字符串常量都统一放在一个const类中。
  
  在MYConst.h文件中，声明所有的常量，而且需要在每个常量前面都加上extern关键字。
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  extern int const height;
  extern NSString *const launchSuccessNotification;
  
  @interface MYConst : NSObject
  @end
  NS_ASSUME_NONNULL_END
  ```
  在MYConst.m文件中，为常量赋值。
  ```
  #import "MYConst.h"
  int const height = 44;
  NSString *const launchSuccessNotification = @"launchSuccessNotification";
  @implementation MYConst
  @end
  ```
  当需要使用const修饰的常量时，引入MYConst类。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSLog(@"my const height:%d",height);
          NSLog(@"my const notification string:%@",launchSuccessNotification);
      }
      return 0;
  }
  ```
  ## 第四章 Foundation框架
  ### 4.1 Foundation框架介绍
  - Application Kit 框架：包含了用于开发交交互式图形应用程序，使得开发文本，菜单，工具栏，表，文档，剪切板和窗口之类的过程变得十分简便，用于Mac OS桌面程序的开发。
  - Cocoa:总体来说，通常指的试Foundation框架，Application Kit框架以及CoreData框架，Cocoa一般针对的是MacOSd的应用开发。
  - Cocoa Touch:指的是Foundation框架，UIKit框架以及CoreData框架，CocoaTouch一般用于iOS移动设备开发。
  
  ### 4.2 字符串类
  在Foundation框架中，处理字符串的类就是NSString和NSMutableString。这两个类完成了Objective-C中与字符串相关的核心功能处理。而NSString和NSMutableString两个类最主要的区别是NSString类的字符串对象，在创建赋值后不能动态修改长度和内容，除非重新赋值。而NSMutableString类似于链表，在创建赋值后可以进行修改长度，插入，删除等操作。
  
  #### 4.2.1 不可变字符串NSString
  1. 创建字符串对象
  ```
  NSString *webSite =@"www.99ios.com"
  NSString *string1 = [NSString stringWithFormat:@"www.99ios.com"];
  NSString *string2 =[NSString stringWithUTF8String:"九九学院"];
  NSString *string3 =[[NSString alloc]initWithFormat:@"www.99ios.com"];
  NSString *string4 = [[NSString alloc]initWithUTF8String:"九九学院"]
  ```
  2. 字符串比较
  使用isEqualToString判断字符串是否相同
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string1 = @"www.99ios.com";
          NSString *string2 = @"www.99ios.com";
          if([string1 isEqualToString: string2]){
              NSLog(@"string1 与string2 相等");
          }
      }
      return 0;
  }
  ```
  判断字符串中是否包含某个字符串，使用containsString
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string = @"www.99ios.com";
          if([string containsString:@"99.ios"]){
              NSLog(@"string 中包含字符串99 ios!");
          }
      }
      return 0;
  }
  ```
  使用hasPrefix与hasSuffix判断字符串的开头与结尾
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string = @"www.99ios.com";
          if([string hasSuffix:@"com"]){
              NSLog(@"string 以com结尾");
          }
          if([string hasPrefix:@"www"]){
              NSLog(@"string 以www开头");
          }
      }
      return 0;
  }
  ```
  
  3. 字符串的拼接与截取
  截取
  - 使用substringFromIndex,获得从指定索引位置开始的字符串，传入的参数表示开发截取的位置，最终截取得到的字符串中不包括参数表示位置的字符。
  - 使用substringToIndex,获得从字符串开始到指定索引之间的字符串，最终截取得到的字符串中不包括参数表示位置的字符。
  - 使用substringWithRange，从字符串中间截取一段字符串，需要传入一个NSRange类型的参数，用于指明截取的范围。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string = @"www.99ios.com";
          NSString *subString1 = [string substringFromIndex:4];
          NSString *subString2 = [string substringToIndex:3];
          NSRange range = NSMakeRange(4, 5);
          
          NSString *subString3 = [string substringWithRange:range];
          NSLog(@"subString1:%@",subString1);
          NSLog(@"subString2:%@",subString2);
          NSLog(@"subString3:%@",subString3);
      }
      return 0;
  }
  ```
  拼接
  - stringWithFormat
  ```
  NSString * string1 = @"123";
  NSString * string2 = @"456";
  NSString * string3 = [NSString stringWithFormat:@"%@%@", string1, string2];
  NSLog(@"%@", string3);
  ```
  - stringByAppendingString
  ```
  NSString * string4 = [string1 stringByAppendingString:string2];
  NSLog(@"%@", string4);
  ```
  - stringByAppendingFormat
  ```
  NSString * string5 = [string1 stringByAppendingFormat:@"%@", string2];
  NSLog(@"%@", string5);
  ```
  4. 字符串的其他操作
  使用length属性，获取字符串的长度。
  使用integerValue方法实现数字字符串与数字的转换。
  
  #### 4.2.2 可变字符串NSMutableString
  NSMutableString是继承自NSString类的，所以NSString中定义的所有方法NSMutableString都可以使用，与NSString相比，NSMutableString类的对象在内存中存储的空间是可以变化的，因此存储的字符串长度和内容都可以改变。
  
  1. NSMutableString的初始化
  NSMutableString类的对象，可以采用以下几个方法来进行初始化。
  - stringWithCapacity，需要指定初始化时预留的可供存储的字符串最大长度。
  - initWithCapacity,需要指定初始化时预留的可供存储的字符串最大长度。
  - stringWithString,传入一个初始化字符串
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString1 = [NSMutableString stringWithCapacity:100];
          NSMutableString *mString2 = [[NSMutableString alloc] initWithCapacity:100];
          NSMutableString *mString3 = [NSMutableString stringWithString:@"www.99ios.com"];
      }
      return 0;
  }
  ```
  
  2. NSMutableString 字符串的修改
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString = [NSMutableString stringWithCapacity:100];
          //赋值
          [mString setString:@"www.99ios.com"];
          //拼接
          [mString appendString:@"九九学院"];
          //在指定位置插入字符串
          [mString insertString:@"欢迎访问" atIndex:0];
          NSLog(@"%@",mString);
      }
      return 0;
  }
  
  ```
  
  3. NSMutableString 字符串的替换与删除
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString = [NSMutableString stringWithString:@"www.99ios.com"];
          NSRange range = NSMakeRange(4, 5);//位置和长度
          [mString replaceCharactersInRange:range withString:@"apple"];
          [mString deleteCharactersInRange:range];
      }
      return 0;
  }
  
  ```
  4. 连接两个字符串对象
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString1 = [NSMutableString stringWithString:@"www.99ios.com"];
          NSMutableString *mString2 = [NSMutableString stringWithString:@"九九学院"];
          NSString *mNewString = [mString1 stringByAppendingString:mString2];
          NSLog(@"合并后的字符串:%@",mNewString);
      }
      return 0;
  }
  ```
  ### 4.3 数组类
  数组是有序的对象集合，一般情况下，一个数据中的元素都是同一类型的对象。
  Objective-C的数据比C++，Java的数组强大之处在于，NSArray保存的对象可以是不同类型的对象。但是缺点是只能保存对象，int、char、double等基本数据类型不能直接保存，需要通过转换成Objective-C对象后才能加入数组。
  
  NSArray类的数组是不可变数组，这种不可变包括：数组中不能新增元素，并且数组内已存在的对象也不支持修改。如果希望对数组进行修改，那么在声明时需要把数组声明为NSMutableArray可变数组，NSMutableArray类是NSArray类的子类。
  
  #### 4.3.1 不可变数组 NSArray
  1. 创建数组
  - 使用@[]的方式是创建数组经常使用的方式之一，只需要把数组中需要保存的对象放在括号中间
  ```
  NSArray *array1 = @[@123,@456,@789];
  NSArray *array2 = @[@123,@456,@"789"];//数组中可以保存不同的数据对象类型
  NSArray *array3 = @[@"tom",@"jerry",@"jobs"];
  ```
  - 使用arrayWithObjects 这种方式创建数组，需要在数组的结尾处添加一个空对象nil来标识数组的结尾。
  ```
  NSArray *array = [NSArray arrayWithObjects:@"123",@"456",@"789",nil];
  ```
  - 使用initWithObjects 这种方式创建数组，需要提前执行alloc操作。
  ```
  NSArray *array = [[NSArray alloc]initWithObjects：@"tom",@"jerry",@"jobs",nil];
  ```
  
  2. 数组的复制
  当直接把一个数组对象赋值给另外一个数组对象时，此时进行的是指针复制，即在内存中，数组中的对象只保留了一个版本。
  使用arrayWithArray方式复制数组，对原数组进行完整的复制，从而得到一个全新的数组。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          NSArray *copyArray1 = array;
          NSArray *copyArray2 = [NSArray arrayWithArray:array];
          NSLog(@"原始数组地址:%p,指针复制数组地址:%p,深复制数组地址:%p",array,copyArray1,copyArray2);
      }
      return 0;
  }
  ```
  3. 数组元素操作
  - objectAtIndex方法访问数组中的元素，或者使用数组名称[序号]来访问。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          NSNumber *num = array[0];
          NSLog(@"num:%@",num);
          id obj = [array objectAtIndex:0];
          NSLog(@"obj:%@",obj);
      }
      return 0;
  }
  ```
  - indexOfObject方法获取某个对象在数组中的下标。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          NSUInteger index = [array indexOfObject:@456];
          NSLog(@"对象对应数组中的下表为:%lu",index);
      }
      return 0;
  }
  
  ```
  - containsObject 查找某个对象是否存在数组中。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          if([array containsObject:@123]){
              NSLog(@"数组中包含这个对象");
          }
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  4. 其他常用操作
  - count返回数组中元素个数
  - firstObject获取数组中的第一个对象
  - lastObject获取数组中的最后一个对象
  
  #### 4.3.2 可变数组 NSMutableArray
  NSMutableArray类可以对数组内的元素数量进行增加，删除。同时也可以对存储元素的内容进行修改。由于NSMutableArray类是NSArray类的子类，因此NSArray类的方法和属性，NSMutableArray类都可以继续使用。
  
  1. 可变数组创建
  - 使用array 可以不指定可变数组的容量。
  - 使用arrayWithCapacity 需要提供数组的初始容量。
  - 使用initWithCapacity 需要提供数组的初始容量。
  ```
  NSMutableArray *mArray1 = [NSMutableArray array];
  NSMutableArray *mArray2 = [NSMutableArray arrayWithCapacity:100];
  NSMutableArray *mArray3 = [[NSMutableArray alloc] initWithCapacity:100];
  ```
  
  2. 可变数组的元素操作
  - 在数组末尾增加
  ```
  [mArray3 addObject:(nonnull id)];
  ```
  - 在指定位置增加元素 
  ```
  [mArray3 insertObject:(nonnull id) atIndex:(NSUInteger)];
  ```
  - 替换某个下标的元素
  ```
  [mArray3 replaceObjectAtIndex:(NSUInteger) withObject:(nonnull id)];
  ```
  - 删除元素
  ```
  [mArray3 removeObject:(nonnull id)];
  ```
  - 删除指定下标的元素
  ```
  [mArray3 removeObjectAtIndex:(NSUInteger)];
  ```
  - 删除所有元素
  ```
  [mArray3 removeAllObjects];
  ```
  - 修改某个元素对象的值，可以使用赋值运算符直接更新数组中某个下标对象的值。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableArray *mArray = [NSMutableArray arrayWithObjects:@"九九学院",@"99ios",nil];
          NSLog(@"初始化状态下，数组中第一个对象的值:%@",mArray[0]);
          mArray[0] = @"www.99ios.com";
          NSLog(@"更新后，数组中第一个对象的值:%@",mArray[0]);
      }
      return 0;
  }
  ```
  ### 4.4 字典类
  字典是由键-值组成的数据集合，其中值为对象。可以通过键从字典中获取需要的值。
  字典中的键必须唯一。通常情况下，键为字符串对象，主要用于注明存储对象的说明，但键也可以是其他类型的对象。和键关联的值可以是任何对象类型。
  
  #### 4.4.1 不可变字典NSDictionary
  1. 创建不可变字典
  NSDictionary字典创建完成后，不能再新增/删除键值对。
  ```
          NSDictionary *dict = @{
              @"website":@"www.99ios.com",
              @"name":@"九九学院",
              @"business":@"iOS学习",
              @"foundedYear":@2016
          };
          
  ```
  这4个键值对的key都使用字符串对象，用来说明键值的含义，而value中可以保存各种类型的对象，可以是NSString字符串对象，也可以是NSNumber数字对象。
  
  2. 访问字典的键值
  使用NSDictionary[key]或objectForKey方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDictionary *dict = @{
              @"website":@"www.99ios.com",
              @"name":@"九九学院",
              @"business":@"iOS学习",
              @"foundedYear":@2016
          };
          NSString *website = dict[@"website"];
          NSLog(@"字典中website对应的value: %@",website);
          NSString *name = [dict objectForKey:@"name"];
          NSLog(@"字典中name 对应的value:%@",name);
      }
      return 0;
  }
  ```
  3. 遍历字典中的键值对
  在Objective-C 中提供了for-in循环，for-in循环除了能够用于遍历数组中的对象之外，也可以用于遍历字典中的键值对。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDictionary *dict = @{
              @"website":@"www.99ios.com",
              @"name":@"九九学院",
              @"business":@"iOS学习",
              @"foundedYear":@2016
          };
          for(NSDictionary *key in dict){
              NSLog(@"key:%@ value:%@",key,dict[key]);
          }
      }
      return 0;
  }
  
  ```
  4. 其他操作
  - 获取字典中键值对的数量
  ```
  @property (readonly) NSUInteger count;
  ```
  - 获取一个字典中所有的键，返回一个数组
  ```
  @property (readonly,copy)NSArray<KeyType> *allKeys
  ```
  - 获取一个字典中所有的值，返回一个数组
  ```
  @property (readonly,copy)NSArray<ObjectType> *allValues
  ```
  
  #### 4.4.2 可变字点NSMutableDictionary
  可变字典类NSMutableDictionary类是不可变字典类NSDictionary的子类。
  NSMutableDictionary类继承了NSDictionary类的属性和方法之外，与不可变字典相比，其存储的键值可以新增、删除以及修改。
  
  1. 实例化可变字典对象
  使用dictionary方法初始化一个空的可变字典对象是最简便地得到一个可变字典对象的方法，获得的可变字典对象不指定初始容量。
  ```
  NSMutableDictionary *mDict = [NSMutableDictionary dictionary];
  ``` 
  2. 增加键值对
  通过调用setObject:forKkey:方法可增加字典内存储的键值。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableDictionary *mDict = [NSMutableDictionary dictionary];
          [mDict setObject:@"www.99ios.com" forKey:@"website"];
          [mDict setObject:@"九九学院" forKey:@"name"];
          NSLog(@"wesite:%@",mDict[@"website"]);
          NSLog(@"name:%@",mDict[@"name"]);
      }
      return 0;
  }
  ```
  3. 修改键值对的值
  当需要修改键值对时，需要根据键去除字典中的键值对，然后使用赋值运算符更新值。
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableDictionary *mDict = [NSMutableDictionary dictionary];
          [mDict setObject:@"www.99ios.com" forKey:@"website"];
          [mDict setObject:@"九九学院" forKey:@"name"];
          NSLog(@"wesite:%@",mDict[@"website"]);
          NSLog(@"name:%@",mDict[@"name"]);
          
          mDict[@"wesite"] =@"www.apple.com";
          mDict[@"name"] = @"苹果公司";
          NSLog(@"wesite新值:%@",mDict[@"website"]);
          NSLog(@"name新值:%@",mDict[@"name"]);
      }
      return 0;
  }
  
  ```
  4. 移除键值对
  - removeObjectForKey 方法可以移除某个键值对。
  - removeObjectsForKeys 方法可以以出多个键值对，把需要移除的所有键存储在一个数组对象中。
  - removeAllObjects方法 可以移除可变字典中的所有键值对。
  
  ### 4.5 NSNumber类
  在编程的过程中，一些基本数据类型的变量是必不可少的，但是在Objective-C编程语言当中，Objective-C的消息机制并不能向这些基本数据类型发送消息，而且Objective-C的集合当中是不能存放基本数据类型的，所以就需要将基本数据类型转换成对象来使用。
  Objective-C中提供了NSNumber类来将基本数据类型包装成**数字对象**，这样就可以将基本数据类型当作对象来处理。
  
  1. NSNumber 对象创建
  - 使用@符号进行快速封装。
  - 使用NSNumber类提供的方法。
  ```
  NSNumber *intNum = @10;
  NSNumber *floatNum = @3.14;
          
  NSNumber *intNum2 = [NSNumber numberWithInt:10];
  NSNumber *floatNum2 = [NSNumber numberWithFloat:3.14];
  NSNumber *integerNum = [NSNumber numberWithInteger:100];
  NSNumber *doubleNum = [NSNumber numberWithInteger:100.01];
  NSLog(@"%@--%@--%@--%@--%@--%@",intNum,intNum2,floatNum,floatNum2,integerNum,doubleNum);
  ```
  
  2. NSNumber 对象与基本数据类型之间的转换
  基本数据类型可以转换为NSNumber类的对象，NSNumber类的对象也可以转换成基本数据类型，在NSNumber类中也提供了对象的属性和方法。
  ```
  NSNumber *intNum = [NSNumber numberWithInt:10];
  NSNumber *floatNum = [NSNumber numberWithFloat:3.14];
  NSNumber *integerNum = [NSNumber numberWithInteger:100];
  NSNumber *doubleNum = [NSNumber numberWithDouble:100.01];
          
  int intBasic = [intNum intValue];
  float floatBasic = [floatNum floatValue];
  double doubleBasic = [doubleNum doubleValue];
  NSInteger integerBasic = [integerNum integerValue];
  NSLog(@"%d--%f--%f--%ld",intBasic,floatBasic,doubleBasic,(long)integerBasic);
  ```
  ### 4.6 NSDate类
  NSData对象用来表示一个具体的时间点，它存储的是世界标准时间，所以在使用的时候可能会需要根据不同的时区将时间转换为本地时间。
  
  1. 获取日期与时间
  NSDate类中提供了data方法，用来获取当前标准时区的时间(国际标准时间)，
  然后需要获取系统当地时区，再获取当前时区与格林尼治时间的间隔。最后转换为本地时间。
  ```
  NSDate *date = [NSDate date];
  NSLog(@"国际标准时间:%@",date);
  NSTimeZone *zone = [NSTimeZone systemTimeZone];
          
  NSInteger interval = [zone secondsFromGMTForDate:date];
          
  NSDate *localDate = [NSDate dateWithTimeIntervalSinceNow:interval];
  NSLog(@"当前时区时间:%@",localDate);
  ```
  
  
  2. 日期格式转换
  默认情况下，通过NSDate获取的日期时间格式为:yyyy-MM-ddHH:mm:ss。如果需要更换日期格式，需要用到NSDateFormatter类对日期格式进行转换，这里有两种方式转换。
  
  - NSDate转NSString时，需要使用NSDateFormatter类的stringFromDate。
  - NSString 转NSDate时，需要使用NSDateFormatter类的dateFromString。
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDate *date = [NSDate date];
          NSLog(@"国际标准时间:%@",date);
          NSTimeZone *zone = [NSTimeZone systemTimeZone];
          
          NSInteger interval = [zone secondsFromGMTForDate:date];
          
          NSDate *localDate = [NSDate dateWithTimeIntervalSinceNow:interval];
          NSLog(@"当前时区时间:%@",localDate);
          
          NSDateFormatter *df = [[NSDateFormatter alloc] init];
          df.dateFormat = @"yyyy年MM月dd日 HH:mm:ss";
          NSString *date2string = [df stringFromDate:date];
          NSLog(@"日期转字符串:%@",date2string);
          NSDate *string2date = [df dateFromString:date2string];
          NSLog(@"字符串转日期:%@",string2date);
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  
  ```
  3. 其他常用操作
  - 比较两个时间对象的先后，可以使用earlierDate以及laterDate方法。
  - 比较两个时间的间隔，可以使用timeIntervalSinceDate方法。
  - 比较两个日期是否相等，可以使用isEqualToDate方法
  
  
  ### 4.7 NSFileManager类
  #### 4.7.1 文件操作
  #### 4.7.2 目录操作
  #### 4.7.3 枚举目录的内容
  #### 4.7.4 文件的读写与写入
  ### 4.8 NSURL类
  NSURL类提供在应用中使用URL地址的相关方法。
  1. 创建NSURL对象。
  在NSURL类中提供了URLWithString方法，可以把一个字符串转换称为一个NSURL对象。
  除此之外，还可以使用initWithString方法。
  ```
  +(nullable instancetype) URLWithString:(NSString *)URLString
  -(nullable instancetype) initWithString:(NSString *)URLString
  ```
  
  2. 获取输出
  - 通过调用NSString类的stringWith-ContentsOfURL:encoding:error可以获取NSURL对象指针地址中存储的数据，并转换成字符串形式。
  
  - 获取NSData类的输出内容，通过NSData类的dataWithContentsOfURL:url可以返回NSData类的对象。
  
  ### 4.9 NSBundle类
  当创建一个应用时，系统存储了应用相关联的所有资源，例如图片、文件等。将这些内容放在应用包中，为了定位应用包中的资源，则需要使用NSBundle类。
  
  NSBundle类提供了在程序包中查找资源的相关方法。
  - 使用mainBundle方法来实例化得到一个NSBundle类对象。
  - 使用pathForResource方法来获取某个资源的路径，返回一个NSString类型对象。
  
  ```
  NSString *filePath = [[NSBundle mainBundle] pathForResource:@"myfile" ofType:@"txt"];   
  NSLog(@"%@",filePath);
      
  NSString *fileString = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
  NSLog(@"%@",fileString);
  ```
  
  ## 第五章 Objective-C语言特性
  ### 5.1 代码块
  Block是对C语言的一个扩展，在Objective-C中完全支持。Block在现在的iOS开发中使用越来越普遍，Block就是封装了一组代码语句的对象，可以在任何时间执行。
  #### 5.1.1 Block简介
  Block块是封装工作单元的对象，是可以在任何时间执行的代码段。其本质上是可移植的匿名函数，可以作为方法和函数的参数传入，可以从方法和函数中返回。
  
  1. Block的定义与调用
  块是以插入字符^开头，后面的一个括号内表示块所需要的参数，最后面的大括号中的块主体，最后以分号结束。
  ```
  ^(int inputNum){
  NSLog(@"printBlock Called");
  return inputNum;
  };
  ```
  代码块也可以进行赋值
  ```
  int (^printBlock)(int) =  ^(int inputNum){
  NSLog(@"printBlock Called");
  return inputNum;
  };
  ```
  当需要调用已定义的Block时。
  ```
  int i = printBlock(100);
  ```
  2. 把Block声明为类的属性
  由于Block就是一个存储了一段代码的对象，因此也可以把Block设置为某个类的属性。
  Block属性与其他类型的属性，如NSString、NSArray没有什么本质区别，都可以使用点句
  法来对属性进行取值和赋值。
  申命两个Block属性
  ```
  #import <UIKit/UIKit.h>
  @interface ViewController : UIViewController
  @property(copy) void (^blockProperty)(void);
  @property(copy,nonatomic)void (^blockPropertyWithInput)(int);
  @end
  ```
  在实现文件中，通过点语法为两个Block属性赋值，然后再调用Block中的代码。
  ```
  #import "ViewController.h"
  @interface ViewController ()
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.blockProperty = ^{
          NSLog(@"blockProperty被调用!");
      };
      self.blockProperty();
      
      self.blockPropertyWithInput = ^(int i) {
          NSLog(@"blockPropertyWithInput被调用!,输入的参数是%d",i);
      };
      self.blockPropertyWithInput(150);
  }
  @end
  ```
  #### 5.1.2 Block的参数与返回值
  1. 无输入参数+无返回值
  ```
  void (^blockWithoutInputAndOutput)(void) = ^(void){
              NSLog(@"欢迎访问 www.99ios.com");
  };
  blockWithoutInputAndOutput();
  ```
  2. 有输入参数+无返回值
  ```
  void (^blockWithInput)(int)=^(int inputNum){
              NSLog(@"blockWithInput 被调用！输入参数的值为%d.",inputNum);
  };
  blockWithInput(99);
  ```
  3. 有输入参数及返回值
  ```
  int (^blockWithOutputAndInput)(int) = ^(int inputNum){
            NSLog(@"blockWithOutputAndInput 被调用!");
            return inputNum * inputNum;
  };
  int a = blockWithOutputAndInput(100);
  NSLog(@"blockWithOutputAndInput 的返回值是:%d",a);
  ```
  4. 有多个输入参数
  ```
  double(^multiplyTwoValues)(double,double) = ^(double number1,double number2){
              return number1 *number2;
  };
  double doubleNumber = multiplyTwoValues(5.0,5.6);
  NSLog(@"multiplyTwoValues:%f",doubleNumber);
  ```
  5. 无输入参数+有返回值
  ```
  int (^blockWithOutput) (void) = ^(void){
              NSLog(@"blockWithOutput 被调用");
              return 100;
  };
  int a = blockWithOutput();
  NSLog(@"blockWithoutput的返回值:%d",a);
  ```
  #### 5.1.3 操作Block外部的变量
  1. 访问Block之外的变量
  如果在一个方法中声明了Block,那么Block中也可以访问在该方法中定义的变量，前提是该变量的定义在Block定义之前。
  ```
  int i = 100;
  void (^beginBlock)(void) = ^(void){
  NSLog(@"i 在Block中获取的值:%d",i);
  };
  beginBlock();
  i =200;
  beginBlock();
  NSLog(@"i的当前值:%d",i);
  ```
  2. 修改Block之外的变量 
  在Block中，假如需要更新在Block之外定义的变量，那么在定义变量时，必须加上_ _ block关键字。
  ```
  __block int i = 100;
  void (^beginBlock)(void) = ^(void){
  NSLog(@"i 在Block中获取的值:%d",i);
  };
  beginBlock();  
  i =200;
  beginBlock();
  NSLog(@"i的当前值:%d",i);
  ```
  #### 5.1.4 Block回调
  在iOS的开发过程中，Block的回调使用非常普遍，也是Block的重要用法之一，在使用过程中经常可以用于替换代理的实现方法。
  
  当需要定义回调Block时，通常情况下可以按照如下步骤进行：
  - 定义带Block参数的方法。
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  @interface Task : NSObject
  -(void) beginTaskWithCallbackBlock:(void (^)(void)) callBackBlock;
  @end
  NS_ASSUME_NONNULL_END
  ```
  - 设置Block的回调时机。
  ```
  #import "Task.h"
  @implementation Task
  -(void)beginTaskWithCallbackBlock:(void (^)(void))callBackBlock{
      NSLog(@"任务开始,3秒后调用block中的代码！现在时间是:%@",[NSDate date]);
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
          callBackBlock();
      });
  }
  @end
  ```
  - 定义Block中需要执行的操作。
  ```
  #import "ViewController.h"
  #import "Task.h"
  @interface ViewController ()
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      Task *task = [[Task alloc] init];
      [task beginTaskWithCallbackBlock:^{
          NSLog(@"block中的代码被执行！现在时间是:%@",[NSDate date]);
      }];
  }
  @end
  ```
  ### 5.2 分类
  
  
  ### 5.3 协议
  #### 5.3.1 协议简介
  协议是多个类共享的一个方法列表，在协议中列出的方法，在定义协议的类中并没有给出具体的实现，而协议的实现的功能是在遵守协议的类中定义的。通过协议可以实现对象之间的通信，同时又能够使类的定义更加通用。
  
  1. 协议的实现步骤
  - 添加协议，并设置协议中包含的方法，同时添加一个属性用于设置遵守协议的对象。
  - 设置触发执行协议中方法的时机。
  - 在遵守协议的类中，实现协议中方法的具体功能。
  
  #### 5.3.2 代理
  1. 代理协议(Delegate)
  在iOS开发中，经常使用到代理协议以及数据源协议。所谓代理协议，通俗来讲，就是委托别人办事。
  
  2. 代理协议的实现
  - 在自定义视图类MYView.h文件中，设置类引用@class、定义代理协议名称、定义代理协议中包含的方法、添加代理属性(注意使用weak属性)。
  ```
  #import <UIKit/UIKit.h>
  
  @class MYView; //设置类应用class
  
  @protocol MyViewDelegate <NSObject> //定义代理协议名称
  -(void) myView:(MYView *) myView clickMYButtonShowAlert:(NSString *)message; //定义代理协议中包含的方法
  
  @end
  
  @interface MYView : UIView
  @property (nonatomic,weak) id <MyViewDelegate> delegate; //添加代理方法
  @end
  ```
  - 在MYView.m文件中，监听代理协议定义事件的发生。当事件发生时，通知遵守代理协议的对象去工作，即设置在实现代理协议的类中，代理协议方法执行的时机。使用respondsToSelector方法判断一下对象中是否已经实现了该协议的方法
  ```
  #import "MYView.h"
  @implementation MYView
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      if([self.delegate respondsToSelector:@selector(myView:clickMYButtonShowAlert:)]){
          [self.delegate myView:self clickMYButtonShowAlert:@"视图被点击了"];
      }
  }
  @end
  ```
  - 在需要遵守代理协议的类中，引用头文件并遵守代理协议，遵守代理协议需要在类的接口部分使用<>符号来声明该类需要遵守的协议，同一个类可以遵守多个协议。
  ```
  #import "MYView.h"
  
  @interface ViewController () <MyViewDelegate>
  @property (nonatomic,strong) MYView *myView;
  @end
  ```
  - 设置代理对象
  ```
  -(MYView *)myView{
      if(_myView ==nil){
          _myView = [[MYView alloc]init];
          _myView.frame = CGRectMake(0, 500, 320, 50);
          _myView.backgroundColor = [UIColor yellowColor];
          _myView.delegate = self;
      }
      return _myView;
  }
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.view];
  }
  ```
  - 实现协议方法。即当触发条件发生时，执行的动作。
  ```
  -(void)myView:(MYView *)myView clickMYButtonShowAlert:(NSString *)message{
      //__func__ 用于打印当前函数名
      NSLog(@"%s",__func__);
      NSLog(@"传递的消失是:%@",message);
  }
  ```
  ### 5.4 KVC
  #### 5.4.1 使用KVC赋值取值
  KVC(Key-value coding)即键值编码，对应了NSKeyValueCoding类。NSKeyValueCoding类是对NSObject类进行的扩展，因此所有的类都可以使用NSKeyValueCoding类中定义的方法。其最基本的使用就是可以对对象属性继续宁赋值和取值，可以起到和点语法同样的效果。
  
  - 在Person.h文件中添加如下代码
  ```
  #import <Foundation/Foundation.h>
  #import "Dog.h"
  NS_ASSUME_NONNULL_BEGIN
  
  @interface Person : NSObject
  
  @property (nonatomic,copy) NSString *personName;
  @property (nonatomic,strong) Dog *dog;
  
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  - 在Dog.h文件中添加如下代码
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface Dog : NSObject
  
  @property (nonatomic,copy) NSString *dogName;
  @property (nonatomic,copy) NSString *dogAge;
  
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  下面的示例代码综合使用了KVC中有关赋值/取值的方法.
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "Person.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          Person *person = [[Person alloc]init];
          Dog *dog = [[Dog alloc]init];
          //使用kvc赋值
          [dog setValue:@"tom" forKey:@"dogName"];
          [person setValue:@"shixin" forKey:@"personName"];
          [person setValue:dog forKey:@"dog"];
          [person setValue:@2 forKeyPath:@"dog.dogAge"];
          
          //使用KVC取值
          NSString *personName = [person valueForKey:@"personName"];
          NSString *dogName = [person valueForKeyPath:@"dog.dogName"];
          NSString *dogAge = [person valueForKeyPath:@"dog.dogAge"];
          
          NSLog(@"<%@>的宠物狗名<%@>,它<%@>岁了",personName,dogName,dogAge);
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  #### 5.4.2 字典转模型
  KVC除了最简单的对对象属性进行赋值和取值外，在NSKeyValueCoding类中，还提供了SetValuesForKeysWithDictionary方法。**该方法专门用于把一个字典转换成一个模型对象，但使用过程中要求字典中的键值和类中定义的属性名称必须完全一致。**假如有不一致的情况，就需要在类的实现文件中，对名称不一致的键值需要使用setValue:forUnderfinedKey方法进行特殊处理。
  
  在Person.h文件中添加idNumber、name和age3个属性。
  ```
  @interface Person : NSObject
  
  @property (nonatomic,copy)NSString *idNumber;
  @property (nonatomic,copy)NSString *name;
  @property (nonatomic,assign) int age;
  
  @end
  ```
  在Person.m文件中使用setValue:forUndefinedKey方法对idNumber属性的赋值方法进行特殊处理，即字典中的id键值对的value需要赋值给idNumber属性。
  ```
  -(void)setValue:(id)value forUndefinedKey:(nonnull NSString *)key{
      if([key isEqualToString:@"id"]){
          self.idNumber = (NSString *)value;
      }
  }
  ```
  在main函数中，使用setValuesForKeysWithDictionary:方法来把一个字典转换成一个Person类的模型对象。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "Person.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDictionary *dict = @{
              @"id" :@1234567,
              @"name" :@"99iOS",
              @"age":@2
          };
          Person *person = [[Person alloc]init];
          [person setValuesForKeysWithDictionary:dict];
          NSLog(@"idNumber:%@",person.idNumber);
          NSLog(@"NAME:%@",person.name);
          NSLog(@"age:%d",person.age);
      }
      return 0;
  }
  ```
  #### 5.4.3 修改readonly的属性以及私有属性
  
  ### 5.5 KVO
  KVO(Key Value Observing)可以实现模型和视图的联动机制，即数据模型发生了修改之后，立即将改变呈现到视图View上去的一种双向绑定的机制。
  
  - 模型对象注册指定KeyPath的监听方法。通常情况下，当模型对象的指定Key发生变化时，通知视图对象。
  ```
  - (void)addObserver:(NSObject *)observer 
           forKeyPath:(NSString *)keyPath 
              options:(NSKeyValueObservingOptions)options 
              context:(void *)context;
  ```
  - 视图对象的监听回调方法，在该方法中可以获取数据模型变化前后的数据
  ```
  - (void)observeValueForKeyPath:(NSString *)keyPath 
                        ofObject:(id)object 
                          change:(NSDictionary<NSKeyValueChangeKey, id> *)change 
                         context:(void *)context;
  ```
  - 删除指定Key路径的监听器
  ```
  - (void)removeObserver:(NSObject *)observer 
              forKeyPath:(NSString *)keyPath 
                 context:(void *)context;
  ```
  使用KVO实现模型与视图联动的步骤
  - 创建数据模型对象，并且注册需要监听的KeyPath.
  - 在视图类中，实现监听回调方法，即当收到模型对象指定KeyPath发生变化时，对界面UI执行的更新操作。
  
  实现过程
  - 定义Person模型类，并添加一个name属性
  ```
  #import <Foundation/Foundation.h>
  @interface Person : NSObject
  @property(nonatomic,copy)NSString *name;
  @end
  ```
  - 定义MYLabel视图类，继承自UILabel，在MYLabel.h中添加一个Person类型的属性，该属性为MYLabel提供展示的数据.
  ```
  #import <UIKit/UIKit.h>
  #import "Person.h"
  @interface MYLabel : UILabel
  @property (nonatomic,strong) Person *viewData;
  @end
  ```
  - 在MYlabel.m文件中，重写viewData属性的setter方法，当设置viewData属性时，更新MYLabel上的文字显示。
  ```
  #import "MYLabel.h"
  @implementation MYLabel
  -(void)setViewData:(Person *)viewData{
      _viewData = viewData;
      self.text = viewData.name;
  }
  ```
  - 在MYLabel.m文件中，实现视图对象的监听回调方法，该方法在模型数据发生变化时会调用，此时会把数据模型中最新的数据从change参数中获取，等获取到最新的数据后，跟新MYLabel的文字显示。
  ```
  -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{
      NSString *newText = change[@"new"];
      self.text = newText;
  }
  ```
  - 在ViewController.m文件中，添加Person类型的属性以及MYLabel类型的属性，并对myLabel属性进行懒加载操作。
  ```
  #import "MYLabel.h"
  #import "Person.h"
  
  @interface ViewController ()
  @property (nonatomic,strong) Person *myPerson;
  @property (nonatomic,strong) MYLabel *myLabel;
  
  @end
  
  -(MYLabel*)myLabel{
      if(_myLabel == nil){
          _myLabel = [[MYLabel alloc] initWithFrame:CGRectMake(150,150,100,100)];
          _myLabel.backgroundColor = [UIColor redColor];
          _myLabel.textColor = [UIColor whiteColor];
      }
      return _myLabel;
  }
  ```
  - 在ViewDidLoad方法中，创建Person类对象，并注册需要监听的KeyPath。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      
      [self.view addSubview:self.myLabel];
      Person *person = [[Person alloc]init];
      self.myPerson = person;
      [person addObserver:self.myLabel forKeyPath:@"name" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];
  
  }
  ```
  - 单击屏幕时，更新Person类对象的值，此时会调用MYLabel类中的observeValueForKeyPath:ofObject:change:context:方法，从而更新MYLabel对象的显示
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      self.myPerson.name = [NSString stringWithFormat:@"%d",arc4random_uniform(1000000)];
  }
  ```
  ## 第六章 Objective-C进阶
  ### 6.1 对象复制
  #### 6.1.1 浅复制与深复制的简介
  在Objective-C中，基本数据类型的复制都会在内存中对需要赋值的变量创建一个副本。而对象的复制有两种形式:浅复制与深复制
  
  - 浅复制:将原始对象的指针值复制到副本中，即指针复制，原始对象和副本共享引用的数据，相当于创建了一份新的文件。
  - 深复制:复制原始对象指针所引用的数据，并将赋给副本对象，即内容复制，相当于创建了一份新的文件。
  - 当属性添加copy关键字时，那么对这个属性赋值时，就会执行深复制操作，同时还需要该类遵守NSCopying协议。当把属性关键字改为strong或者weak时，那么对这个属性赋值时，就会执行浅复制。
  
  
  新增一个ClassA类，添加一个NSString类型的name1属性，并添加copy关键字，添加一个NSString类型的name2属性，并添加strong关键字。
  ```
  @property (nonatomic,copy) NSString *name1;
  @property (nonatomic,strong) NSString *name2;
  ```
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "ClassA.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *string = [[NSMutableString alloc]initWithFormat:@"www.99ios.com"];
          ClassA *classA = [[ClassA alloc]init];
          
          classA.name1 = string;
          classA.name2 = string;
          
          [string appendString:@"+"];
          
          NSLog(@"原字符串值:%@,内存地址:%p",string,string);
          NSLog(@"name1复制字符串值:%@,内存地址:%p",classA.name1,classA.name1);
          NSLog(@"name2复制字符串值:%@,内存地址:%p",classA.name2,classA.name2);
      }
      return 0;
  }
  ```
  #### 6.1.2 可变对象复制与不可变对象复制
  
  #### 6.1.3 自定义对象复制
  对于自定义对象的复制，首先要保证在类的定义中遵守NSCopying协议，然后实现copyWithZone：方法，对于自定义对象的复制特性，都取决于copyWithZone:方法中的实现情况，对于类中定义的属性也需要综合考虑其定义中有关内存管理的特性。
  
  1. 类的定义与复制
  为了实现对该类对象的复制，要求ClassB类遵守NSCopying协议，同时在类的.m文件中实现copyWithZone:方法，在该方法中的实现逻辑决定了当调用copy方法时，对该类对象进行复制所采取的方法。
  
  ```
  #import <Foundation/Foundation.h>
  #import "ClassA.h"
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface ClassB : NSObject <NSCopying>
  
  @property (nonatomic,copy)NSString *name;
  @property (nonatomic,strong) ClassA *customClass;
  @property (nonatomic,weak) id delegate;
  @property (nonatomic,assign) int number;
  @end
  NS_ASSUME_NONNULL_END
  ```
  2. 浅复制该类的对象
  当仅仅需要对该对象进行浅复制时，可以在copyWithZone:方法中，直接返回要复制的对象即可。
  ```
  #import "ClassB.h"
  @implementation ClassB 
  - (nonnull id)copyWithZone:(nullable NSZone *)zone {
      return self;
  }
  @end
  ```
  3. 深复制该类的对象
  当需要对自定义对象深复制时，需要在copyWithZone:方法中调用alloc以及init方法，重新开辟一块新的内存空间。另外，对于属性的复制过程中，也需要考虑到属性自身的特性。
  ```
  - (nonnull id)copyWithZone:(nullable NSZone *)zone {
      ClassB *copyObject = [[[self class]allocWithZone:zone] init];
      copyObject.name = [self.name mutableCopy];
      copyObject.customClass = self.customClass;
      copyObject.delegate = self.delegate;
      copyObject.number = self.number;
      return copyObject;
      //return self;
  }
  ```
  
  
  4. 深复制与浅复制代码验证
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "ClassA.h"
  #import "ClassB.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          ClassA *classA = [[ClassA alloc]init];
          ClassB *myClass1 = [[ClassB alloc]init];
          myClass1.name = @"ABC";
          myClass1.customClass = classA;
          myClass1.delegate = classA;
          myClass1.number =100;
          ClassB *myClass2 = [myClass1 copy];
          NSLog(@"对象类:[%@]原对象内存地址:[%p],复制对象内存地址:[%p]",[ClassB class],myClass1,myClass2);
          NSLog(@"[原对象]:copy属性-[%p],strong属性-[%p],weak属性-[%p],assign属性-[%d]",myClass1.name,myClass1.customClass,myClass1.delegate,myClass1.number);
          NSLog(@"[复制对象]:copy属性-[%p],strong属性-[%p],weak属性-[%p],assign属性-[%d]",myClass2.name,myClass2.customClass,myClass2.delegate,myClass2.number);
      }
      return 0;
  }
  ```
  ### 6.2 内存管理
  1. 引用计数
  引用计数是在Object-C中用于管理对象生命周期的机制，这种机制可以很有效地管理对象的生命周期。当一个对象被创建时，它的引用计数为1。每当有新的指针指向这个对象时，这个对象的引用计数就加1.当某个指针不再指向这个对象时，该对象的应用计数减1。当该对象的应用计数为0时，该对象就自动销毁，占用的内存被回收。
  2. MRC(手工引用计数)
  MRC在Xcode4.2版本之前，对象的引用计数都需要程序员来手工管理，因此，程序员需要花费大量的精力来管理对象的创建于销毁，其中一个最基本的原则就是：谁创建谁销毁。
  
  3. ARC(自动引用计数)
  随着Xcode4.2的版本发布，苹果引用了其中一个新特性就是自动引用计数。与MRC不同，自动引用计数模式中，对象的引用计数管理完全交由系统来管理，也就是说，在MRC中的retain/release操作都由系统自动完成了。
  
  ### 6.3 预编译指令
  预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符串外的第一个字符。#号后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。预处理过程先于编译器对源代码进行处理，还会删除程序中的注释和多余的空白字符。
  
  #### 6.3.1 宏定义
  宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以像函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。#define 预处理指令是用来定义宏的，宏的作用范围是从宏定义的那一行开始，直到文件尾。
  1. 无参宏
  - 定义符号常量
  ```
  #define PI 3.14 
  ```
  - 定义表达式
  ```
  #define LARGE (100+100)
  ```
  - 定义字符串常量
  ```
  #define WEBNAME "www.99ios.com"
  ```
  - 定义符号
  ```
  #define AND &&
  ```
  - 宏定义中
  ```
  #define TWO_PI(2.0*PI)
  ```
  2. 有参宏
  - 当使用有参宏时，需要传入必要的参数参与运算。
  ```
  #define 宏名(参数列表)宏体
  ```
  - 定义一个又一个参数的宏,求参数的平方值
  ```
  #define SQUARE(a) ((a)*(a))
  ```
  - 使用续行符定义多行的宏。\\被称为续行符，表示下一行是本行的延续。在\\符号所在行之后不能加任何空白字符。
  ```
  #define LARGER(a,b) ({\\
  int m=a,n=b;m>n ? m:n;\\
  })
  ```
  3. 运算符#
  出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #define STRING(n) #n
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSLog(@"%s",STRING(www.99ios.com));
      }
      return 0;
  }
  ```
  4. 运算符##
  ##运算符用于把多个参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  #define STRING(a,b,c) (a##b##c)
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSLog(@"%f",STRING(13.6,2,3));
      }
      return 0;
  }
  ```
  #### 6.3.2 #include、#import与@class
  ```
  #include <类名.h>
  ```
  这种格式告诉预处理程序在编译器自带的或外部库的头文件中搜索被包含的头文件。
  ```
  #include "类名.h"
  ```
  这种格式告诉预处理程序在当前被编译的应用程序的源代码文件中搜索被包含的头文件，如果找不到，再搜索编译器自带的头文件。
  
  #import与#include 是一样的，@class指令与#import的功能类似。**但是使用@class不能引入类中的属性和方法。**
  
  #### 6.3.3 条件编译
  条件编译指令决定哪些代码将被编译，而哪些是不被编译的。例如NSLog函数，可以定义只有在版本调试debug状态时才打印日志，在版本发布release状态时不打印日志。
  - #if 指令检测跟在关键字后的宏或者常量表达式的值，如果值为真，则编译后面的代码。直到出现#else,#elif或#endif为止，反之则不执行。
  - #elif预处理指令综合了#else和#if指令的作用。类似于else if.
  - #else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。
  
  
  ### 6.4 NSLog函数
  
  ### 6.5 结构
  #### 6.5.1 结构的定义与基本使用
  1. 结构类型的定义
  ```
  struct Date {
  int day;
  int month;
  int year;};
  ```
  2. 结构变量的声明
  ```
  struct Date today;
  ```
  3. 结构变量的赋值/初始化
  ```
  today.day = 2;
  today.month = 9;
  today.year = 2016;
  ```
  4. 结构体成员变量的访问
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          struct Date {
              int day;
              int month;
              int year;
          };
          struct Date today;
          today.day = 2;
          today.month = 9;
          today.year = 2016;
          NSLog(@"今天是:%d年%d月%d日",today.year,today.month,today.day);
      }
      return 0;
  }
  ```
  ## 第七章 基础UI控件
  ### 7.1 UIKit框架
  ### 7.2 视图UIView
  #### 7.2.1 UIView简介
  #### 7.2.2 视图UIView的外观
  #### 7.2.3 视图UIView的形变
  #### 7.2.4 视图UIView的层次关系
  #### 7.2.5 视图UIView的动画
  #### 7.2.6 响应用户交互事件
  UIView类的对象都具有响应用户交互的能力，因为UIView继承自UIResponder.在初始化视图对象的过程中，可以给UIView对象添加手势，以响应用户交互。另外，对于自定义视图类，可以通过实现其有关触摸的相关方法，来定义用户交互的动作。
  
  1. 与用户交互事件相关属性
  UIView类中，userInteractionEnabled属性可以用来自定义视图类对象是否能够响应用户交互。
  **在UILabel、UIImageView子类中该属性默认情况下是关闭的，**另外multipleTouchEnabled属性用于设置视图对象能否支持多点触控，默认情况下，其取值是NO。
  ```
  //是否支持用户交互
  @property(nonatomic, getter=isUserInteractionEnabled) BOOL userInteractionEnabled;
  //是否支持多点触控
  @property(nonatomic, getter=isMultipleTouchEnabled) BOOL multipleTouchEnabled;
  ```
  2. 添加手势
  对于视图类对象，都可以通过添加手势的方法来响应用户的交互。一个视图类对象，可以添加多个手势。
  - 获取视图对象上的所有手势
  ```
  @property(nonatomic, readonly, copy) NSArray<UIGestureRecognizer *> *gestureRecognizers;
  ```
  - 添加手势
  ```
  - (void)addGestureRecognizer:(UIGestureRecognizer *)gestureRecognizer;
  ```
  - 移除手势
  ```
  - (void)removeGestureRecognizer:(NSGestureRecognizer *)gestureRecognizer;
  ```
  在ViewController.m文件中添加以下示例代码。
  ```
  #import "ViewController.h"
  
  @interface ViewController ()
  @property (nonatomic,strong)UIView *myView;
  @end
  
  @implementation ViewController
  
  
  -(UIView *)myView{
      if(_myView == nil){
          _myView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
          _myView.backgroundColor = [UIColor redColor];
      }
      return _myView;
  }
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.myView];
      //添加长按手势
      UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction)];
      [self.myView addGestureRecognizer:longPress];
      UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)];
      [self.myView addGestureRecognizer:tap];
      NSLog(@"myView gesture :%@",self.myView.gestureRecognizers);
  }
  
  -(void)longPressAction{
      NSLog(@"%s",__func__);
     
      UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示" message:@"长按" delegate:nil cancelButtonTitle:nil otherButtonTitles:@"OK", nil];
      
      [alertView show];
  }
  
  -(void)tapAction{
      NSLog(@"%s",__func__);
      
      UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示" message:@"点击了" delegate:nil cancelButtonTitle:nil otherButtonTitles:@"OK", nil];
      [alertView show];
  }
  @end
  ```
  #### 7.2.7 内容模式contentMode
  视图的contentMode属性决定了边界变化和缩放操作作用到视图上产生的效果。视图在屏幕上显示后，渲染后的内存会被缓存在视图的图层上，当视图的大小发生变化时，UIKit并不强制对视图进行重画，而是根据其contentMode属性决定如何显示缓存内容。由于这种机制的存在，当修改视图的大小时，可以提升性能。
  
  1. contentMode简介
  contentMode经常用于图像视图UIImageView。当希望在app中调整控件的尺寸时，务必优先考虑使用contentMode,这样做可以在视图的外观发生形变时，避免编写定制的描画代码。
  ```
  @property(nonatomic)UIViewContentMode contentMode;
  ```
  在开发过程中，当发生以下两种情况时，会使用到contentMode:
  - 改变frame或bounds中的高度或宽度
  - 修改transform属性。
  
  2. 常见的contentMode
  ```
  UIViewContentModeScaleToFill
  如有必要，可以通过更改内容的纵横比来缩放内容以适应其自身的大小。
  UIViewContentModeScaleAspectFit
  通过保持纵横比来缩放内容以适应视图大小的选项。视图边界的任何剩余区域都是透明的。
  UIViewContentModeScaleAspectFill
  缩放内容以填充视图大小的选项。内容的某些部分可能会被剪裁以填充视图的边界。
  UIViewContentModeRedraw
  通过调用 setNeedsDisplay 方法在边界更改时重新显示视图的选项。
  UIViewContentModeCenter
  使内容在视图边界居中的选项，保持比例不变。
  UIViewContentModeTop
  将在视图边界顶部对齐的内容居中的选项。
  UIViewContentModeBottom
  将在视图边界底部对齐的内容居中的选项。
  UIViewContentModeLeft
  在视图左侧对齐内容的选项。
  UIViewContentModeRight
  在视图右侧对齐内容的选项。
  UIViewContentModeTopLeft
  对齐视图左上角内容的选项。
  UIViewContentModeTopRight
  对齐视图右上角的内容的选项。
  UIViewContentModeBottomLeft
  对齐视图左下角的内容的选项。
  UIViewContentModeBottomRight
  在视图的右下角对齐内容的选项。
  ```
  3. contentMode的设置方法
  - 使用storyboard设置。选中一个视图控件，可以在右侧的选项中设置contentMode.
  ![dc6cf195.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\dc6cf195.png)
  - 使用代码来设置contentMode.UIView类中提供了contentMode属性,其是一个UIViewContentMode类型的属性，默认取值为UIViewContentModeScaleToFill。
  
  #### 7.2.8 图片拉伸
  #### 7.2.9 使用代码创建自定义UIView
  #### 7.2.10 使用XIB创建自定义UIView
  - 新增一个NibView类，继承自UIView
  ![4b9d0fb2.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\4b9d0fb2.png)
  - 新增一个XIB文件，命名为NibView.xib
  ![50df840d.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\50df840d.png) 
  - 使用XIB绘制UIView的界面，添加子视图并设置约束关系。
  ![1f8cfe80.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\1f8cfe80.png)
  - 由于使用XIB在初始化时不会调用initWithFrame方法，而是调用initWithCoder方法。因此在.h文件中定义一个类方法initFromNib，并在.m文件中对该方法进行实现。该方法的主要功能从XIB文件中加载，该方法会调用initWithCoder 方法。
  ```
  #import <UIKit/UIKit.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface NibView : UIView
  
  @property (weak,nonatomic) IBOutlet UIView *subView;
  +(NibView*)initFromNib;
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  
  
  ```
  #import "NibView.h"
  
  @implementation NibView
  
  //加载XIB布局
  +(NibView *)initFromNib{
      NSLog(@"%s",__func__);
      return [[[NSBundle mainBundle] loadNibNamed:@"NibView" owner:self options:nil]lastObject];
  }
  
  //只要对象是从文件解析来的，就会调用
  -(instancetype) initWithCoder:(NSCoder *)coder{
      NSLog(@"%s",__func__);
      self = [super initWithCoder:coder];
      if(self){
          
      }
      return self;
  }
  //从xib或者storyboard加载完毕就会调用
  -(void)awakeFromNib{
      [super awakeFromNib];
      NSLog(@"%s",__func__);
      self.alpha =0.5;
  }
  
  //当需要对子视图进行重新布局的时候
  -(void)layoutSubviews{
      NSLog(@"%s",__func__);
  }
  //当需要自定义绘图的时候
  -(void)drawRect:(CGRect)rect{
      NSLog(@"%s",__func__);
  }
  
  @end
  ```
  然后在ViewController加载布局
  ```
  #import "ViewController.h"
  #import "NibView.h"
  @interface ViewController ()
  @property (nonatomic,strong)UIView *myView;
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      NibView *nibView = [NibView initFromNib];
      [self.view addSubview:nibView];
  }
  @end
  ```
  
  注意：
  initWithCoder：使用文件加载的对象调用（如从xib或stroyboard中创建）
  initWithFrame：使用代码加载的对象调用（使用纯代码创建）
  
  #### 7.2.11 控件改变坐标系
  ### 7.3 图片控件UIImageView
  #### 7.3.1 基本使用
  #### 7.3.2 常用操作
  #### 7.3.3 帧动画功能
  ### 7.4 按钮控件UIButton
  #### 7.4.1 基本使用
  #### 7.4.2 按钮的创建
  #### 7.4.3 调整图标与标题的位置
  ### 7.5 文本控件UILabel
  #### 7.6 提示框控件UIAlertController
  苹果自iOS8开始，就已经废弃了之前用于界面提醒的UIAlertView类以及UIActionSheet,取而代之的是UIAlertController以及UIAlertAction。
  
  1. UIAlertController的使用
  - UIAlertController实例化方法，通过该方法可以创建一个UIAlertController类的对象。
  ```
  + (instancetype)alertControllerWithTitle:(NSString *)title message:(NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;
  ```
  - 在提醒对象中添加按钮，每个按钮都是一个UIAlertAction类的对象。
  ```
  -(void)addAction:(UIAlertAction *)action;
  ```
  - 在界面上显示提醒信息
  ```
  - (void)presentViewController:(NSViewController *)viewController animator:(id<NSViewControllerPresentationAnimator>)animator;
  ```
  - 显示样式
  ```
  //在呈现它的视图控制器的上下文中显示的操作表。
  UIAlertControllerStyleActionSheet
  //为应用程序模态显示的警报。
  UIAlertControllerStyleAlert
  ```
  2. UIAlertAction的使用
  UIAlertAction是定义提醒每个按钮的样式以及用户点击后执行的操作，每个UIAlertAction对象都需要添加到一个UIAlertController对象上才能生效。当需要创建UIAlertAction对象时，可以使用如下类方法
  ```
  + (instancetype)actionWithTitle:(NSString *)title style:(WKAlertActionStyle)style handler:(WKAlertActionHandler)handler;
  ```
  3. 示例代码
  ```
  -(void)viewDidAppear:(BOOL)animated{
      UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"提示" message:@"是否要访问99IOS" preferredStyle:UIAlertControllerStyleAlert];
      
      UIAlertAction *defaultAction = [UIAlertAction actionWithTitle:@"YES" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){
          NSLog(@"点击了 YES");
      }];
      
      UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"NO" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action){
          NSLog(@"点击了 NO");
      }];
      
      [alert addAction:defaultAction];
      [alert addAction:cancelAction];
      
      [self presentViewController:alert animated:YES completion:nil]; 
  }
  ```
  
  
  #### 7.7 文本输入框UITextField
'''
linesHighlighted: [
  1791
  1790
]
isStarred: false
isTrashed: false
