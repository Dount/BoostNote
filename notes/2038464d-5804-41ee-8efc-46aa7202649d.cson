createdAt: "2022-01-20T02:36:31.286Z"
updatedAt: "2022-06-02T05:42:07.584Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "IOS 开发：从零基础到精通"
tags: []
content: '''
  # IOS 开发：从零基础到精通
  [TOC]
  
  
  # 第一部分
  ## 第一章 IOS介绍
  ### 1.1 Xcode 常用快捷键
  ```
  注释某行/取消注释某行:command+/
  代码整体向上移动:command+option+[(windows上option替换alt)
  代码整体向下移动:command+option+](windows上option替换alt)
  在单个文件中搜索关键字: command+F
  在整个工程中搜索关键字: command+shift+f
  查看方法实现: command+单击
  查看方法帮助: option+单击(windows上option替换alt)
  前一个打开的文件:ctrl+command+方向键
  后一个打开的文件:ctrl+command+方向键
  ```
  ### 1.2 Code Snippets快捷代码段
  创建自定义CodeSnippet
  ![2e8c2b33.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\2e8c2b33.png)
  
  自定义codeSnippet
  ![ebb4c2bb.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\ebb4c2bb.png)
  
  使用codeSnippet
  ![19e1bf87.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\19e1bf87.png)
  ![cc1a62c7.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\cc1a62c7.png)
  
  导出或导入CodeSnippet
  Xcode 的 CodeSnippet 目录 ~/Library/Developer/Xcode/UserData/CodeSnippet。
  如果你没有创建过自定义的CodeSnippet，那么就不会有CodeSnippet文件夹.
  
  把CodeSnippet文件夹的自定义CodeSnippet代码块全部保存到你想保存的地方,换电脑或者重装Xcode时,再导入到CodeSnippet文件夹,即可再次使用.
  
  ## 第二章 数据类型和表达式
  ### 2.1 数据类型与常量
  #### 2.1.1 基本数据类型
  ```
  int number = 10;
  NSLog(@"%d",number);
  
  float f = 10.1234;
  NSLog(@"%f",f);
          
  double d = 10.1234;
  NSLog(@"%f",d);
          
  char c = 'a';
  NSLog(@"%c",c);
          
  BOOL b1 = YES;
  BOOL b2 = NO;
  NSLog(@"b1:%d,b2:%d",b1,b2);
  ```
  #### 2.1.2 限定词
  ```
  将number声明为long的整形变量
  long int i1 = 100;
  NSLog(@"i1:%ld",i1);
  
  双长整形相当于双精度long
  long long int i2 = 100;
  NSLog(@"i2:%lld",i2);
          
  告诉编译器要声明的特定变量用来存储相当小的整数。
  short int i3 = 100;
  NSLog(@"i3:%d",i3);
  
  当整数变量只用来存储正数的情况下使用该限定符
  unsigned int i4 = 100;
  NSLog(@"i4:%d",i4);
  
  signed限定词可明确地告诉编译器该整型变量是有符号的。
  signed int i5 = 100;
  NSLog(@"i5:%d",i5);
  ```
  #### 2.1.3 id与instancetype
  id数据类型可存储任何类型的对象。从某种意义上说，它是通用对象类型。
  这和C语言中的void * 很相似。id是一个指向任意一个继承了NSObject类的对象。id是一个指针，所以在使用id的时候不需要加星号。
  
  id类型是Object-c中经常使用的一种重要数据类型，它是Object-C动态绑定的基础。
  ```
  NSArray *array = @[@123,@"99ios"];
  id obj = array[1];
  NSLog(@"%@",obj);
  ```
  在类方法中，例如，以alloc,new开头的方法，以及实例方法中autorelease,init,retain等方法的返回值类型就是instancetype类型。
  这些就称为关联返回类型的方法。这些方法的返回值是一个以方法所在的类为类型的对象。
  ```
  +(instancetype)alloc
  -(instancetype)init
  ```
  
  id和instancetype的异同
  id和instancetype的相同点在于都可以作为方法的返回值类型。
  两者不同点体现在：
  - id可以作为方法或函数的参数类型，也可以单独用这种类型定义变量，但是instancetype不行。
  - 如果方法的返回值类型是instancetype,那么它返回的一定是这个类型的对象，如果方法的返回值类型是id,那么它返回的是未知类型的对象。
  
  ### 2.2 算数表达式
  #### 2.2.1 基本运算符
  #### 2.2.2 数据类型转换
  在Objective-c语言中，类型转换的一般形式为(类型说明符)(表达式)
  该功能是吧表达式的运算结构强制转换成类型说明符所表示的类型。
  ```
  (float)a;
  (int)(x+y);
  ```
  类型转换时，存在以下几种常见形式。
  - 浮点值赋给整型变量，数值的小数部分会被删掉，整数部分不变。
  - 整型值赋给浮点型变量，数值大小不发生变化，数据类型变成浮点型。
  - id类型的对象转换成特定类型的对象。
  ```
  int a= 10,b=4;
  float c=2.0, d= 1.5;
          
  NSLog(@"(float)(a+b)=%f",(float)(a+b));
  NSLog(@"(int)(a+b)=%d",(int)(c+d));    
  NSLog(@"a=%d,b=%d,c=%f,d=%f",a,b,c,d);
          
  int intResult;
  intResult = d;
  NSLog(@"(intResult=d) --> initResult=%d",intResult);
          
  float floatResult;
  floatResult = a;
  NSLog(@"(floatResult=a)-->floatReuslt= %f",floatResult);
      
  id Object;
  NSString *string = @"99iOS";
  Object = (NSString *)string;
  NSLog(@"id object=%@",Object);
  ```
  ### 2.3 循环结构
  #### 2.3.1 for循环
  #### 2.3.2 for-in循环
  在Object-C编程中，for-in循环可以认为是一种增强型的for循环，这个是Objective-C中的一个重要语法。当遇到遍历数据的情况时经常会使用到for-in循环。
  ```
  NSMutableArray *array = [NSMutableArray arrayWithObjects:@"张三",@"李四",@"王五",@"赵六",nil];
  for(NSString *string in array){
  NSLog(@"%@",string);}
  ```
  在for-in循环使用中不允许改变容器中的对象，即不允许删除或者增加枚举容器中的对象。因为对于一个既定的枚举器来说，其内部的对象都已经对其进行了枚举排序，如果你私自添加或者删除对象，那么其既定的枚举序列就发生了改变，而这种改变是系统不能识别的。所以Objective-c中不允许这么做。
  
  若必须在for-in过程中删除一些对象，这时就需要在删除完一个对象时，对循环执行break操作.
  ```
  NSMutableArray *array = [NSMutableArray arrayWithObjects:@"张三",@"李四",@"王五",@"赵六",nil];
  for(NSString *string in array){
  if([string isEqualToString:@"张三"]){
  [array removeObject:string];
  break;
  }}
  ```
  #### 2.3.3 while循环
  #### 2.3.4 break与continue
  ### 2.4 选择结构
  #### 2.4.1 if语句
  #### 2.4.2 switch语句
  #### 2.4.3 条件运算符/三目运算符
  ### 2.5 typedef语句
  Objectvie-C允许开发者为已经定义过的数据类型指派一个别名。需要使用typedef语句。typedef可以定义任意的数据类型，可以是系统自带的数据类型，
  如int,float等。也可以是自定义的类，同时也可以支持枚举或者结构体。
  ```
  typedef int Integer;
  typedef MYPerson *Person;
  typedef CGRect MYRect;
  ```
  使用
  ```
  int number1 = 100;
  Integer number2 = 100;
          
  MYPerson *person1 = [[MYPerson alloc]init];
  Person person2 = [[MYPerson alloc]init];
          
  CGRect frame1 =CGRectMake(0, 0, 100, 100);
  MYRect frame2 =CGRectMake(0, 0, 100, 100);
  ```
  ## 第三章 类、对象与方法
  ### 3.1 类
  #### 3.1.1 类的定义
  在Objective-c中，每个类的定义包括两个部分：接口(interface)和实现(implementation)。接口部分定义在.h文件中，包含类的声明、属性以及方法，主要作用是对外提供访问解耦。实现部分定义在.m文件中，主要用于方法的功能实现。
  
  类定义是一种类型的对象原型，其声明了每个对象都具有的属性(Property),同时还定义了同一类的所有对象都使用的一系列方法(Method)。
  
  接口文件实现
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface Player : NSObject
  @property (nonatomic,assign)int healthPoint;
  @property (nonatomic,assign)int magicPoint;
  
  +(Player *)player; //初始化类方法
  -(void) normalAttack;
  -(void) magicAttack;
  
  @end
  NS_ASSUME_NONNULL_END
  ```
  
  实现文件实现
  ```
  #import "Player.h"
  @implementation Player
  +(Player *) player{
  //实例化对象
  Player *player = [[Player alloc]init];
  //设置属性初始化
  player.healthPoint =100;
  player.magicPoint = 100; 
  return player;
  }
  -(void)normalAttack{   
  }
  -(void)magicAttack{  
  }
  @end
  ```
  
  #### 3.1.2 类的继承
  在Objective-c中创建的类也遵循继承的原则。主要体现在两个方面。
  - 继承父类的属性：当创建一个新的类时，新的类不仅仅包含其自身定义的属性，并且还包括在其父类中定义的属性，以及其父类的父类的属性，并按照这个规则一直追溯到根类。NSObject是所有类的根类，因此，所有类都可以使用NSObject中定义的属性以及方法。
  
  - 继承父类的方法：一个对象既可以访问自身定义的方法，也可以访问所有父类的方法。当需要调用父类的方法时，需要使用到关键字super.
  
  接口文件实现
  ```
  #import "Player.h"
  NS_ASSUME_NONNULL_BEGIN
  @interface Magician : Player
  -(void) specialMagicAttack;
  -(void) mixAttack;
  @end
  NS_ASSUME_NONNULL_END
  ```
  
  实现文件实现
  ```
  #import "Magician.h"
  @implementation Magician
  -(void) specialMagicAttack{
      //调用父类的属性
      self.magicPoint -=50;
  }
  -(void)mixAttack{ 
      //调用父类的方法
      [super normalAttack];
      [super magicAttack];
  }
  @end
  ```
  ### 3.2 属性
  #### 3.2.1 属性的定义
  属性在类的定义中使用非常普遍，属性定义后，会创建一个与该属性名称同名且带下划线的实例变量，与此同时，编译器会根据属性的特性，自动合成该属性对应实例变量的存取方法(getter和setter方法)。
  
  当在类中声明一个属性时，需要在类的@interface代码部分编写
  ```
  @property (attributes) type name;
  ```
  - @property 属性定义关键字
  - attribute 属性的特性，提供了该属性的存储方法以及属性行为的说明，常见的关键字有weak/strong,assign,copy,atomic/nonatomic。
  - type属性的类型说明。
  - name属性的名称。
  
  获取属性的值：在点语法中使用objectName.properyName来获取属性的值，其本至上是调用了属性对应的getter方法。
  
  设置属性的值: 在点语法中使用objectName.properyName = value来给属性直接设值，其本质上是调用了属性对应的setter方法。需要注意的是，属性定义中包含readonly关键字的属性是不能设置值的。
  ```
  MYClass *object = [[MYClass alloc]init];
  //获取属性的值，getter方法
  NSLog(@"name属性初始值:%@",object.name);
  //设置属性的值，setter方法
  NSLog(@"name属性最新值:%@",object.name);
  ```
  
  懒加载指系统不会在初始化时就加载某个对象，而是在第一次调用get方法时候才加载这个对象的内存。懒加载其实就是对属性的getter方法进行重写操作。在懒加载过程中，可以对属性进行一些初始化的操作。
  ```
  @property (nonatomic,strong)NSMutableArray *dataArray;
  -(NSMutableArray *)dataArray{
  if(!_dataArray){
  _dataArray = [NSMutableArray array];
  }
  return _dataArray;
  }
  ```
  #### 3.2.2 公有属性与私有属性
  **在自定义类中，既可以在.h文件中声明属性，也可以在.m文件中声明属性。在.h文件中声明的属性可以供外部调用，称为公有属性。在.m文件中声明的属性，即该类扩展中声明的属性，只能在该类的实现部分使用，称为私有属性。公有属性与私有属性的作用域是不同的，公有属性可以在整个工程中都被调用到，而私有属性只能在该类内部调用。**
  
  在实现文件中，可以定义供类内部使用的专有属性。专有属性的作用域只限于本类，即只能够在该类的内部使用，外部无法访问。
  ```
  @interface Player ()
  @property (nonatomic,copy)NSString *firstName;
  @property (nonatomic,copy)NSString *lastName;
  @end
  
  完成专有属性后，通常建议使用懒加载的方式。
  -(NSString *)firstName {
      if(_firstName == nil){
          _firstName = [NSString stringWithFormat:@""];
      }
      return _firstName;
  }
  
  -(NSString *)lastName {
      if(_lastName == nil){
          _lastName = [NSString stringWithFormat:@""];
      }
      return _lastName;
  }
  ```
  
  在接口文件中，公共属性是可以被外部进行访问和调用的。
  ```
  @property (nonatomic,copy) NSString *name;
  -(NSString *)name{
      if(_name ==nil){
          _name = [self.firstName stringByAppendingString:self.lastName];
      }
      return _name;
  }
  ```
  #### 3.2.3 属性关键字
  在定义属性的时候，需要在括号内说明该属性的特性(attribute)。属性的特性决定了属性在原子性，存取方法以及内存管理3个方面的特性。目前，常用的特性关键字有8个，分别由nonatomic,atomic,readonly,readwrite,strong,weak,assign,copy.
  
  原子性(atomic,nonatomic)
  atomic意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，
  - 当一个变量声明为atomic时，意味着在多线程中只能有一个线程能对它进行访问。
  - 当一个变量声明为atomic时，该变量为线程安全性，但是会影响访问速度。
  - 当一个变量声明为atomic时，在非ARC编译环境下，需要设置访问锁来保证对该变量进行正确的getter/setter.
  
  nonatomic表示非原子的，可以被多个线程访问，效率比atomic快，但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。
  - 当一个变量声明为nonatomic时，意味着多个线程可以同时对其进行访问。
  - 当一个变量声明为nonatomic时，它是非线程安全型，访问速度快。
  - 当一个变量声明为nonatomic时，当两个不同的线程对其访问时，容易失控。
  
  存取方法(readwrite,readonly)
  readwrite是默认值，表示该属性同时拥有setter和getter，即该属性即可以读，也可以写。
  readonly表示只有getter没有setter,即该属性只能读取，不能更新或写入。
  
  内存管理(strong,weak,assign,copy)
  - strong表示实例变量对传入对象要有所有权关系，引用计数加1.
  - weak弱引用在setter方法中，对传入的对象不进行引用计数加1的操作。简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用weak声明的实例变量指向nil.
  - assign简单复制，不更改索引计数，适合简单数据类型。如 int、float、double和NSInteger,CGFloat等。
  - copy 用于希望在内存中保留一份传入值的复制，而不是值自身的情况，即把原来的对象完整地复制到另外一个新的内存区，当副本改变时，原对象并不同时改变，同样，当原对象发送改变时，其副本也不会发生改变，因为原对象与原复制对象存储在独立的两个内存区域中。
  
  copy与strong的区别在于实例对象是对传入对象的副本拥有所有权，而非对象本身。
  
  - strong 自定义对象，控制器对象使用strong,如果不指定，属性默认取值strong.
  - weak代理对象，IBOutlet使用weak.
  - assign基本数据类型，int,float,double,NSInteger,CGFloat使用assgin.
  - copy NSString,NSArray,NSDictionary及其可变子类，Block块代码使用copy
  ```
  @property (nonatomic,strong) MYClass *myclass;
  @property (nonatomic,weak) id delegate;
  @property (nonatomic,assign) int age ;
  @property (nonatomic,copy) NSString *name;
  @property (nonatomic,copy) NSArray *courseResults;
  @property (nonatomic,copy) void (^blockProperty)(void);
  ```
  
  ### 3.3 方法
  #### 3.3.1 方法的定义
  在IOS开发中，调用某个对象定义的方法是通过向对象发送消息的方式进行的，消息的名称对应类中定义的方法名称。消息机制是Objective-C语言区别其它编程语言的一个特性。在Object-c中，有两种类型的方法，分别是实例方法与类方法。
  
  1. 有关方法的基本概念
  ```
  [receiver message];消息传递模型
  ```
  - 消息message: 在iOS开发中，调用一个方法相当于传递一个消息，这里的消息指的是方法名（选择器selector）和参数。
  - 接收者receiver: 通常为一个对象，消息告诉接收者需要去做什么事情。当消息发送的时候，系统从接收者的方法列表中选择最合适的方法并调用。
  - 方法method: 方法都包括方法声明和方法实现两部分，相关代码分别编写在.h和.m文件中。
  - 发送消息：当需要调用一个方法时，通过给实现该方法的对象发送一条消息来实现，简单来说。就是通知对象去调用其定义的某个方法或者其父类的某个方法。
  - 选择器selector: 因为方法在消息中负责在对象的方法列表中选择一个方法执行，因此方法名在消息中通常成为选择器。
  
  2. 方法的定义
  方法声明包含了以下几个部分：方法类型标识符，返回类型，方法名称，参数类型和参数名称。
  ```
  - (void)insertString:(NSString *)astring atIndex:(NSInteger)loc;
  ```
  - 方法类型标识符(-) 表示一个实例方法
  - 返回类型(void) 即没有返回值
  - 方法名称(insertString:atIndex:) 一个方法的实际名称是所有签名关键词的串联，包括冒号字符。
  - 参数类型 该方法中包括了两个参数，两个参数的类型为NSString和NSUInteger.
  - 参数名称 该方法中包含了两个参数，两个参数的名称分别为astring和loc
  
  3. 方法的类型
  在iOS开发中，方法一共有两种类型，分别为实例方法和类方法。
  - 实例方法:消息的接收者必须为一个已经实例化的对象，实例方法在定义时以-开头。
  ```
  -(void)appendString:(NSString *)aString;
  ```
  - 类方法:有时也称为工厂方法，类方法通常用于创建类的新实例。消息的接收者为一个类对象，类方法在定义时以+开头，类方法是一般情况下是有返回值的，返回类型通常为instancetype.
  ```
  +(instancetype)stringWithFormat:(NSString *)format....;
  ```
  #### 3.3.2 方法的调用
  在Objective-C中，调用一个方法相当于传递一个消息，这里的消息指的是方法名和参数。
  所有消息的分派都是动态的，所谓动态指的是所有消息处理直到执行时(runtime)才会动态决定，而不是在编译时就绑定，这也体现了Objective-C对象的多态行为。
  
  1. 方法调用的方式
  - 普通调用 使用方括号将消息本身与参数放到括号内，同时将接受消息的对象放在最前面。
  ```
  NSString *str = [NSString stringWithFormat:@"九九学院"]; //类方法调用
  NSString *str2 = [NSString stringWithFormat:@"www.99ios.com"]; //类方法调用
  str = [str stringByAppendingString:str2]; //实例方法调用
  NSLog(@"%@",str);
  ```
  - 嵌套调用 有时为了避免声明大量的局部变量来存储临时结果，Objective-C也支持嵌套消息表达式。
  ```
  NSString *str = [NSString stringWithFormat:@"九九学院"]; //类方法调用
  str = [str stringByAppendingString:[NSStringstringWithFormat:@"www.99ios.com"]]; //方法的嵌套调用
  NSLog(@"%@",str);
  ```
  - 调用父类的方法 子类可以直接调用父类的方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "myPerson.h"
  int main(int argc, char * argv[]) {
  @autoreleasepool {
  myPerson *myPerson1 = [[myPerson alloc] init];
  [myPerson copy];
  }
  return 0;
  }
  ```
  
  2. 点语法
  Objective-C中还提供专门用于调用存取方法(setter/getter)的点语法。开发者可以调用getter/setter方法来获取或设置对象的属性的值，同样的，可以使用点语法来更加简便地获取或设置对象属性的值。
  
  - 创建一个MyPerson类，并添加一个name属性
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  @interface myPerson : NSObject
  @property (nonatomic,copy) NSString *name;
  @end
  NS_ASSUME_NONNULL_END
  ```
  - 使用点语法对name属性进行赋值以及取值操作。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "myPerson.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          myPerson *myPerson1 = [[myPerson alloc] init];
          myPerson1.name = @"MYClass";
          NSLog(@"class name is %@",myPerson1.name);
      }
      return 0;
  }
  ```
  3. 消息处理机制
  在Objective-C中，消息是直到运行时才和方法进行绑定关联的。消息机制的关键在于编译器为类和对象生成的结构。其中类的结构中包含两个基本元素：**，指向父类的指针；第二，类的方法列表**,而对象被创建时，对象的第一个实例变量是一个指向该对象的类结构的指针，即isa指针。通过该指针，就可以访问到该类及其父类的方法列表。
  
  当向某个对象发送消息时:
  - 首先根据isa指针，找到该对象对应的类结构的方法列表，继而可找到具体的方法实现。当在本类的方法列表中找不到对应的方法时，会根据类结构中父类的指针去查找父类的方法列表，直至NSObject根类。
  - 将对象以及参数传递给找到的方法实现。
  - 执行方法中的代码，获取方法的返回值。 
  
  #### 3.3.3 方法的重写
  在Objective-C中，子类不仅可以继承父类的属性，同时还可以直接继承父类中的方法，而不需要重新编写相同的方法，但有时候在子类中并不想原封不动地继承父类中的方法，而是希望在子类中实现一些特定的功能，这时可以对父类进行方法重写或方法覆盖。
  
  1. 方法重写的规则
  一般来说，如果希望在子类中调用父类的某个方法，实现一些特定的功能时，可以考虑对父类的方法进行重写。当子类需要重写父类的方法时，必须保证重写的两个方法放回置，方法名，参数列表完全一致。
  
  2. 实例代码实现
  新增一个ClassA类，在ClassA.h文件中，添加webSite属性以及printWebSite方法#import 
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface ClassA : NSObject
  @property (nonatomic,copy) NSString *webSite;
  -(void) printWebSite;
  
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  在ClassA.m文件中，实现printWebSite方法的功能，即打印webSite属性的值。
  ```
  #import "ClassA.h"
  @implementation ClassA
  -(void) printWebSite {
      NSLog(@"classA 中打印webSite的只：%@",self.webSite);
  }
  @end
  ```
  新建一个ClassB,继承自ClassA,在ClassB.h文件中，同样添加一个printWebSite方法。
  ```
  #import <Foundation/Foundation.h>
  #import "ClassA.h"
  NS_ASSUME_NONNULL_BEGIN
  @interface ClassB : ClassA
  -(void)printWebSite;
  @end
  NS_ASSUME_NONNULL_END
  ```
  ClassB.m文件中，重写printWebSite方法，改变打印的内容。
  ```
  #import "ClassB.h"
  @implementation ClassB
  -(void)printWebSite{
      NSLog(@"ClassB中打印webSite的值:%@",[NSString stringWithFormat:@"http://%@",self.webSite]);
  }
  @end
  ```
  在main()中分别调用父类和子类的printwebSite方法。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "ClassA.h"
  #import "ClassB.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          ClassA *classA = [[ClassA alloc] init];
          classA.webSite = @"www.99ios.com";
          [classA printWebSite];
          ClassB *classB = [[ClassB alloc]init];
          classB.webSite = @"www.99ios.com";
          [classB printWebSite];
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  3. 子类方法调用父类方法
  在发开过程中，需要子类先调用父类的方法，然后再进行一些定制操作，因此在调用父类方法时需要用到super关键字
  ```
  #import "ClassB.h"
  @implementation ClassB
  -(void)printWebSite{
  [super printWebSite];
  NSLog(@"ClassB中打印webSite的值:%@",[NSString stringWithFormat:@"http://%@",self.webSite]);
  }
  @end
  ```
  ### 3.4 对象
  #### 3.4.1 创建对象
  对象是类Class运行时的实例，它包含了自己的实例变量的内存副本以及类方法的指针，在实际开发种可以采用分配内存地址alloc以及初始化init两个步骤来创建一个对象。
  
  对象的创建分为两个阶段：内存空间分配和初始化。通常情况下，初始化总是紧跟在内存空间分配之后进行的，但是在创建对象的过程种，这两个操作的作用是不同的。
  
  1. 分配内存空间alloc
  除了为对象在程序的内存区划定一块合适大小的内存空间之外,alloc方法还有以下几个重要作用：
  - 将对象的引用计数设置为1。其中，引用计数与对象的内存管理有关，在ARC模式下，当引用计数为0时，对象会被释放。
  - 初始化对象的isa指针并指向对象的类。在实际开发过程种，会遇到对象类的类对象两个概念，其中，对象类是一个根据类定义编译得到的运行对象。另外，每一个对象都有一个isa指针表示其是哪个类的实例。
  - 将类种定义的属性的值初始化为0或者nil.
  
  如果只执行了alloc操作，在内存种分配了内存空间，但未进行任何初始化操作。
  其对象的地址是存在的，但其属性的值为空。
  
  2. 初始化init
  初始化的过程将对象的实例变量设置为合理且有用的初始值，还可以分配和准备对象需要的其他全局资源，并在必要时加载诸如文件这样的资源。
  
  在对象调用init方法时，主要完成了以下工作。
  - 调用父类的初始化方法[super init]
  - 如果父类返回的对象不为空，则可以对对象进一步设置；
  - 如果父类返回的对象为nil,则直接返回nil。
  
  3. 类方法
  类方法是方法前面为+号的方法，类方法把创建对象过程中的两个步骤(alloc+init)合并，直接返回被创建的对象。在实际开发过程中，类方法的使用非常普遍。
  ![635dcb02.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\635dcb02.png)
  下方的示例代码中分别使用类方法和实例方法创建了NSString 类型的对象。
  ```
  //使用类方法创建字符串对象
  NSString *str = [NSString stringWithFormat:@"www.99ios.com"];
  //使用alloc+init方法创建字符串对象
  NSString *str2 = [[NSString alloc] initWithString:@"九九学院"];
  ```
  #### 3.4.2 对象操作
  针对对象的常见操作主要包括:判断对象的类型，判断对象是否响应消息，对象间的比较以及对象复制
  
  1. 判断对象的类型
  对象通过调用isKindOfClass:方法，可以判断对象的类型。isKindOfClass:方法是NSObject类的方法，将类型为Class的对象aClass作为参数传入，返回一个BOOL类型的返回值。
  ```
  -(BOOL)isKindOfClass:(Class)aclass;
  ```
  ```
  NSString *str = [NSString stringWithFormat:@"www.99ios.com"];
  if([str isKindOfClass:[NSString class]]){
  NSLog(@"str 是NSString类型的对象!");}
  ```
  
  2. 判断对象是否响应消息
  在Objective-C 中，调用对象的方法需要向对象发送消息，这是Objective-C语言的重要特征。要判断一个对象是否响应一条消息，则可以调用respondsToSelector：方法。应用程序通常在验证一个对象响应一则消息后，才将消息发送给该对象。
  
  定义MYClass.h文件中，添加一个name属性
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  
  @interface MYClass : NSObject
  @property (nonatomic,copy)NSString *name;
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  在自定义类MYClass.m文件中，对属性进行懒加载
  ```
  #import "MYClass.h"
  @implementation MYClass
  -(NSString *)name{
      if(_name ==nil){
          _name=@"99ios";
      }
      return _name;
  }
  @end
  ```
  在main()中，判断自定义类是否实现了属性的getter方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *obj = [[MYClass alloc]init];
          if([obj respondsToSelector:@selector(name)]){
              NSLog(@"obj可以响应名称为name的消息");
          }
      }
      return 0;
  }
  ```
  3. 对象间的比较
  当需要对比两个对象是否相同时，可以使用isEqual:方法。如果相同，则该方法返回YES。该方法是在NSObject类中定义的，因此所有的对象都可以调用这个方法。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *str1 = [NSString stringWithFormat:@"www.99ios.com"];
          NSString *str2 = @"九九学院";
          if([str1 isEqual:str2]){
              NSLog(@"str1与str2相同");
          }else{
              NSLog(@"str1与str2不相同");
          }
          if([str1 isEqualToString:@"www.99ios.com"]){
              NSLog(@"str1与字符串 wwww.99ios.com相同");
          }
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  4. 对象复制
  通过调用copy方法，可以创建对象的副本。调用copy方法，有个前提条件，即接受的对象的类必须遵守NSCopying协议。另外，在使用对象复制时，还需要考虑针对该对象是浅复制还是深复制。有关沈复制与浅复制后续会详细介绍。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *str = [NSString stringWithFormat:@"www.99ios.com"];
          //对象复制
          NSString *copyString = [str copy];
          NSLog(@"copyString的值:%@",copyString);
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  ### 3.5 变量
  #### 3.5.1 局部变量
  局部变量也称为内部变量，局部变量在方法内部声明，作用域仅仅限于方法内。有关局部变量在实际使用中，有以下几个常用的要点。
  - 局部变量在方法内部定义，只有在方法运行时才存在。
  - 局部变量没有默认的初始值，因此在使用前需要赋值。
  - 在一个方法中，方法中的输入参数也属于局部变量的范畴。
  
  示例代码
  定义一个MYClass类，在该类MYClass.h文件中添加一个printlocalVariable方法。
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  @interface MYClass : NSObject
  -(void) printLocalVariable;
  @end
  NS_ASSUME_NONNULL_END
  ```
  在类MYClass.m文件中，实现printLocalVariable方法。在printLocalVariable方法内部，定义个局部变量localVar,并赋初始值0.当方法被调用时，打印当前localVar的值，之后localVar值执行加1操作。
  ```
  #import "MYClass.h"
  @implementation MYClass
  -(void) printLocalVariable{
      int localVar = 0;
      NSLog(@"localVar value :%d",localVar);
      localVar++;
  }
  @end
  ```
  在main函数中反复调用printlocalVariable方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
      }
      return 0;
  }
  ```
  #### 3.5.2 全局变量
  全局变量也称为外部变量，它不属于任何一个方法，而是属于一个源程序文件或者特定的类。根据其作用区域来区分，全局变量包括内部全局变量以及外部全局变量，其中，**内部全局变量的作用域是整个类，而外部全局变量的作用域是整个程序。**
  
  1. 内部全局变量
  如果在程序开始处定义变量，那么久可以在类中任何位置都使用这个变量的值，且变量的值是累计变化的，这个时候，这个变量的作用域在于整个类的实现文件，称之为内部全局变量。
  
  在MYClass.m文件中定义一个内部全局变量gNum,并且赋初始值0，那么就可以在该类的所有方法中使用该变量，不需要重新声明，并且对于该变量值的修改是累加的。
  ```
  import "MYClass.h"
  @implementation MYClass
  int gNum = 0;
  -(void) printLocalVariable{
      NSLog(@"localVar value :%d",gNum);
      gNum++;
  }
  @end
  ```
  在main()函数中，调用printGlobalVariable方法，来检验内部全局变量gNum的值是累加的。
  ```
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
      }
      return 0;
  }
  ```
  2. 外部全局变量
  外部全局变量，也是可以在程序的其他任何方法以及函数中访问的。**这需要在访问外部全局变量的地方，声明变量类型以及名称，并添加extern关键字，即可访问该全局变量。**
  
  首先在classA.m classB.m文件中实现printExternVar方法，并对全局变量gNum进行声明。
  ```
  #import "ClassA.h"
  @implementation ClassA
  -(void)printLocalVariable{
      extern int gNum;
      NSLog(@"globalVar value (Class A):%d",gNum);
      gNum++;
  }
  @end
  ```
  
  ```
  #import "ClassB.h"
  @implementation ClassB
  -(void)printLocalVariable{
      extern int gNum;
      NSLog(@"globalVar value (Class B):%d",gNum);
  }
  @end
  ```
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "ClassA.h"
  #import "ClassB.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          [myclass printLocalVariable];
          
          ClassA *classA = [[ClassA alloc]init];
          [classA printLocalVariable];
          
          ClassB *classB = [[ClassB alloc]init];
          [classB printLocalVariable];
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  **注意 需要区分变量的声明和定义，变量的声明不会引起内存空间的分配，而定义会分配内存空间。处理外部变量时，变量可以在很多地方声明为extern,但只能定义一次。**
  
  #### 3.5.3 静态变量
  在Objective-C中，在变量声明前加上关键字static,该变量就成为静态变量。静态变量可以使局部变量保留多次调用同一个方法所取得的值。
  1. 在方法之内定义静态变量
  静态变量只在程序开始执行初始化一次。在不指定静态变量的值时，默认情况下，静态变量的初始值为0，并且多次调用方法时，保存这些数值。静态变量也可以在方法内部定义，此时，只能在该方法中使用定义的静态变量。
  
  在MYClass.m文件printStaticVariable方法中定义静态变量staticValue.该静态变量只能在printStaticVariable方法中使用。
  ```
  #import "MYClass.h"
  @implementation MYClass
  -(void)printStaticVariable{
      static int staticValue;
      NSLog(@"staticVar value: %d",staticValue);
      staticValue++;
  }
  @end
  ```
  当在main中多次调用printStaticVariable方法时，staticValue的值会累加。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass printStaticVariable];
          [myclass printStaticVariable];
          [myclass printStaticVariable];
      }
      return 0;
  }
  ```
  2. 在方法之外定义静态变量
  静态变量除了可以在方法内部定义之外，还可以在方法之外定义，此时，该类的所有方法都可以访问该静态变量。
  
  在MYClass.m文件 @implementation之外定义一个静态变量staticValue2,并赋初始值100.
  ```
  #import "MYClass.h"
  static int staticValue2 = 100;
  @implementation MYClass
  -(void) testStaticVarValue1{
      NSLog(@"在方法1中打印静态变量的当前值:%d",staticValue2);
      staticValue2++;
  }
  -(void) testStaticVarValue2{
      NSLog(@"在方法2中打印静态变量的当前值:%d",staticValue2);
      staticValue2++;
  }
  @end
  ```
  在main函数中
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
      }
      return 0;
  }
  ```
  3. 静态变量的重要特性
  - 某个对象调用不同的方法，修改同一个静态变量时，则该静态变量的值使累加的。
  - 当同一个类的不同对象，修改同一个静态变量时，则该静态变量的值也是累加的。
  
  在main函数中，再创建一个MYClass对象,可以验证，此时静态变量staticValue2的值也是叠加的。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          MYClass *myclass = [[MYClass alloc] init];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
          [myclass testStaticVarValue1];
          [myclass testStaticVarValue2];
          
          MYClass *myclass2 = [[MYClass alloc]init];
          [myclass2 testStaticVarValue1];
          [myclass2 testStaticVarValue2];
          [myclass2 testStaticVarValue1];
          [myclass2 testStaticVarValue2];
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  #### 3.5.4 const关键字
  
  1. const介绍
  如果不像让某些变量的值改变，可以使用const关键字来修饰这些变量。如果添加const关键字，这些变量的值从头到尾都不会改变了。在iOS开发中，经常把字符串常量添加const关键字，从而替代宏(#define),因为const的执行性能比宏定义要高。给变量添加const关键字，主要目的是防止定义的对象被修改，在定义有const关键字的对象时，需要设置初始值。
  
  const在不同位置情况下的变量
  ```
  int main() {
      @autoreleasepool {
          int a = 10;
          const int *p = &a;
          int const *p2 = &a;
          int * const p3 = &a;
          
          int b = 20;
          *p = 12;
          p = &b;
          
          *p2 = 12;
          p2 = &b;
          
          *p3 = 12;
          p3 = &b;
  
          printf("%d",*p);
          printf("%d",*p2);
          printf("%d",*p3);
      }
  }
  ```
  结果如下：
  ![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80MDQ0ODk2LTRmZmFhNWYxNWEzZDVkNzgucG5n.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\25b94e62.png)
  
  情况1: 
  ```
  const int *p = &a
  此时const修饰的是*p,*p的意义是指针所指向的内存地址的值，所以此时的意思是指针p所指向的内存地址的值是不可变的，但是指向的内存地址可变。
  ```
  情况2：
  ```
  int const *p = &a
  此时const修饰的仍然是*p,同情况1一样。
  ```
  情况3：
  ```
  int *const p = &a
  此时const修饰的是变量p,也就是局部变量p的值不能被改变，所以当尝试使用*p改变p所指向的内存地址a中的值时是可行的，但是当尝试重新给p赋值，让其指向b的内存地址时会报错。
  ```
  2. const使用方法
  在实际的iOS开发中，const最常用于定义字符串常量，并且为了维护方便，会把工程中所有的字符串常量都统一放在一个const类中。
  
  在MYConst.h文件中，声明所有的常量，而且需要在每个常量前面都加上extern关键字。
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  extern int const height;
  extern NSString *const launchSuccessNotification;
  
  @interface MYConst : NSObject
  @end
  NS_ASSUME_NONNULL_END
  ```
  在MYConst.m文件中，为常量赋值。
  ```
  #import "MYConst.h"
  int const height = 44;
  NSString *const launchSuccessNotification = @"launchSuccessNotification";
  @implementation MYConst
  @end
  ```
  当需要使用const修饰的常量时，引入MYConst类。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSLog(@"my const height:%d",height);
          NSLog(@"my const notification string:%@",launchSuccessNotification);
      }
      return 0;
  }
  ```
  ## 第四章 Foundation框架
  ### 4.1 Foundation框架介绍
  - Application Kit 框架：包含了用于开发交交互式图形应用程序，使得开发文本，菜单，工具栏，表，文档，剪切板和窗口之类的过程变得十分简便，用于Mac OS桌面程序的开发。
  - Cocoa:总体来说，通常指的试Foundation框架，Application Kit框架以及CoreData框架，Cocoa一般针对的是MacOSd的应用开发。
  - Cocoa Touch:指的是Foundation框架，UIKit框架以及CoreData框架，CocoaTouch一般用于iOS移动设备开发。
  
  ### 4.2 字符串类
  在Foundation框架中，处理字符串的类就是NSString和NSMutableString。这两个类完成了Objective-C中与字符串相关的核心功能处理。而NSString和NSMutableString两个类最主要的区别是NSString类的字符串对象，在创建赋值后不能动态修改长度和内容，除非重新赋值。而NSMutableString类似于链表，在创建赋值后可以进行修改长度，插入，删除等操作。
  
  #### 4.2.1 不可变字符串NSString
  1. 创建字符串对象
  ```
  NSString *webSite =@"www.99ios.com"
  NSString *string1 = [NSString stringWithFormat:@"www.99ios.com"];
  NSString *string2 =[NSString stringWithUTF8String:"九九学院"];
  NSString *string3 =[[NSString alloc]initWithFormat:@"www.99ios.com"];
  NSString *string4 = [[NSString alloc]initWithUTF8String:"九九学院"]
  ```
  2. 字符串比较
  使用isEqualToString判断字符串是否相同
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string1 = @"www.99ios.com";
          NSString *string2 = @"www.99ios.com";
          if([string1 isEqualToString: string2]){
              NSLog(@"string1 与string2 相等");
          }
      }
      return 0;
  }
  ```
  判断字符串中是否包含某个字符串，使用containsString
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string = @"www.99ios.com";
          if([string containsString:@"99.ios"]){
              NSLog(@"string 中包含字符串99 ios!");
          }
      }
      return 0;
  }
  ```
  使用hasPrefix与hasSuffix判断字符串的开头与结尾
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string = @"www.99ios.com";
          if([string hasSuffix:@"com"]){
              NSLog(@"string 以com结尾");
          }
          if([string hasPrefix:@"www"]){
              NSLog(@"string 以www开头");
          }
      }
      return 0;
  }
  ```
  
  3. 字符串的拼接与截取
  截取
  - 使用substringFromIndex,获得从指定索引位置开始的字符串，传入的参数表示开发截取的位置，最终截取得到的字符串中不包括参数表示位置的字符。
  - 使用substringToIndex,获得从字符串开始到指定索引之间的字符串，最终截取得到的字符串中不包括参数表示位置的字符。
  - 使用substringWithRange，从字符串中间截取一段字符串，需要传入一个NSRange类型的参数，用于指明截取的范围。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSString *string = @"www.99ios.com";
          NSString *subString1 = [string substringFromIndex:4];
          NSString *subString2 = [string substringToIndex:3];
          NSRange range = NSMakeRange(4, 5);
          
          NSString *subString3 = [string substringWithRange:range];
          NSLog(@"subString1:%@",subString1);
          NSLog(@"subString2:%@",subString2);
          NSLog(@"subString3:%@",subString3);
      }
      return 0;
  }
  ```
  拼接
  - stringWithFormat
  ```
  NSString * string1 = @"123";
  NSString * string2 = @"456";
  NSString * string3 = [NSString stringWithFormat:@"%@%@", string1, string2];
  NSLog(@"%@", string3);
  ```
  - stringByAppendingString
  ```
  NSString * string4 = [string1 stringByAppendingString:string2];
  NSLog(@"%@", string4);
  ```
  - stringByAppendingFormat
  ```
  NSString * string5 = [string1 stringByAppendingFormat:@"%@", string2];
  NSLog(@"%@", string5);
  ```
  4. 字符串的其他操作
  使用length属性，获取字符串的长度。
  使用integerValue方法实现数字字符串与数字的转换。
  
  #### 4.2.2 可变字符串NSMutableString
  NSMutableString是继承自NSString类的，所以NSString中定义的所有方法NSMutableString都可以使用，与NSString相比，NSMutableString类的对象在内存中存储的空间是可以变化的，因此存储的字符串长度和内容都可以改变。
  
  1. NSMutableString的初始化
  NSMutableString类的对象，可以采用以下几个方法来进行初始化。
  - stringWithCapacity，需要指定初始化时预留的可供存储的字符串最大长度。
  - initWithCapacity,需要指定初始化时预留的可供存储的字符串最大长度。
  - stringWithString,传入一个初始化字符串
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString1 = [NSMutableString stringWithCapacity:100];
          NSMutableString *mString2 = [[NSMutableString alloc] initWithCapacity:100];
          NSMutableString *mString3 = [NSMutableString stringWithString:@"www.99ios.com"];
      }
      return 0;
  }
  ```
  
  2. NSMutableString 字符串的修改
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString = [NSMutableString stringWithCapacity:100];
          //赋值
          [mString setString:@"www.99ios.com"];
          //拼接
          [mString appendString:@"九九学院"];
          //在指定位置插入字符串
          [mString insertString:@"欢迎访问" atIndex:0];
          NSLog(@"%@",mString);
      }
      return 0;
  }
  
  ```
  
  3. NSMutableString 字符串的替换与删除
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString = [NSMutableString stringWithString:@"www.99ios.com"];
          NSRange range = NSMakeRange(4, 5);//位置和长度
          [mString replaceCharactersInRange:range withString:@"apple"];
          [mString deleteCharactersInRange:range];
      }
      return 0;
  }
  
  ```
  4. 连接两个字符串对象
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *mString1 = [NSMutableString stringWithString:@"www.99ios.com"];
          NSMutableString *mString2 = [NSMutableString stringWithString:@"九九学院"];
          NSString *mNewString = [mString1 stringByAppendingString:mString2];
          NSLog(@"合并后的字符串:%@",mNewString);
      }
      return 0;
  }
  ```
  ### 4.3 数组类
  数组是有序的对象集合，一般情况下，一个数据中的元素都是同一类型的对象。
  Objective-C的数据比C++，Java的数组强大之处在于，NSArray保存的对象可以是不同类型的对象。但是缺点是只能保存对象，int、char、double等基本数据类型不能直接保存，需要通过转换成Objective-C对象后才能加入数组。
  
  NSArray类的数组是不可变数组，这种不可变包括：数组中不能新增元素，并且数组内已存在的对象也不支持修改。如果希望对数组进行修改，那么在声明时需要把数组声明为NSMutableArray可变数组，NSMutableArray类是NSArray类的子类。
  
  #### 4.3.1 不可变数组 NSArray
  1. 创建数组
  - 使用@[]的方式是创建数组经常使用的方式之一，只需要把数组中需要保存的对象放在括号中间
  ```
  NSArray *array1 = @[@123,@456,@789];
  NSArray *array2 = @[@123,@456,@"789"];//数组中可以保存不同的数据对象类型
  NSArray *array3 = @[@"tom",@"jerry",@"jobs"];
  ```
  - 使用arrayWithObjects 这种方式创建数组，需要在数组的结尾处添加一个空对象nil来标识数组的结尾。
  ```
  NSArray *array = [NSArray arrayWithObjects:@"123",@"456",@"789",nil];
  ```
  - 使用initWithObjects 这种方式创建数组，需要提前执行alloc操作。
  ```
  NSArray *array = [[NSArray alloc]initWithObjects：@"tom",@"jerry",@"jobs",nil];
  ```
  
  2. 数组的复制
  当直接把一个数组对象赋值给另外一个数组对象时，此时进行的是指针复制，即在内存中，数组中的对象只保留了一个版本。
  使用arrayWithArray方式复制数组，对原数组进行完整的复制，从而得到一个全新的数组。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "MYClass.h"
  #import "MYConst.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          NSArray *copyArray1 = array;
          NSArray *copyArray2 = [NSArray arrayWithArray:array];
          NSLog(@"原始数组地址:%p,指针复制数组地址:%p,深复制数组地址:%p",array,copyArray1,copyArray2);
      }
      return 0;
  }
  ```
  3. 数组元素操作
  - objectAtIndex方法访问数组中的元素，或者使用数组名称[序号]来访问。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          NSNumber *num = array[0];
          NSLog(@"num:%@",num);
          id obj = [array objectAtIndex:0];
          NSLog(@"obj:%@",obj);
      }
      return 0;
  }
  ```
  - indexOfObject方法获取某个对象在数组中的下标。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          NSUInteger index = [array indexOfObject:@456];
          NSLog(@"对象对应数组中的下表为:%lu",index);
      }
      return 0;
  }
  
  ```
  - containsObject 查找某个对象是否存在数组中。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSArray *array = @[@123,@456,@789];
          if([array containsObject:@123]){
              NSLog(@"数组中包含这个对象");
          }
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  4. 其他常用操作
  - count返回数组中元素个数
  - firstObject获取数组中的第一个对象
  - lastObject获取数组中的最后一个对象
  
  #### 4.3.2 可变数组 NSMutableArray
  NSMutableArray类可以对数组内的元素数量进行增加，删除。同时也可以对存储元素的内容进行修改。由于NSMutableArray类是NSArray类的子类，因此NSArray类的方法和属性，NSMutableArray类都可以继续使用。
  
  1. 可变数组创建
  - 使用array 可以不指定可变数组的容量。
  - 使用arrayWithCapacity 需要提供数组的初始容量。
  - 使用initWithCapacity 需要提供数组的初始容量。
  ```
  NSMutableArray *mArray1 = [NSMutableArray array];
  NSMutableArray *mArray2 = [NSMutableArray arrayWithCapacity:100];
  NSMutableArray *mArray3 = [[NSMutableArray alloc] initWithCapacity:100];
  ```
  
  2. 可变数组的元素操作
  - 在数组末尾增加
  ```
  [mArray3 addObject:(nonnull id)];
  ```
  - 在指定位置增加元素 
  ```
  [mArray3 insertObject:(nonnull id) atIndex:(NSUInteger)];
  ```
  - 替换某个下标的元素
  ```
  [mArray3 replaceObjectAtIndex:(NSUInteger) withObject:(nonnull id)];
  ```
  - 删除元素
  ```
  [mArray3 removeObject:(nonnull id)];
  ```
  - 删除指定下标的元素
  ```
  [mArray3 removeObjectAtIndex:(NSUInteger)];
  ```
  - 删除所有元素
  ```
  [mArray3 removeAllObjects];
  ```
  - 修改某个元素对象的值，可以使用赋值运算符直接更新数组中某个下标对象的值。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableArray *mArray = [NSMutableArray arrayWithObjects:@"九九学院",@"99ios",nil];
          NSLog(@"初始化状态下，数组中第一个对象的值:%@",mArray[0]);
          mArray[0] = @"www.99ios.com";
          NSLog(@"更新后，数组中第一个对象的值:%@",mArray[0]);
      }
      return 0;
  }
  ```
  ### 4.4 字典类
  字典是由键-值组成的数据集合，其中值为对象。可以通过键从字典中获取需要的值。
  字典中的键必须唯一。通常情况下，键为字符串对象，主要用于注明存储对象的说明，但键也可以是其他类型的对象。和键关联的值可以是任何对象类型。
  
  #### 4.4.1 不可变字典NSDictionary
  1. 创建不可变字典
  NSDictionary字典创建完成后，不能再新增/删除键值对。
  ```
          NSDictionary *dict = @{
              @"website":@"www.99ios.com",
              @"name":@"九九学院",
              @"business":@"iOS学习",
              @"foundedYear":@2016
          };
          
  ```
  这4个键值对的key都使用字符串对象，用来说明键值的含义，而value中可以保存各种类型的对象，可以是NSString字符串对象，也可以是NSNumber数字对象。
  
  2. 访问字典的键值
  使用NSDictionary[key]或objectForKey方法
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDictionary *dict = @{
              @"website":@"www.99ios.com",
              @"name":@"九九学院",
              @"business":@"iOS学习",
              @"foundedYear":@2016
          };
          NSString *website = dict[@"website"];
          NSLog(@"字典中website对应的value: %@",website);
          NSString *name = [dict objectForKey:@"name"];
          NSLog(@"字典中name 对应的value:%@",name);
      }
      return 0;
  }
  ```
  3. 遍历字典中的键值对
  在Objective-C 中提供了for-in循环，for-in循环除了能够用于遍历数组中的对象之外，也可以用于遍历字典中的键值对。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDictionary *dict = @{
              @"website":@"www.99ios.com",
              @"name":@"九九学院",
              @"business":@"iOS学习",
              @"foundedYear":@2016
          };
          for(NSDictionary *key in dict){
              NSLog(@"key:%@ value:%@",key,dict[key]);
          }
      }
      return 0;
  }
  
  ```
  4. 其他操作
  - 获取字典中键值对的数量
  ```
  @property (readonly) NSUInteger count;
  ```
  - 获取一个字典中所有的键，返回一个数组
  ```
  @property (readonly,copy)NSArray<KeyType> *allKeys
  ```
  - 获取一个字典中所有的值，返回一个数组
  ```
  @property (readonly,copy)NSArray<ObjectType> *allValues
  ```
  
  #### 4.4.2 可变字点NSMutableDictionary
  可变字典类NSMutableDictionary类是不可变字典类NSDictionary的子类。
  NSMutableDictionary类继承了NSDictionary类的属性和方法之外，与不可变字典相比，其存储的键值可以新增、删除以及修改。
  
  1. 实例化可变字典对象
  使用dictionary方法初始化一个空的可变字典对象是最简便地得到一个可变字典对象的方法，获得的可变字典对象不指定初始容量。
  ```
  NSMutableDictionary *mDict = [NSMutableDictionary dictionary];
  ``` 
  2. 增加键值对
  通过调用setObject:forKkey:方法可增加字典内存储的键值。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableDictionary *mDict = [NSMutableDictionary dictionary];
          [mDict setObject:@"www.99ios.com" forKey:@"website"];
          [mDict setObject:@"九九学院" forKey:@"name"];
          NSLog(@"wesite:%@",mDict[@"website"]);
          NSLog(@"name:%@",mDict[@"name"]);
      }
      return 0;
  }
  ```
  3. 修改键值对的值
  当需要修改键值对时，需要根据键去除字典中的键值对，然后使用赋值运算符更新值。
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableDictionary *mDict = [NSMutableDictionary dictionary];
          [mDict setObject:@"www.99ios.com" forKey:@"website"];
          [mDict setObject:@"九九学院" forKey:@"name"];
          NSLog(@"wesite:%@",mDict[@"website"]);
          NSLog(@"name:%@",mDict[@"name"]);
          
          mDict[@"wesite"] =@"www.apple.com";
          mDict[@"name"] = @"苹果公司";
          NSLog(@"wesite新值:%@",mDict[@"website"]);
          NSLog(@"name新值:%@",mDict[@"name"]);
      }
      return 0;
  }
  
  ```
  4. 移除键值对
  - removeObjectForKey 方法可以移除某个键值对。
  - removeObjectsForKeys 方法可以以出多个键值对，把需要移除的所有键存储在一个数组对象中。
  - removeAllObjects方法 可以移除可变字典中的所有键值对。
  
  ### 4.5 NSNumber类
  在编程的过程中，一些基本数据类型的变量是必不可少的，但是在Objective-C编程语言当中，Objective-C的消息机制并不能向这些基本数据类型发送消息，而且Objective-C的集合当中是不能存放基本数据类型的，所以就需要将基本数据类型转换成对象来使用。
  Objective-C中提供了NSNumber类来将基本数据类型包装成**数字对象**，这样就可以将基本数据类型当作对象来处理。
  
  1. NSNumber 对象创建
  - 使用@符号进行快速封装。
  - 使用NSNumber类提供的方法。
  ```
  NSNumber *intNum = @10;
  NSNumber *floatNum = @3.14;
          
  NSNumber *intNum2 = [NSNumber numberWithInt:10];
  NSNumber *floatNum2 = [NSNumber numberWithFloat:3.14];
  NSNumber *integerNum = [NSNumber numberWithInteger:100];
  NSNumber *doubleNum = [NSNumber numberWithInteger:100.01];
  NSLog(@"%@--%@--%@--%@--%@--%@",intNum,intNum2,floatNum,floatNum2,integerNum,doubleNum);
  ```
  
  2. NSNumber 对象与基本数据类型之间的转换
  基本数据类型可以转换为NSNumber类的对象，NSNumber类的对象也可以转换成基本数据类型，在NSNumber类中也提供了对象的属性和方法。
  ```
  NSNumber *intNum = [NSNumber numberWithInt:10];
  NSNumber *floatNum = [NSNumber numberWithFloat:3.14];
  NSNumber *integerNum = [NSNumber numberWithInteger:100];
  NSNumber *doubleNum = [NSNumber numberWithDouble:100.01];
          
  int intBasic = [intNum intValue];
  float floatBasic = [floatNum floatValue];
  double doubleBasic = [doubleNum doubleValue];
  NSInteger integerBasic = [integerNum integerValue];
  NSLog(@"%d--%f--%f--%ld",intBasic,floatBasic,doubleBasic,(long)integerBasic);
  ```
  ### 4.6 NSDate类
  NSData对象用来表示一个具体的时间点，它存储的是世界标准时间，所以在使用的时候可能会需要根据不同的时区将时间转换为本地时间。
  
  1. 获取日期与时间
  NSDate类中提供了data方法，用来获取当前标准时区的时间(国际标准时间)，
  然后需要获取系统当地时区，再获取当前时区与格林尼治时间的间隔。最后转换为本地时间。
  ```
  NSDate *date = [NSDate date];
  NSLog(@"国际标准时间:%@",date);
  NSTimeZone *zone = [NSTimeZone systemTimeZone];
          
  NSInteger interval = [zone secondsFromGMTForDate:date];
          
  NSDate *localDate = [NSDate dateWithTimeIntervalSinceNow:interval];
  NSLog(@"当前时区时间:%@",localDate);
  ```
  
  
  2. 日期格式转换
  默认情况下，通过NSDate获取的日期时间格式为:yyyy-MM-ddHH:mm:ss。如果需要更换日期格式，需要用到NSDateFormatter类对日期格式进行转换，这里有两种方式转换。
  
  - NSDate转NSString时，需要使用NSDateFormatter类的stringFromDate。
  - NSString 转NSDate时，需要使用NSDateFormatter类的dateFromString。
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDate *date = [NSDate date];
          NSLog(@"国际标准时间:%@",date);
          NSTimeZone *zone = [NSTimeZone systemTimeZone];
          
          NSInteger interval = [zone secondsFromGMTForDate:date];
          
          NSDate *localDate = [NSDate dateWithTimeIntervalSinceNow:interval];
          NSLog(@"当前时区时间:%@",localDate);
          
          NSDateFormatter *df = [[NSDateFormatter alloc] init];
          df.dateFormat = @"yyyy年MM月dd日 HH:mm:ss";
          NSString *date2string = [df stringFromDate:date];
          NSLog(@"日期转字符串:%@",date2string);
          NSDate *string2date = [df dateFromString:date2string];
          NSLog(@"字符串转日期:%@",string2date);
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  
  ```
  3. 其他常用操作
  - 比较两个时间对象的先后，可以使用earlierDate以及laterDate方法。
  - 比较两个时间的间隔，可以使用timeIntervalSinceDate方法。
  - 比较两个日期是否相等，可以使用isEqualToDate方法
  
  
  ### 4.7 NSFileManager类
  #### 4.7.1 文件操作
  #### 4.7.2 目录操作
  #### 4.7.3 枚举目录的内容
  #### 4.7.4 文件的读写与写入
  ### 4.8 NSURL类
  NSURL类提供在应用中使用URL地址的相关方法。
  1. 创建NSURL对象。
  在NSURL类中提供了URLWithString方法，可以把一个字符串转换称为一个NSURL对象。
  除此之外，还可以使用initWithString方法。
  ```
  +(nullable instancetype) URLWithString:(NSString *)URLString
  -(nullable instancetype) initWithString:(NSString *)URLString
  ```
  
  2. 获取输出
  - 通过调用NSString类的stringWith-ContentsOfURL:encoding:error可以获取NSURL对象指针地址中存储的数据，并转换成字符串形式。
  
  - 获取NSData类的输出内容，通过NSData类的dataWithContentsOfURL:url可以返回NSData类的对象。
  
  ### 4.9 NSBundle类
  当创建一个应用时，系统存储了应用相关联的所有资源，例如图片、文件等。将这些内容放在应用包中，为了定位应用包中的资源，则需要使用NSBundle类。
  
  NSBundle类提供了在程序包中查找资源的相关方法。
  - 使用mainBundle方法来实例化得到一个NSBundle类对象。
  - 使用pathForResource方法来获取某个资源的路径，返回一个NSString类型对象。
  
  ```
  NSString *filePath = [[NSBundle mainBundle] pathForResource:@"myfile" ofType:@"txt"];   
  NSLog(@"%@",filePath);
      
  NSString *fileString = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
  NSLog(@"%@",fileString);
  ```
  
  ## 第五章 Objective-C语言特性
  ### 5.1 代码块
  Block是对C语言的一个扩展，在Objective-C中完全支持。Block在现在的iOS开发中使用越来越普遍，Block就是封装了一组代码语句的对象，可以在任何时间执行。
  #### 5.1.1 Block简介
  Block块是封装工作单元的对象，是可以在任何时间执行的代码段。其本质上是可移植的匿名函数，可以作为方法和函数的参数传入，可以从方法和函数中返回。
  
  1. Block的定义与调用
  块是以插入字符^开头，后面的一个括号内表示块所需要的参数，最后面的大括号中的块主体，最后以分号结束。
  ```
  ^(int inputNum){
  NSLog(@"printBlock Called");
  return inputNum;
  };
  ```
  代码块也可以进行赋值
  ```
  int (^printBlock)(int) =  ^(int inputNum){
  NSLog(@"printBlock Called");
  return inputNum;
  };
  ```
  当需要调用已定义的Block时。
  ```
  int i = printBlock(100);
  ```
  2. 把Block声明为类的属性
  由于Block就是一个存储了一段代码的对象，因此也可以把Block设置为某个类的属性。
  Block属性与其他类型的属性，如NSString、NSArray没有什么本质区别，都可以使用点句
  法来对属性进行取值和赋值。
  申命两个Block属性
  ```
  #import <UIKit/UIKit.h>
  @interface ViewController : UIViewController
  @property(copy) void (^blockProperty)(void);
  @property(copy,nonatomic)void (^blockPropertyWithInput)(int);
  @end
  ```
  在实现文件中，通过点语法为两个Block属性赋值，然后再调用Block中的代码。
  ```
  #import "ViewController.h"
  @interface ViewController ()
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.blockProperty = ^{
          NSLog(@"blockProperty被调用!");
      };
      self.blockProperty();
      
      self.blockPropertyWithInput = ^(int i) {
          NSLog(@"blockPropertyWithInput被调用!,输入的参数是%d",i);
      };
      self.blockPropertyWithInput(150);
  }
  @end
  ```
  #### 5.1.2 Block的参数与返回值
  1. 无输入参数+无返回值
  ```
  void (^blockWithoutInputAndOutput)(void) = ^(void){
              NSLog(@"欢迎访问 www.99ios.com");
  };
  blockWithoutInputAndOutput();
  ```
  2. 有输入参数+无返回值
  ```
  void (^blockWithInput)(int)=^(int inputNum){
              NSLog(@"blockWithInput 被调用！输入参数的值为%d.",inputNum);
  };
  blockWithInput(99);
  ```
  3. 有输入参数及返回值
  ```
  int (^blockWithOutputAndInput)(int) = ^(int inputNum){
            NSLog(@"blockWithOutputAndInput 被调用!");
            return inputNum * inputNum;
  };
  int a = blockWithOutputAndInput(100);
  NSLog(@"blockWithOutputAndInput 的返回值是:%d",a);
  ```
  4. 有多个输入参数
  ```
  double(^multiplyTwoValues)(double,double) = ^(double number1,double number2){
              return number1 *number2;
  };
  double doubleNumber = multiplyTwoValues(5.0,5.6);
  NSLog(@"multiplyTwoValues:%f",doubleNumber);
  ```
  5. 无输入参数+有返回值
  ```
  int (^blockWithOutput) (void) = ^(void){
              NSLog(@"blockWithOutput 被调用");
              return 100;
  };
  int a = blockWithOutput();
  NSLog(@"blockWithoutput的返回值:%d",a);
  ```
  #### 5.1.3 操作Block外部的变量
  1. 访问Block之外的变量
  如果在一个方法中声明了Block,那么Block中也可以访问在该方法中定义的变量，前提是该变量的定义在Block定义之前。
  ```
  int i = 100;
  void (^beginBlock)(void) = ^(void){
  NSLog(@"i 在Block中获取的值:%d",i);
  };
  beginBlock();
  i =200;
  beginBlock();
  NSLog(@"i的当前值:%d",i);
  ```
  2. 修改Block之外的变量 
  在Block中，假如需要更新在Block之外定义的变量，那么在定义变量时，必须加上_ _ block关键字。
  ```
  __block int i = 100;
  void (^beginBlock)(void) = ^(void){
  NSLog(@"i 在Block中获取的值:%d",i);
  };
  beginBlock();  
  i =200;
  beginBlock();
  NSLog(@"i的当前值:%d",i);
  ```
  #### 5.1.4 Block回调
  在iOS的开发过程中，Block的回调使用非常普遍，也是Block的重要用法之一，在使用过程中经常可以用于替换代理的实现方法。
  
  当需要定义回调Block时，通常情况下可以按照如下步骤进行：
  - 定义带Block参数的方法。
  ```
  #import <Foundation/Foundation.h>
  NS_ASSUME_NONNULL_BEGIN
  @interface Task : NSObject
  -(void) beginTaskWithCallbackBlock:(void (^)(void)) callBackBlock;
  @end
  NS_ASSUME_NONNULL_END
  ```
  - 设置Block的回调时机。
  ```
  #import "Task.h"
  @implementation Task
  -(void)beginTaskWithCallbackBlock:(void (^)(void))callBackBlock{
      NSLog(@"任务开始,3秒后调用block中的代码！现在时间是:%@",[NSDate date]);
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
          callBackBlock();
      });
  }
  @end
  ```
  - 定义Block中需要执行的操作。
  ```
  #import "ViewController.h"
  #import "Task.h"
  @interface ViewController ()
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      Task *task = [[Task alloc] init];
      [task beginTaskWithCallbackBlock:^{
          NSLog(@"block中的代码被执行！现在时间是:%@",[NSDate date]);
      }];
  }
  @end
  ```
  ### 5.2 分类
  
  
  ### 5.3 协议
  #### 5.3.1 协议简介
  协议是多个类共享的一个方法列表，在协议中列出的方法，在定义协议的类中并没有给出具体的实现，而协议的实现的功能是在遵守协议的类中定义的。通过协议可以实现对象之间的通信，同时又能够使类的定义更加通用。
  
  1. 协议的实现步骤
  - 添加协议，并设置协议中包含的方法，同时添加一个属性用于设置遵守协议的对象。
  - 设置触发执行协议中方法的时机。
  - 在遵守协议的类中，实现协议中方法的具体功能。
  
  #### 5.3.2 代理
  1. 代理协议(Delegate)
  在iOS开发中，经常使用到代理协议以及数据源协议。所谓代理协议，通俗来讲，就是委托别人办事。
  
  2. 代理协议的实现
  - 在自定义视图类MYView.h文件中，设置类引用@class、定义代理协议名称、定义代理协议中包含的方法、添加代理属性(注意使用weak属性)。
  ```
  #import <UIKit/UIKit.h>
  
  @class MYView; //设置类应用class
  
  @protocol MyViewDelegate <NSObject> //定义代理协议名称
  -(void) myView:(MYView *) myView clickMYButtonShowAlert:(NSString *)message; //定义代理协议中包含的方法
  
  @end
  
  @interface MYView : UIView
  @property (nonatomic,weak) id <MyViewDelegate> delegate; //添加代理方法
  @end
  ```
  - 在MYView.m文件中，监听代理协议定义事件的发生。当事件发生时，通知遵守代理协议的对象去工作，即设置在实现代理协议的类中，代理协议方法执行的时机。使用respondsToSelector方法判断一下对象中是否已经实现了该协议的方法
  ```
  #import "MYView.h"
  @implementation MYView
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      if([self.delegate respondsToSelector:@selector(myView:clickMYButtonShowAlert:)]){
          [self.delegate myView:self clickMYButtonShowAlert:@"视图被点击了"];
      }
  }
  @end
  ```
  - 在需要遵守代理协议的类中，引用头文件并遵守代理协议，遵守代理协议需要在类的接口部分使用<>符号来声明该类需要遵守的协议，同一个类可以遵守多个协议。
  ```
  #import "MYView.h"
  
  @interface ViewController () <MyViewDelegate>
  @property (nonatomic,strong) MYView *myView;
  @end
  ```
  - 设置代理对象
  ```
  -(MYView *)myView{
      if(_myView ==nil){
          _myView = [[MYView alloc]init];
          _myView.frame = CGRectMake(0, 500, 320, 50);
          _myView.backgroundColor = [UIColor yellowColor];
          _myView.delegate = self;
      }
      return _myView;
  }
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.view];
  }
  ```
  - 实现协议方法。即当触发条件发生时，执行的动作。
  ```
  -(void)myView:(MYView *)myView clickMYButtonShowAlert:(NSString *)message{
      //__func__ 用于打印当前函数名
      NSLog(@"%s",__func__);
      NSLog(@"传递的消失是:%@",message);
  }
  ```
  ### 5.4 KVC
  #### 5.4.1 使用KVC赋值取值
  KVC(Key-value coding)即键值编码，对应了NSKeyValueCoding类。NSKeyValueCoding类是对NSObject类进行的扩展，因此所有的类都可以使用NSKeyValueCoding类中定义的方法。其最基本的使用就是可以对对象属性继续宁赋值和取值，可以起到和点语法同样的效果。
  
  - 在Person.h文件中添加如下代码
  ```
  #import <Foundation/Foundation.h>
  #import "Dog.h"
  NS_ASSUME_NONNULL_BEGIN
  
  @interface Person : NSObject
  
  @property (nonatomic,copy) NSString *personName;
  @property (nonatomic,strong) Dog *dog;
  
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  - 在Dog.h文件中添加如下代码
  ```
  #import <Foundation/Foundation.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface Dog : NSObject
  
  @property (nonatomic,copy) NSString *dogName;
  @property (nonatomic,copy) NSString *dogAge;
  
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  下面的示例代码综合使用了KVC中有关赋值/取值的方法.
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "Person.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          Person *person = [[Person alloc]init];
          Dog *dog = [[Dog alloc]init];
          //使用kvc赋值
          [dog setValue:@"tom" forKey:@"dogName"];
          [person setValue:@"shixin" forKey:@"personName"];
          [person setValue:dog forKey:@"dog"];
          [person setValue:@2 forKeyPath:@"dog.dogAge"];
          
          //使用KVC取值
          NSString *personName = [person valueForKey:@"personName"];
          NSString *dogName = [person valueForKeyPath:@"dog.dogName"];
          NSString *dogAge = [person valueForKeyPath:@"dog.dogAge"];
          
          NSLog(@"<%@>的宠物狗名<%@>,它<%@>岁了",personName,dogName,dogAge);
          
          //return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
      }
      return 0;
  }
  ```
  #### 5.4.2 字典转模型
  KVC除了最简单的对对象属性进行赋值和取值外，在NSKeyValueCoding类中，还提供了SetValuesForKeysWithDictionary方法。**该方法专门用于把一个字典转换成一个模型对象，但使用过程中要求字典中的键值和类中定义的属性名称必须完全一致。**假如有不一致的情况，就需要在类的实现文件中，对名称不一致的键值需要使用setValue:forUnderfinedKey方法进行特殊处理。
  
  在Person.h文件中添加idNumber、name和age3个属性。
  ```
  @interface Person : NSObject
  
  @property (nonatomic,copy)NSString *idNumber;
  @property (nonatomic,copy)NSString *name;
  @property (nonatomic,assign) int age;
  
  @end
  ```
  在Person.m文件中使用setValue:forUndefinedKey方法对idNumber属性的赋值方法进行特殊处理，即字典中的id键值对的value需要赋值给idNumber属性。
  ```
  -(void)setValue:(id)value forUndefinedKey:(nonnull NSString *)key{
      if([key isEqualToString:@"id"]){
          self.idNumber = (NSString *)value;
      }
  }
  ```
  在main函数中，使用setValuesForKeysWithDictionary:方法来把一个字典转换成一个Person类的模型对象。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "Person.h"
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSDictionary *dict = @{
              @"id" :@1234567,
              @"name" :@"99iOS",
              @"age":@2
          };
          Person *person = [[Person alloc]init];
          [person setValuesForKeysWithDictionary:dict];
          NSLog(@"idNumber:%@",person.idNumber);
          NSLog(@"NAME:%@",person.name);
          NSLog(@"age:%d",person.age);
      }
      return 0;
  }
  ```
  #### 5.4.3 修改readonly的属性以及私有属性
  
  ### 5.5 KVO
  KVO(Key Value Observing)可以实现模型和视图的联动机制，即数据模型发生了修改之后，立即将改变呈现到视图View上去的一种双向绑定的机制。
  
  - 模型对象注册指定KeyPath的监听方法。通常情况下，当模型对象的指定Key发生变化时，通知视图对象。
  ```
  - (void)addObserver:(NSObject *)observer 
           forKeyPath:(NSString *)keyPath 
              options:(NSKeyValueObservingOptions)options 
              context:(void *)context;
  ```
  - 视图对象的监听回调方法，在该方法中可以获取数据模型变化前后的数据
  ```
  - (void)observeValueForKeyPath:(NSString *)keyPath 
                        ofObject:(id)object 
                          change:(NSDictionary<NSKeyValueChangeKey, id> *)change 
                         context:(void *)context;
  ```
  - 删除指定Key路径的监听器
  ```
  - (void)removeObserver:(NSObject *)observer 
              forKeyPath:(NSString *)keyPath 
                 context:(void *)context;
  ```
  使用KVO实现模型与视图联动的步骤
  - 创建数据模型对象，并且注册需要监听的KeyPath.
  - 在视图类中，实现监听回调方法，即当收到模型对象指定KeyPath发生变化时，对界面UI执行的更新操作。
  
  实现过程
  - 定义Person模型类，并添加一个name属性
  ```
  #import <Foundation/Foundation.h>
  @interface Person : NSObject
  @property(nonatomic,copy)NSString *name;
  @end
  ```
  - 定义MYLabel视图类，继承自UILabel，在MYLabel.h中添加一个Person类型的属性，该属性为MYLabel提供展示的数据.
  ```
  #import <UIKit/UIKit.h>
  #import "Person.h"
  @interface MYLabel : UILabel
  @property (nonatomic,strong) Person *viewData;
  @end
  ```
  - 在MYlabel.m文件中，重写viewData属性的setter方法，当设置viewData属性时，更新MYLabel上的文字显示。
  ```
  #import "MYLabel.h"
  @implementation MYLabel
  -(void)setViewData:(Person *)viewData{
      _viewData = viewData;
      self.text = viewData.name;
  }
  ```
  - 在MYLabel.m文件中，实现视图对象的监听回调方法，该方法在模型数据发生变化时会调用，此时会把数据模型中最新的数据从change参数中获取，等获取到最新的数据后，跟新MYLabel的文字显示。
  ```
  -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context{
      NSString *newText = change[@"new"];
      self.text = newText;
  }
  ```
  - 在ViewController.m文件中，添加Person类型的属性以及MYLabel类型的属性，并对myLabel属性进行懒加载操作。
  ```
  #import "MYLabel.h"
  #import "Person.h"
  
  @interface ViewController ()
  @property (nonatomic,strong) Person *myPerson;
  @property (nonatomic,strong) MYLabel *myLabel;
  
  @end
  
  -(MYLabel*)myLabel{
      if(_myLabel == nil){
          _myLabel = [[MYLabel alloc] initWithFrame:CGRectMake(150,150,100,100)];
          _myLabel.backgroundColor = [UIColor redColor];
          _myLabel.textColor = [UIColor whiteColor];
      }
      return _myLabel;
  }
  ```
  - 在ViewDidLoad方法中，创建Person类对象，并注册需要监听的KeyPath。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      
      [self.view addSubview:self.myLabel];
      Person *person = [[Person alloc]init];
      self.myPerson = person;
      [person addObserver:self.myLabel forKeyPath:@"name" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];
  
  }
  ```
  - 单击屏幕时，更新Person类对象的值，此时会调用MYLabel类中的observeValueForKeyPath:ofObject:change:context:方法，从而更新MYLabel对象的显示
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      self.myPerson.name = [NSString stringWithFormat:@"%d",arc4random_uniform(1000000)];
  }
  ```
  ## 第六章 Objective-C进阶
  ### 6.1 对象复制
  #### 6.1.1 浅复制与深复制的简介
  在Objective-C中，基本数据类型的复制都会在内存中对需要赋值的变量创建一个副本。而对象的复制有两种形式:浅复制与深复制
  
  - 浅复制:将原始对象的指针值复制到副本中，即指针复制，原始对象和副本共享引用的数据，相当于创建了一份新的文件。
  - 深复制:复制原始对象指针所引用的数据，并将赋给副本对象，即内容复制，相当于创建了一份新的文件。
  - 当属性添加copy关键字时，那么对这个属性赋值时，就会执行深复制操作，同时还需要该类遵守NSCopying协议。当把属性关键字改为strong或者weak时，那么对这个属性赋值时，就会执行浅复制。
  
  
  新增一个ClassA类，添加一个NSString类型的name1属性，并添加copy关键字，添加一个NSString类型的name2属性，并添加strong关键字。
  ```
  @property (nonatomic,copy) NSString *name1;
  @property (nonatomic,strong) NSString *name2;
  ```
  
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "ClassA.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSMutableString *string = [[NSMutableString alloc]initWithFormat:@"www.99ios.com"];
          ClassA *classA = [[ClassA alloc]init];
          
          classA.name1 = string;
          classA.name2 = string;
          
          [string appendString:@"+"];
          
          NSLog(@"原字符串值:%@,内存地址:%p",string,string);
          NSLog(@"name1复制字符串值:%@,内存地址:%p",classA.name1,classA.name1);
          NSLog(@"name2复制字符串值:%@,内存地址:%p",classA.name2,classA.name2);
      }
      return 0;
  }
  ```
  #### 6.1.2 可变对象复制与不可变对象复制
  
  #### 6.1.3 自定义对象复制
  对于自定义对象的复制，首先要保证在类的定义中遵守NSCopying协议，然后实现copyWithZone：方法，对于自定义对象的复制特性，都取决于copyWithZone:方法中的实现情况，对于类中定义的属性也需要综合考虑其定义中有关内存管理的特性。
  
  1. 类的定义与复制
  为了实现对该类对象的复制，要求ClassB类遵守NSCopying协议，同时在类的.m文件中实现copyWithZone:方法，在该方法中的实现逻辑决定了当调用copy方法时，对该类对象进行复制所采取的方法。
  
  ```
  #import <Foundation/Foundation.h>
  #import "ClassA.h"
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface ClassB : NSObject <NSCopying>
  
  @property (nonatomic,copy)NSString *name;
  @property (nonatomic,strong) ClassA *customClass;
  @property (nonatomic,weak) id delegate;
  @property (nonatomic,assign) int number;
  @end
  NS_ASSUME_NONNULL_END
  ```
  2. 浅复制该类的对象
  当仅仅需要对该对象进行浅复制时，可以在copyWithZone:方法中，直接返回要复制的对象即可。
  ```
  #import "ClassB.h"
  @implementation ClassB 
  - (nonnull id)copyWithZone:(nullable NSZone *)zone {
      return self;
  }
  @end
  ```
  3. 深复制该类的对象
  当需要对自定义对象深复制时，需要在copyWithZone:方法中调用alloc以及init方法，重新开辟一块新的内存空间。另外，对于属性的复制过程中，也需要考虑到属性自身的特性。
  ```
  - (nonnull id)copyWithZone:(nullable NSZone *)zone {
      ClassB *copyObject = [[[self class]allocWithZone:zone] init];
      copyObject.name = [self.name mutableCopy];
      copyObject.customClass = self.customClass;
      copyObject.delegate = self.delegate;
      copyObject.number = self.number;
      return copyObject;
      //return self;
  }
  ```
  
  
  4. 深复制与浅复制代码验证
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #import "ClassA.h"
  #import "ClassB.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          ClassA *classA = [[ClassA alloc]init];
          ClassB *myClass1 = [[ClassB alloc]init];
          myClass1.name = @"ABC";
          myClass1.customClass = classA;
          myClass1.delegate = classA;
          myClass1.number =100;
          ClassB *myClass2 = [myClass1 copy];
          NSLog(@"对象类:[%@]原对象内存地址:[%p],复制对象内存地址:[%p]",[ClassB class],myClass1,myClass2);
          NSLog(@"[原对象]:copy属性-[%p],strong属性-[%p],weak属性-[%p],assign属性-[%d]",myClass1.name,myClass1.customClass,myClass1.delegate,myClass1.number);
          NSLog(@"[复制对象]:copy属性-[%p],strong属性-[%p],weak属性-[%p],assign属性-[%d]",myClass2.name,myClass2.customClass,myClass2.delegate,myClass2.number);
      }
      return 0;
  }
  ```
  ### 6.2 内存管理
  1. 引用计数
  引用计数是在Object-C中用于管理对象生命周期的机制，这种机制可以很有效地管理对象的生命周期。当一个对象被创建时，它的引用计数为1。每当有新的指针指向这个对象时，这个对象的引用计数就加1.当某个指针不再指向这个对象时，该对象的应用计数减1。当该对象的应用计数为0时，该对象就自动销毁，占用的内存被回收。
  2. MRC(手工引用计数)
  MRC在Xcode4.2版本之前，对象的引用计数都需要程序员来手工管理，因此，程序员需要花费大量的精力来管理对象的创建于销毁，其中一个最基本的原则就是：谁创建谁销毁。
  
  3. ARC(自动引用计数)
  随着Xcode4.2的版本发布，苹果引用了其中一个新特性就是自动引用计数。与MRC不同，自动引用计数模式中，对象的引用计数管理完全交由系统来管理，也就是说，在MRC中的retain/release操作都由系统自动完成了。
  
  ### 6.3 预编译指令
  预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符串外的第一个字符。#号后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。预处理过程先于编译器对源代码进行处理，还会删除程序中的注释和多余的空白字符。
  
  #### 6.3.1 宏定义
  宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以像函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。#define 预处理指令是用来定义宏的，宏的作用范围是从宏定义的那一行开始，直到文件尾。
  1. 无参宏
  - 定义符号常量
  ```
  #define PI 3.14 
  ```
  - 定义表达式
  ```
  #define LARGE (100+100)
  ```
  - 定义字符串常量
  ```
  #define WEBNAME "www.99ios.com"
  ```
  - 定义符号
  ```
  #define AND &&
  ```
  - 宏定义中
  ```
  #define TWO_PI(2.0*PI)
  ```
  2. 有参宏
  - 当使用有参宏时，需要传入必要的参数参与运算。
  ```
  #define 宏名(参数列表)宏体
  ```
  - 定义一个又一个参数的宏,求参数的平方值
  ```
  #define SQUARE(a) ((a)*(a))
  ```
  - 使用续行符定义多行的宏。\\被称为续行符，表示下一行是本行的延续。在\\符号所在行之后不能加任何空白字符。
  ```
  #define LARGER(a,b) ({\\
  int m=a,n=b;m>n ? m:n;\\
  })
  ```
  3. 运算符#
  出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  #define STRING(n) #n
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSLog(@"%s",STRING(www.99ios.com));
      }
      return 0;
  }
  ```
  4. 运算符##
  ##运算符用于把多个参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  #define STRING(a,b,c) (a##b##c)
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          NSLog(@"%f",STRING(13.6,2,3));
      }
      return 0;
  }
  ```
  #### 6.3.2 #include、#import与@class
  ```
  #include <类名.h>
  ```
  这种格式告诉预处理程序在编译器自带的或外部库的头文件中搜索被包含的头文件。
  ```
  #include "类名.h"
  ```
  这种格式告诉预处理程序在当前被编译的应用程序的源代码文件中搜索被包含的头文件，如果找不到，再搜索编译器自带的头文件。
  
  #import与#include 是一样的，@class指令与#import的功能类似。**但是使用@class不能引入类中的属性和方法。**
  
  #### 6.3.3 条件编译
  条件编译指令决定哪些代码将被编译，而哪些是不被编译的。例如NSLog函数，可以定义只有在版本调试debug状态时才打印日志，在版本发布release状态时不打印日志。
  - #if 指令检测跟在关键字后的宏或者常量表达式的值，如果值为真，则编译后面的代码。直到出现#else,#elif或#endif为止，反之则不执行。
  - #elif预处理指令综合了#else和#if指令的作用。类似于else if.
  - #else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。
  
  
  ### 6.4 NSLog函数
  
  ### 6.5 结构
  #### 6.5.1 结构的定义与基本使用
  1. 结构类型的定义
  ```
  struct Date {
  int day;
  int month;
  int year;};
  ```
  2. 结构变量的声明
  ```
  struct Date today;
  ```
  3. 结构变量的赋值/初始化
  ```
  today.day = 2;
  today.month = 9;
  today.year = 2016;
  ```
  4. 结构体成员变量的访问
  ```
  #import <UIKit/UIKit.h>
  #import "AppDelegate.h"
  
  int main(int argc, char * argv[]) {
      @autoreleasepool {
          struct Date {
              int day;
              int month;
              int year;
          };
          struct Date today;
          today.day = 2;
          today.month = 9;
          today.year = 2016;
          NSLog(@"今天是:%d年%d月%d日",today.year,today.month,today.day);
      }
      return 0;
  }
  ```
  # 第二部分 iOS开发基础
  ## 第七章 基础UI控件
  ### 7.1 UIKit框架
  ### 7.2 视图UIView
  #### 7.2.1 UIView简介
  #### 7.2.2 视图UIView的外观
  #### 7.2.3 视图UIView的形变
  #### 7.2.4 视图UIView的层次关系
  #### 7.2.5 视图UIView的动画
  #### 7.2.6 响应用户交互事件
  UIView类的对象都具有响应用户交互的能力，因为UIView继承自UIResponder.在初始化视图对象的过程中，可以给UIView对象添加手势，以响应用户交互。另外，对于自定义视图类，可以通过实现其有关触摸的相关方法，来定义用户交互的动作。
  
  1. 与用户交互事件相关属性
  UIView类中，userInteractionEnabled属性可以用来自定义视图类对象是否能够响应用户交互。
  **在UILabel、UIImageView子类中该属性默认情况下是关闭的，**另外multipleTouchEnabled属性用于设置视图对象能否支持多点触控，默认情况下，其取值是NO。
  ```
  //是否支持用户交互
  @property(nonatomic, getter=isUserInteractionEnabled) BOOL userInteractionEnabled;
  //是否支持多点触控
  @property(nonatomic, getter=isMultipleTouchEnabled) BOOL multipleTouchEnabled;
  ```
  2. 添加手势
  对于视图类对象，都可以通过添加手势的方法来响应用户的交互。一个视图类对象，可以添加多个手势。
  - 获取视图对象上的所有手势
  ```
  @property(nonatomic, readonly, copy) NSArray<UIGestureRecognizer *> *gestureRecognizers;
  ```
  - 添加手势
  ```
  - (void)addGestureRecognizer:(UIGestureRecognizer *)gestureRecognizer;
  ```
  - 移除手势
  ```
  - (void)removeGestureRecognizer:(NSGestureRecognizer *)gestureRecognizer;
  ```
  在ViewController.m文件中添加以下示例代码。
  ```
  #import "ViewController.h"
  
  @interface ViewController ()
  @property (nonatomic,strong)UIView *myView;
  @end
  
  @implementation ViewController
  
  
  -(UIView *)myView{
      if(_myView == nil){
          _myView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
          _myView.backgroundColor = [UIColor redColor];
      }
      return _myView;
  }
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.myView];
      //添加长按手势
      UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction)];
      [self.myView addGestureRecognizer:longPress];
      UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)];
      [self.myView addGestureRecognizer:tap];
      NSLog(@"myView gesture :%@",self.myView.gestureRecognizers);
  }
  
  -(void)longPressAction{
      NSLog(@"%s",__func__);
     
      UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示" message:@"长按" delegate:nil cancelButtonTitle:nil otherButtonTitles:@"OK", nil];
      
      [alertView show];
  }
  
  -(void)tapAction{
      NSLog(@"%s",__func__);
      
      UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示" message:@"点击了" delegate:nil cancelButtonTitle:nil otherButtonTitles:@"OK", nil];
      [alertView show];
  }
  @end
  ```
  #### 7.2.7 内容模式contentMode
  视图的contentMode属性决定了边界变化和缩放操作作用到视图上产生的效果。视图在屏幕上显示后，渲染后的内存会被缓存在视图的图层上，当视图的大小发生变化时，UIKit并不强制对视图进行重画，而是根据其contentMode属性决定如何显示缓存内容。由于这种机制的存在，当修改视图的大小时，可以提升性能。
  
  1. contentMode简介
  contentMode经常用于图像视图UIImageView。当希望在app中调整控件的尺寸时，务必优先考虑使用contentMode,这样做可以在视图的外观发生形变时，避免编写定制的描画代码。
  ```
  @property(nonatomic)UIViewContentMode contentMode;
  ```
  在开发过程中，当发生以下两种情况时，会使用到contentMode:
  - 改变frame或bounds中的高度或宽度
  - 修改transform属性。
  
  2. 常见的contentMode
  ```
  UIViewContentModeScaleToFill
  如有必要，可以通过更改内容的纵横比来缩放内容以适应其自身的大小。
  UIViewContentModeScaleAspectFit
  通过保持纵横比来缩放内容以适应视图大小的选项。视图边界的任何剩余区域都是透明的。
  UIViewContentModeScaleAspectFill
  缩放内容以填充视图大小的选项。内容的某些部分可能会被剪裁以填充视图的边界。
  UIViewContentModeRedraw
  通过调用 setNeedsDisplay 方法在边界更改时重新显示视图的选项。
  UIViewContentModeCenter
  使内容在视图边界居中的选项，保持比例不变。
  UIViewContentModeTop
  将在视图边界顶部对齐的内容居中的选项。
  UIViewContentModeBottom
  将在视图边界底部对齐的内容居中的选项。
  UIViewContentModeLeft
  在视图左侧对齐内容的选项。
  UIViewContentModeRight
  在视图右侧对齐内容的选项。
  UIViewContentModeTopLeft
  对齐视图左上角内容的选项。
  UIViewContentModeTopRight
  对齐视图右上角的内容的选项。
  UIViewContentModeBottomLeft
  对齐视图左下角的内容的选项。
  UIViewContentModeBottomRight
  在视图的右下角对齐内容的选项。
  ```
  3. contentMode的设置方法
  - 使用storyboard设置。选中一个视图控件，可以在右侧的选项中设置contentMode.
  ![dc6cf195.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\dc6cf195.png)
  - 使用代码来设置contentMode.UIView类中提供了contentMode属性,其是一个UIViewContentMode类型的属性，默认取值为UIViewContentModeScaleToFill。
  
  #### 7.2.8 图片拉伸
  #### 7.2.9 使用代码创建自定义UIView
  #### 7.2.10 使用XIB创建自定义UIView
  - 新增一个NibView类，继承自UIView
  ![4b9d0fb2.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\4b9d0fb2.png)
  - 新增一个XIB文件，命名为NibView.xib
  ![50df840d.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\50df840d.png) 
  - 使用XIB绘制UIView的界面，添加子视图并设置约束关系。
  ![1f8cfe80.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\1f8cfe80.png)
  - 由于使用XIB在初始化时不会调用initWithFrame方法，而是调用initWithCoder方法。因此在.h文件中定义一个类方法initFromNib，并在.m文件中对该方法进行实现。该方法的主要功能从XIB文件中加载，该方法会调用initWithCoder 方法。
  ```
  #import <UIKit/UIKit.h>
  
  NS_ASSUME_NONNULL_BEGIN
  
  @interface NibView : UIView
  
  @property (weak,nonatomic) IBOutlet UIView *subView;
  +(NibView*)initFromNib;
  @end
  
  NS_ASSUME_NONNULL_END
  ```
  
  
  ```
  #import "NibView.h"
  
  @implementation NibView
  
  //加载XIB布局
  +(NibView *)initFromNib{
      NSLog(@"%s",__func__);
      return [[[NSBundle mainBundle] loadNibNamed:@"NibView" owner:self options:nil]lastObject];
  }
  
  //只要对象是从文件解析来的，就会调用
  -(instancetype) initWithCoder:(NSCoder *)coder{
      NSLog(@"%s",__func__);
      self = [super initWithCoder:coder];
      if(self){
          
      }
      return self;
  }
  //从xib或者storyboard加载完毕就会调用
  -(void)awakeFromNib{
      [super awakeFromNib];
      NSLog(@"%s",__func__);
      self.alpha =0.5;
  }
  
  //当需要对子视图进行重新布局的时候
  -(void)layoutSubviews{
      NSLog(@"%s",__func__);
  }
  //当需要自定义绘图的时候
  -(void)drawRect:(CGRect)rect{
      NSLog(@"%s",__func__);
  }
  
  @end
  ```
  然后在ViewController加载布局
  ```
  #import "ViewController.h"
  #import "NibView.h"
  @interface ViewController ()
  @property (nonatomic,strong)UIView *myView;
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      NibView *nibView = [NibView initFromNib];
      [self.view addSubview:nibView];
  }
  @end
  ```
  
  注意：
  initWithCoder：使用文件加载的对象调用（如从xib或stroyboard中创建）
  initWithFrame：使用代码加载的对象调用（使用纯代码创建）
  
  #### 7.2.11 控件改变坐标系
  ### 7.3 图片控件UIImageView
  #### 7.3.1 基本使用
  #### 7.3.2 常用操作
  #### 7.3.3 帧动画功能
  ### 7.4 按钮控件UIButton
  #### 7.4.1 基本使用
  #### 7.4.2 按钮的创建
  #### 7.4.3 调整图标与标题的位置
  ### 7.5 文本控件UILabel
  #### 7.6 提示框控件UIAlertController
  苹果自iOS8开始，就已经废弃了之前用于界面提醒的UIAlertView类以及UIActionSheet,取而代之的是UIAlertController以及UIAlertAction。
  
  1. UIAlertController的使用
  - UIAlertController实例化方法，通过该方法可以创建一个UIAlertController类的对象。
  ```
  + (instancetype)alertControllerWithTitle:(NSString *)title message:(NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;
  ```
  - 在提醒对象中添加按钮，每个按钮都是一个UIAlertAction类的对象。
  ```
  -(void)addAction:(UIAlertAction *)action;
  ```
  - 在界面上显示提醒信息
  ```
  - (void)presentViewController:(NSViewController *)viewController animator:(id<NSViewControllerPresentationAnimator>)animator;
  ```
  - 显示样式
  ```
  //在呈现它的视图控制器的上下文中显示的操作表。
  UIAlertControllerStyleActionSheet
  //为应用程序模态显示的警报。
  UIAlertControllerStyleAlert
  ```
  2. UIAlertAction的使用
  UIAlertAction是定义提醒每个按钮的样式以及用户点击后执行的操作，每个UIAlertAction对象都需要添加到一个UIAlertController对象上才能生效。当需要创建UIAlertAction对象时，可以使用如下类方法
  ```
  + (instancetype)actionWithTitle:(NSString *)title style:(WKAlertActionStyle)style handler:(WKAlertActionHandler)handler;
  ```
  3. 示例代码
  ```
  -(void)viewDidAppear:(BOOL)animated{
      UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"提示" message:@"是否要访问99IOS" preferredStyle:UIAlertControllerStyleAlert];
      
      UIAlertAction *defaultAction = [UIAlertAction actionWithTitle:@"YES" style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){
          NSLog(@"点击了 YES");
      }];
      
      UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@"NO" style:UIAlertActionStyleCancel handler:^(UIAlertAction *action){
          NSLog(@"点击了 NO");
      }];
      
      [alert addAction:defaultAction];
      [alert addAction:cancelAction];
      
      [self presentViewController:alert animated:YES completion:nil]; 
  }
  ```
  
  ### 7.7 文本输入框UITextField
  #### 7.7.1 UITextField的基本属性
  1. UITextField的文本相关属性
  - text 获取文本框中的文字
  - placeholder 占位符
  - textColor 字体颜色
  - font 字体大小
  - textAlignment 文本对齐方式
  2. UITextField 的外观属性
  - backgroundColor 背景颜色
  - boderStyle 边框样式,UITextBorderStyleNone(无边框),UITextBorderStyleLine(线形边框),UITextBorderStyleBezel(带阴影效果的边框),UITextBorderStyleRoundedRect(圆角边框)
  3. 其它属性
  - keyboardType 键盘类型
  - returnKeyType 键盘弹出后的键盘返回键类型
  - autocapitailzationType 设置输入框输入的字符是否大写
  - clearsOnBeginEditing 当开始编辑时，是否删除TextField里面的所有字符串。
  
  #### 7.7.2 UITextField的代理
  - 当开始输入时调用，即当键盘弹出时候
  ```
  - (void)textFieldDidBeginEditing:(UITextField *)textField;
  ```
  - 编辑结束时调用。即当键盘收起时候
  ```
  - (void)textFieldDidEndEditing:(UITextField *)textField;
  ```
  - 是否允许编辑，当返回值是NO时，此时UITextField对象不能输入任何内容
  ```
  - (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;
  ```
  - 是否允许编辑结束，并且放弃第一响应者状态
  ```
  - (BOOL)textFieldShouldEndEditing:(UITextField *)textField;
  ```
  - 是否响应清除按钮
  ```
  - (BOOL)textFieldShouldClear:(UITextField *)textField;
  ```
  - 是否响应键盘上的返回按钮
  ```
  - (BOOL)textFieldShouldReturn:(UITextField *)textField;
  ```
  #### 7.7.3 UITextField的键盘回收代理方法
  当需要进行键盘回收时，可以使用两种方法。
  - 调用UIResponder类的resignFirstResponder方法
  ```
  -(BOOL)resignFirstResponder
  ```
  - 调用UITextField类的endEditing方法
  ```
  -(BOOL)endEditing:(BOOL)force
  ```
  示例代码
  ```
  #import "ViewController.h"
  @interface ViewController ()<UITextFieldDelegate>
  @property(nonatomic,strong)UITextField *textField;
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.view.backgroundColor = [UIColor redColor];
      [self.view addSubview:self.textField];
      
  }
  -(UITextField*)textField{
      if(_textField == nil){
          _textField = [[UITextField alloc] initWithFrame:CGRectMake(50, 50, 250, 50)];
          _textField.backgroundColor = [UIColor whiteColor];
          _textField.placeholder = @"欢迎访问99IOS";
          _textField.textAlignment = NSTextAlignmentCenter;
          _textField.borderStyle = UITextBorderStyleRoundedRect;
          _textField.returnKeyType = UIReturnKeyDone;
          _textField.delegate = self;
      }
      return _textField;
  }
  
  -(BOOL)textFieldShouldReturn:(UITextField *)textField{
      [textField endEditing:YES];
      return YES;
  }
  
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      [self.textField resignFirstResponder];
  }
  @end
  ```
  #### 7.7.4 UITextField的字数限制代理方法
  在UITextFieldDelegate代理协议中，定义了textField:shouldChangeCharactersInRange:replacementString方法，当用户在一个UITextField对象中输入内容时，该方法会被持续调用，即每次输入都会调用该方法。通过该代理协议，可以监控用户的输入过程，并且对于用户的输入内容进行控制。该方法中提供了两个参数，其中range可以获取当前输入的内容的长度，string可以获取输入的内容。
  ```
  - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;
  ```
  示例代码
  ```
  -(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{
      if(range.location - range.length >=3){
          NSLog(@"字数超出限制，无法继续输入");
          return NO;
      }else{
          NSLog(@"字数未超出限制，可以继续输入");
          return YES;
      }
  }
  ```
  ## 第八章 高级UI控件
  ### 8.1 滚动视图UIScrollView
  #### 8.1.1 UIScrollView基本使用
  UIScrollView 是一个能够在上下左右四个方向滚动的控件，UITableView、UICollectionView也是继承自UIScrollView.
  ![a63cbd69.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\a63cbd69.png)
  1. UIScrollView简介
  UIScrollView用于显示超出屏幕大小的内容，一般需要配合其他控件来使用，如添加一个UIImageView子控件，可以用来显示更大的图片。UITableView、UICollectionView、以及UITextView这些可以滑动显示更多内容的控件都是UIScrollView的子类。
  2. UIScrollView的常用属性
  UIScrollView在使用过程中有3个核心属性。
  - contentSize 表示UIScrollView内容的尺
  - contentOffset 当前屏幕显示区域的原点，在UIScrollView的位置
  - contentInset 可以在UIScrollView内容的四周增加额外的滚动区域
  
  除此之外，UIScrollView还有以下几个常用的属性
  - bounces 当UIScrollView滚动到边界时，再继续滚动会有个反弹的效果。注意如果不设置contentSize,bounces的效果显现不出来。
  - showHorizontalScrollIndicator 显示水平指示器
  - showsVerticalScrollIndicator 显示垂直指示器
  - pagingEnabled 分页效果
  - scrollEnabled UIScrollView 是否可以滚动
  
  3. 示例代码
  ```
  #import "ViewController.h"
  @interface ViewController ()
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.view.backgroundColor = [UIColor redColor];
      UIImageView *imageView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@"image"]];
      UIScrollView *myScrollView = [[UIScrollView alloc]initWithFrame:self.view.bounds];
      myScrollView.contentSize = imageView.bounds.size;
      myScrollView.backgroundColor = [UIColor redColor];
      myScrollView.contentOffset = CGPointMake(0, 0);
      myScrollView.contentInset = UIEdgeInsetsMake(0, 0, 0, 0);
      [myScrollView addSubview:imageView];
      [self.view addSubview:myScrollView];
      
  }
  @end
  ```
  #### 8.1.2 UIScrollView常用代理方法的实现
  1. UIScrollViewDelegate中的常用方法
  - 当滚动时不断调用
  ```
  - (void)scrollViewDidScroll:(UIScrollView *)scrollView;
  ```
  - 即将开始滚动时调用
  ```
  - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;
  ```
  - 手指离开屏幕，停止滚动时调用
  ```
  - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView 
                    willDecelerate:(BOOL)decelerate;
  ```
  示例代码
  ```
  #import "ViewController.h"
  
  @interface ViewController () <UIScrollViewDelegate>
  
  @end
  
  @implementation ViewController
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.view.backgroundColor = [UIColor redColor];
      UIImageView *imageView = [[UIImageView alloc]initWithImage:[UIImage imageNamed:@"image"]];
      UIScrollView *myScrollView = [[UIScrollView alloc]initWithFrame:self.view.bounds];
      myScrollView.contentSize = imageView.bounds.size;
      
      myScrollView.backgroundColor = [UIColor redColor];
      myScrollView.delegate = self;
      
      [myScrollView addSubview:imageView];
      [self.view addSubview:myScrollView];
      
  }
  
  -(void)scrollViewDidScroll:(UIScrollView *)scrollView{
      NSLog(@"滚动，调用ScrollViewDidScroll 方法");
  }
  
  -(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{
      NSLog(@"即将开始滚动时，调用ScrollViewWillBeginDraggin：方法");
  }
  
  -(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{
      NSLog(@"停止滚动时，调用scrollViewDidEndDragging: 方法");
  }
  
  @end
  ```
  ### 8.2 表视图UITableView
  表视图主要用于呈现一个滚动的选择列表，在使用过程中主要有三个步骤：
  初始化，数据源的设置以及委托代理方法的实现。
  UITableView中数据中只行的概念，并没有列的概念，因为在手机中显示多列是不利于操作的。
  #### 8.2.1 UITableView基本介绍
  1. UITableView样式
  UITableView有两种样式：平铺(UITableViewStylePlain)和分组(UITableViewStyleGrouped)，这两者本质区别不大。在没有特别设置的情况下，UITableViewStyleGrouped样式会默认留出header和footer的位置。也就是分组样式。
  ![ec2d7c09.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\ec2d7c09.png) ![7ee6f19f.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\7ee6f19f.png)
  2. UITableView的属性
  - 获取表视图的样式
  ```
  @property(nonatomic,readonly)UITableViewStyle style
  ```
  - UITableView的数据源对象与代理对象，需要遵守UITableViewDataSource协议与UITableViewDelegate
  ```
  @property(nonatomic,weak,nullable)id <UITableViewDataSource>dataSource;
  @property(nonatomic,weak,nullable)id <UITableViewDelegate> delegate;
  ```
  - 单元格的行高
  ```
  @property(nonatomic)CGFloat rowHeight
  ```
  - 段section的header高度与footer高度
  ```
  @property(nonatomic)CGFloat sectionHeaderHeight;
  @property(nonatomic)CGFloat sectionFooterHeight;
  ```
  - 整体表视图的顶部视图与底部视图
  ```
  @property(nonatomic,strong,nullable)UIView *tableHeaderView;
  @property(nonatomic,strong,nullable)UIView *tableFooterView;
  ```
  - 表索引的样式位置
  ```
  @property(nonatomic,strong,nullable)UIColor *sectionIndexColor;
  @property(nonatomic,strong,nullable)UIColor *sectionIndexBackgroundColor;
  ```
  - 分割线的样式设置
  ```
  @property(nonatomic,UITableViewCellSeparatorStyle separatorStyle);
  @property(nonatomic,strong,nullable)UIColor *separatorColor;
  ```
  
  #### 8.2.2 UITableView的数据方法
  1. UITableView 表视图的数据源简介
  对于UITableView类的对象，除了可以设置代理属性之外，还需要设置其数据源属性，因为UITableView中展示的数据是由其数据源对象提供的。在设置完UITableView的dataSource属性后，通过实现UITableViewDataSource协议中定义的数据源方法来为UITableView对象提供需要展示的数据。
  
  在UITableView中，引入了NSIndexPath类来定位每一个单元格。在NSIndexPath类中，包含两个关键属性:section和row,分别对应每个单元格在UITableView中段号Section与行号Row.根据索引路径indexPath即可定位到唯一的一个单元格。
  
  2. UITableViewDataSource中的常用方法
  UITableViewDataSource协议中，有3个方法是最常使用的，一般情况下在初始化UITableView时都需要实现，这3个方法分别用于返回表视图的段数、每段的行数以及每个单元格的样式与展示内容。
  - (必选)返回每个段(section)中有多少个单元格
  ```
  - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
  ```
  - (必选)返回每个单元格的具体样式和显示内容
  ```
  - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - (可选)返回整个表视图有多少个段(section)，如果不实现该方法，默认为1个段。
  ```
  - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;
  ```
  3. UITableViewDataSource中的其他方法
  - 设置某section上header的标题，当tableView的style是平铺时有悬浮效果，为分组时是没有时是没有悬浮效果的。
  ```
  - (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;
  ```
  - 设置每个段section上的footer的标题
  ```
  - (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;
  ```
  - 设置表视图的索引
  ```
  - (NSArray<NSString *> *)sectionIndexTitlesForTableView:(UITableView *)tableView;
  ```
  - 点击右侧索引栏时调用
  ```
  - (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;
  ```
  - 对单元格进行编辑(删除，添加)时调用
  ```
  - (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 设置单元格是否可移动
  ```
  - (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 对单元格的移动
  ```
  - (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
  ```
  #### 8.2.3 了解单元格UITableViewCell
  1. 系统自带单元格组成
  单元格(UITableViewCell)是UITableView的组成单元,每一个单元格都是一个UITableViewCell对象。默认情况下，一个单元格具有1个icon图片、1个title、1个detailtitle以及1个accessory。
  ![04cb5ed6.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\04cb5ed6.png)
  - imageView 显示在左边的一张图片logo
  - textLabel 主要文字，黑色字体显示，textLabel和detailTextLabel会在上图中的Text处显示。
  - detailTextLabel 详细说明文字，字体较小
  - accessaryView 附件视图，可以使用自定义View,也可以使用系统自带的一些标准按钮
  
  2. 系统自带单元格的样式
  默认情况下，系统自带了4中样式的单元格，区别在于显示的属性内容以及位置不同。
  - UITableViewCellStyleDefault
  - UITableViewCellStyleValue1
  - UITableViewCellStyleValue2
  - UITableViewCellStyleSubtitle
  ![478097fb.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\478097fb.png)
  3. Accessory View的简介
  Accessory View是显示在单元格最左边的图标，主要可以用来显示一些提示信息，默认情况下是不显示的。当需要显示AccessoryView时，可以有两种方式来设置。
  - 通过cell的accessoryType属性设置。此时可以使用系统提供的样式。
  ```
  @property(nonatomic)UITableViewCellAccessoryType accessoryType
  ```
  ![企业微信截图_16482762287476.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\87b40f84.png)
  
  - 通过cell的accessoryView属性来自定义附件的样式
  ```
  @property(nonatomic,strong,nullable)UIView *accessoryView
  ```
  #### 8.2.4 UITableView创建示例
  UITableView是由一个个的UITableViewCell单元格构成的，并且每个单元格中显示的数据都是通过其数据源对象来获取的。
  
  - 在ViewController.m文件中，设置该控制器类遵守UITableViewDataSource协议，并且添加一个UITableView类型的属性。
  ```
  @interface ViewController () <UITableViewDelegate,UITableViewDataSource>
  @property (nonatomic,strong) UITableView *tableView;
  @end
  ```
  - 对tableView属性进行懒加载，设置表视图的属性。
  ```
  -(UITableView *)tableView{
      if(_tableView == nil){
          _tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain];
          _tableView.dataSource = self;
      }
      return  _tableView;
  }
  ```
  - 把表视图添加到控制器View上
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.tableView]; 
  }
  ```
  - 实现UITableViewDataSource协议中的tableView:numberOfRowsInSection:方法，返回表视图中包含的单元格个数。
  ```
  -(NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
      return 20;
  }
  ```
  - 实现tableView:cellForRowAtIndexPath:方法，创建每一个单元格，该方法会被反复调用20次。
  ```
  -(UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
      static NSString *cellID = @"cell";
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];
      if(cell ==nil){
          cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellID];
      }
      NSString *text = [NSString stringWithFormat:@"%d",arc4random_uniform(1000000)];
      cell.textLabel.text = text;
      return cell;
  }
  ```
  #### 8.2.5 UITableView搭理方法之点击单元格
  在UITableView中的每个单元格Cell都可以监听用户的点击动作，并可以通过代理方法来进行一个逻辑处理。
  - 用户点击单元格时调用
  ```
  - (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath;
  - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 取消单元格选中调用
  ```
  - (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
  - (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 单元格高亮显示
  ```
  - (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath;
  - (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath;
  - (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  
  - 实例代码
  ```
  //通知委托是否开启点击高亮显示
  -(BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      return YES;
  }
  //通知委托指定行被高亮显示
  -(void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      NSLog(@"调用 tableView:didHighlightRowAtIndexPath: 方法");
  }
  //通知委托指定行不在高亮显示，一般是点击其他行的时候
  -(void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      NSLog(@"调用 tableView:didUnhighlightRowAtIndexPath:方法");
  }
  //通知委托指定行将要被选中，返回响应行的索引
  -(nullable NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      NSLog(@"调用 tableView:willSelectRowAtIndexPath:%@",indexPath);
      return indexPath;
  }
  //通知委托指定行将取消选中
  -(nullable NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      NSLog(@"调用 tableView:willDeselectRowAtIndexPath:%@",indexPath);
      return indexPath;
  }
  //通知委托指定行被选中
  -(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      NSLog(@"调用 tableView:didSelectRowAtIndexPath:方法");
  }
  //通知委托指定行被取消选中
  -(void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(nonnull NSIndexPath *)indexPath{
      NSLog(@"调用 tableView:didDeselectRowAtIndexPath:方法");
  }
  ```
  #### 8.2.6 UITableView代理方法之编辑单元格
  1. 单元格Cell编辑方法
  当希望对表视图中的单元格进行编辑时，因为涉及对数据的修改，因此需要通过表视图的代理进行操作。在UITableViewDelegate协议中，定义了如下几个与单元格修改的方法，当需要对单元格进行修改时，会调用对应的方法。
  - 设置对单元格修改时添加的按钮及其对应的处理事件
  ```
  - (NSArray<UITableViewRowAction *> *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 开始编辑单元格前调用的方法。
  ```
  - (void)tableView:(UITableView *)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 完成编辑单元格后调用的方法。
  ```
  - (void)tableView:(UITableView *)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  2. UITableViewRowAction简单介绍
  UITableViewRowAction 对象是用于设置UITableViewCell处于编辑状态下所显示的按钮，默认情况下，左滑会显示一个删除按钮，也可以创建多个UITableViewRowAction对象从而实现不同的操作。
  
  UITableViewRowAction 对象的创建可以调用API中定义的类方法，在该方法中包含3个参数，分别是按钮的样式style,显示的标题title以及用户点击按钮后的操作handler。
  ```
  + (instancetype)rowActionWithStyle:(NSTableViewRowActionStyle)style title:(NSString *)title handler:(void (^)(NSTableViewRowAction *action, NSInteger row))handler;
  ```
  除此之外，UITableViewRowAction对象还可以设置它的背景颜色backgroundColor,其title属性也可以被修改。
  
  3. 实现单元格编辑的基本步骤
  - 实现editActionsForRowAtIndexPath:方法
  - 创建UITableViewRowAction对象，并设置每个按钮对应的操作.
  - 调用reloadData方法刷新表格：对tableView的cell进行操作后，一定记得需要重新刷新表格，更新样式.
  
  ```
  #import "ViewController.h"
  @interface ViewController () <UITableViewDelegate,UITableViewDataSource>
  @property (nonatomic,strong) UITableView *tableView;
  @property (nonatomic,retain) NSMutableArray *data;
  @end
  @implementation ViewController
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.data = [NSMutableArray array];
      for(int i=0;i<20;i++){
          NSString *text = [NSString stringWithFormat:@"mj-%i",i];
          [self.data addObject:text];
      }
      _tableView.delegate = self;
      [self.view addSubview:self.tableView];
  }
  
  -(UITableView *)tableView{
      if(_tableView == nil){
          _tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain];
          _tableView.dataSource = self;
          _tableView.delegate = self;
      }
      return  _tableView;
  }
  
  -(NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
      return self.data.count;
  }
  
  -(UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
      static NSString *cellID = @"cell";
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];
      if(cell ==nil){
          cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellID];
      }
      cell.textLabel.text = [self.data objectAtIndex:indexPath.row];
      return cell;
  }
  -(nullable NSArray <UITableViewRowAction *>*)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath{
      UITableViewRowAction *action1 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@"添加" handler:nil];
      UITableViewRowAction *action2 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@"移动" handler:nil];
      UITableViewRowAction *action3 = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@"删除" handler:^(UITableViewRowAction*_Nonnull action,NSIndexPath*_Nonnull indexPath){
          NSLog(@"删除第%ld行",(long)indexPath.row);
          [self.data removeObjectAtIndex:indexPath.row];
          [tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];
      }];
      NSArray *actionArray = @[action1,action2,action3];
      return actionArray;
  }
  @end
  ```
  
  #### 8.2.7 UITableViewCell性能优化
  
  #### 8.2.8 分段Section
  1. Section的定义
  在UITableView中，可以设置多个段Section,每个Section中可以包含若干个单元格Cell,同时每个Section还包含了一个头部视图以及一个底部视图，因此具有很强的定制能力。
  
  2. 在UITableViewDataSource协议中，如果涉及多个Section的配置，则需要实现如下方法。如不实现，则section的默认值为1，即整个表视图只有一个段Section.
  ```
  - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;
  ```
  3. Section的header/footer的title设置
  如果Section的header以及footer只显示一些文字提示，则可以直接调用UITableViewDataSource协议中的方法来设置。
  - 设置header文字
  ```
  - (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;
  ```
  - 设置footer文字
  ```
  - (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;
  ```
  4. Section的header/footer的自定义样式
  通常情况下，在开发App的过程中，Section的header,footer并不仅仅需要显示一些普通的文字，而是需要对显示的样式进行定制，这就需要通过UITableViewDelegate中定义的代理方法进行定制。
  - 定制Section的顶部视图样式
  ```
  - (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;
  ```
  - 定制Section的底部视图样式
  ```
  - (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;
  ```
  5. Section的索引
  在表视图的右侧，可以定制每个section的索引，可以通过如下方法以及属性来设置。例如，在通讯录应用中，右侧的索引可以显示联系人的姓名拼音首字。
  
  - 索引显示的内容需要通过sectionIndexTitlesForTableView:数据源方法来实现，索引内容需要存放在一个数组中作为该方法的返回值，数组中的每个对象都与一个Section对应。
  ```
  - (NSArray<NSString *> *)sectionIndexTitlesForTableView:(UITableView *)tableView;
  ```
  - 索引文字颜色
  ```
  @property(nonatomic, strong) UIColor *sectionIndexColor;
  ```
  - 索引背景颜色
  ```
  @property(nonatomic, strong) UIColor *sectionIndexBackgroundColor;
  ```
  - 索引点击时的背景颜色
  ```
  @property(nonatomic, strong) UIColor *sectionIndexTrackingBackgroundColor;
  ```
  #### 8.2.9 分段Section实现示例
  1. 准备工作
  在ViewController.m中直接添加一个UITableView类型的属性，ViewController作为UITableView的代理及数据源要遵守UITableView的代理协议和数据源协议。
  ```
  @interface ViewController () <UITableViewDelegate,UITableViewDataSource>
  @property (nonatomic,strong) UITableView *tableView;
  @end
  ```
  通过懒加载的方式初始化UITableView,并对其做一些简单的设置.
  ```
  -(UITableView *)tableView{
      if(_tableView == nil){
          _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, [UIScreen mainScreen].bounds.size.width,[UIScreen mainScreen].bounds.size.height)style:UITableViewStyleGrouped];
          //设置代理和数据源
          _tableView.dataSource = self;
          _tableView.delegate = self;
          //分割线与屏幕等宽
          _tableView.separatorInset = UIEdgeInsetsMake(0,0,0,0);
          //分割线颜色
          _tableView.separatorColor = [UIColor blueColor];
          //索引栏颜色
          _tableView.sectionIndexBackgroundColor = [UIColor clearColor];
          //索引文字颜色
          _tableView.sectionIndexColor = [UIColor redColor];
      }
      return  _tableView;
  }
  ```
  将TableView作为子视图添加到控制器View上。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.tableView];
  }
  ```
  2. 实现数据源方法
  - 实现UITableViewDataSource中定义的必须实现的数据源方法，设置每个Section中单元格的数量，并创建所有的单元格对象
  ```
  -(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
      return 4;
  }
  
  -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
      //设定重用标识符
      static NSString *cellID = @"cellID";
      //重用机制
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];
      if(cell == nil){
          cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:cellID];
      }
      cell.textLabel.text = @"99iOS";
      cell.detailTextLabel.text = @"苹果IOS开发进阶之路";
      cell.imageView.image = [UIImage imageNamed:@"99logo"];
      cell.accessoryType = UITableViewCellAccessoryNone;
      return cell;
  }
  ```
  - 设置Section数量
  ```
  -(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{
      return 2;
  }
  ```
  3. 设置Section的头部文字与底部文字
  - 设置Section的header文字
  ```
  -(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section{
      NSString *message = [NSString stringWithFormat:@"这是第%ld个Section头部时图",(long)section];
      return message;
  }
  ```
  - 设置Section的footer文字
  ```
  -(NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section{
      NSString *message = [NSString stringWithFormat:@"这是第%ld个Section底部视图",(long)section];
      return message;
  }
  ```
  4. 设置Section的样式--使用自定义View
  - 定制头部视图样式
  ```
  -(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{
      UIView *headerView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width,30)];
      headerView.backgroundColor = [UIColor orangeColor];
      return headerView;
  }
  ```
  - 定制底部视图样式
  ```
  -(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section{
      UIView *footerView = [[UIView alloc]initWithFrame:CGRectMake(0, 0,[UIScreen mainScreen].bounds.size.width,30)];
      footerView.backgroundColor = [UIColor greenColor];
      return footerView;
  }
  ```
  5. 索引样式定制
  通过实现sectionIndexTitlesForTableView:方法即可实现索引内容的定制，该方法的返回值是一个数组，并且数组中存储的都是字符串类型的对象。由于数组中的对象是有序存储的，因此每个字符串对象都对应了一个段Section.
  当点击索引时，即可跳转到对应的段Section.另外，关于索引外观样式的定制需要在UITableView对象中设置。
  ```
  -(NSArray<NSString *>*)sectionIndexTitlesForTableView:(UITableView *)tableView{
      return @[@"s0",@"s1",@"s2",@"s3"];
  }
  ```
  #### 8.2.10 自定义Cell
  参考科大天行中CreateMeetingViewController,CreateMeetingTableViewCell
  
  #### 8.2.11 Cell高度的设置
  对于单元格高度的控制，有以下几种常用的方法：
  - 修改rowHeight属性。当单元格的高度为固定值时，可以使用rowHeight属性来设置单元格的高度。
  ```
  @property CGFloat rowHeight;
  ```
  - 在heightForRowAtIndexPath:代理方法中设置单元格的高度。tableView:heightForRowAtIndexPath:代理方法中可以根据indexPath参数，为每一个单元格设置不同的高度。
  ```
  - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 使用self-sizing,要求适配的版本必须在IOS8 以上。
  - 使用代码计算Cell高度，该方法的通用性比较强，需要提前根据显示的内容来计算单元格的高度，但需要编写的代码比较多，使用不太方便。
  - 使用第三方库UITableView+FDTemplateLayoutCell计算单元格高度。
  
  #### 8.2.12 动态调整Cell高度(self-sizing)
  在IOS 8中，苹果引入了UITableView的一项新功能-Self Sizing cells。
  
  1. self-sizing相关属性与方法
  当需要使用self-sizing功能时，需要同时满足如下几个预设条件才能使用。
  - 确认需要适配的iOS版本高于IOS8.
  - 必须使用自动布局方法来定义单元格的样式。
  - 设置表视图的estimatedRowHeight属性，即单元体的预估行高，一般设置为单元格的默认行高。
  ```
  @property(nonatomic) CGFloat estimatedRowHeight;
  ```
  - 将表视图的rowHeight属性设置为UITableViewAutomaticDimension.
  ```
  const CGFloat UITableViewAutomaticDimension;
  ```
  2. 示例代码
  - 使用XIB搭建Cell并设置约束。对于需要动态调整高度的控件，在使用自动布局设置约束时，一般不要设置其绝对高度，其高度要根据控件与其他控件的相对位置约束来确定。
  ![50b3e4d3.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\50b3e4d3.png)
  - 针对可变高度的UILabel需要设置其行数Lines为0
  ![c908ac9a.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\c908ac9a.png)
  - 初始化Cell.m 并初始化数据。
  ```
  Cell.h文件
  #import <UIKit/UIKit.h>
  #import "MYModel.h"
  NS_ASSUME_NONNULL_BEGIN
  @interface MYTableViewCell : UITableViewCell
  @property(nonatomic,strong)MYModel *cellData;
  +(instancetype) cellWithTableView:(UITableView *)tableview;
  @end
  NS_ASSUME_NONNULL_END
  
  Cell.m文件
  #import "MYTableViewCell.h"
  
  @interface MYTableViewCell()
  @property (weak, nonatomic) IBOutlet UIImageView *profileImageView;
  @property (weak, nonatomic) IBOutlet UILabel *userNameLabel;
  @property (weak, nonatomic) IBOutlet UILabel *sourceLabel;
  @property (weak, nonatomic) IBOutlet UIImageView *iconImageView;
  @property (weak, nonatomic) IBOutlet UILabel *contentLabel;
  @end
  
  @implementation MYTableViewCell
  
  +(instancetype)cellWithTableView:(UITableView *)tableview{
      static NSString *cellID = @"cell";
      MYTableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:cellID];
      if(cell == nil){
          cell = [[[NSBundle mainBundle]loadNibNamed:@"MYTableViewCell" owner:self options:nil]lastObject];
      }
      return cell;
  }
  - (void)layoutSubviews{
      [super layoutSubviews];
      self.profileImageView.layer.masksToBounds = YES;
      self.profileImageView.layer.borderWidth = 1;
      self.iconImageView.layer.masksToBounds = YES;
      self.iconImageView.layer.borderWidth = 1;
      self.contentLabel.adjustsFontSizeToFitWidth = YES;
  }
  - (void)setCellData:(MYModel *)cellData{
      _cellData = cellData;
      self.profileImageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%@",cellData.profileImageName]];
      self.userNameLabel.text = cellData.userName;
      self.sourceLabel.text = cellData.source;
      self.iconImageView.image = [UIImage imageNamed:[NSString stringWithFormat:@"%@",cellData.iconName]];
      self.contentLabel.text = cellData.content;
  }
  - (void)awakeFromNib {
      [super awakeFromNib];
      // Initialization code
  }
  - (void)setSelected:(BOOL)selected animated:(BOOL)animated {
      [super setSelected:selected animated:animated];
      // Configure the view for the selected state
  }
  @end
  ```
  - 为初始化表视图，并设置表视图属性以及数据。
  ```
  #import "ViewController.h"
  #import "MYModel.h"
  #import "MYTableViewCell.h"
  @interface ViewController () <UITableViewDelegate,UITableViewDataSource>
  @property (nonatomic,strong) UITableView *tableView;
  @property (nonatomic,retain) NSMutableArray *rowDataArray;
  @end
  
  @implementation ViewController
  
  -(NSMutableArray *)rowDataArray{
      if(_rowDataArray == nil){
          _rowDataArray = [NSMutableArray array];
          for(int i=0;i<20;i++){
              MYModel *model = [MYModel myCellModel];
              [self.rowDataArray addObject:model];
          }
      }
      return _rowDataArray;
  }
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.tableView];
  }
  
  -(UITableView *)tableView{
      if(_tableView == nil){
          _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width,[UIScreen mainScreen].bounds.size.height)style:UITableViewStyleGrouped];
          //设置数据源
          _tableView.dataSource = self;
          //分割线与屏幕等宽
          _tableView.separatorInset = UIEdgeInsetsMake(1, 0, 1, 0);
          //分割线颜色
          _tableView.separatorColor = [UIColor blackColor];
          _tableView.separatorStyle = UITableViewCellSeparatorStyleSingleLine;
          _tableView.estimatedRowHeight = 127;
          _tableView.rowHeight = UITableViewAutomaticDimension;
      }
      return _tableView;
  }
  -(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{
      return self.rowDataArray.count;
  }
  -(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
      MYTableViewCell *cell = [MYTableViewCell cellWithTableView:tableView];
      cell.cellData = self.rowDataArray[indexPath.row];
      return cell;
  }
  @end
  ```
  - 更新Model类的初始化方法。
  ```
  Model.h
  #import <Foundation/Foundation.h>
  #import <UIKit/UIKit.h>
  NS_ASSUME_NONNULL_BEGIN
  
  @interface MYModel : NSObject
  @property (nonatomic,copy) NSString *profileImageName;//头像
  @property (nonatomic,copy) NSString *userName;//发送用户
  @property (nonatomic,copy) NSString *source;//设备来源
  @property (nonatomic,copy) NSString *content;//内容
  @property (nonatomic,copy) NSString *iconName;//小图标
  @property (nonatomic,assign) CGFloat cellLabelHeight;
  +(instancetype)myCellModel;
  @end
  NS_ASSUME_NONNULL_END
  
  Model.m
  #import "MYModel.h"
  @implementation MYModel
  +(instancetype)myCellModel {
      MYModel *cellModel = [[MYModel alloc]init];
      cellModel.userName = @"99iOS";
      cellModel.profileImageName = @"99logo";
      cellModel.iconName = @"99logo";
      cellModel.source = @"来自99的iPhone 7 Plus";
      int arcNumber = arc4random_uniform(2);
      if (arcNumber == 1) {
          cellModel.content = @"对于需要动态调整高度的控件，在使用自动布局设置约束时，一定不要设置其绝对高度，其高度要根据控件与周边其他控件的位置约束来决定。如下图所示";
      }else {
          cellModel.content = @"苹果iOS开发进阶之路";
      }
      return cellModel;
  }
  @end
  ```
  #### 8.2.13 动态调整Cell(代码)
  
  #### 8.2.14 改变Cell位置
  在表视图中的单元格cell,可以通过代理方法调整其显示的顺序/位置，该功能在实际的应用开发中。
  如果需要调整cell的位置，首先需要设置表视图的editing属性为true
  ```
  tableView.editing = YES;
  ```
  另外，还需要添加tableView:moveRowAtIndexPath:toIndexPath:代理方法，在该方法中，可以获取单元格的原索引位置sourceIndexPath以及更新后的索引位置destinationIndexPath,通过这两个属性，需要去修改该单元格对应的数据在数据源数组中的位置，以便再次刷新界面后，该单元格的显示顺序是不变的。
  ```
  - (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
  ```
  
  示例
  ```
  -(void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{
      MYModel *model = self.rowDataArray[sourceIndexPath.row];
      [self.rowDataArray removeObjectAtIndex:sourceIndexPath.row];
      [self.rowDataArray insertObject:model atIndex:destinationIndexPath.row];
  }
  ```
  #### 8.2.15 UITableView的Header和Footer
  每一个UITableView对象都有一个tableHeaderView属性和一个tableFooterView属性，这两个属性是对应整个表视图的顶部视图和底部视图。
  需要主要同Section的HeaderView以及FooterView进行区分。通常来说UITableView的tableHeaderView经常会放置搜索栏或者图片轮播器，tableFooterView也可以根据设计需要添加定制的视图类UIView类控件。
  
  示例代码
  ```
  -(UITableView *)tableView{
      if(_tableView == nil){
          _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width,[UIScreen mainScreen].bounds.size.height)style:UITableViewStyleGrouped];
          _tableView.dataSource = self;
          //UITableView 的顶部视图
          UIView *tableViewHeader = [[UIView alloc]initWithFrame:CGRectMake(0,0, [UIScreen mainScreen].bounds.size.width, 40)];
          tableViewHeader.backgroundColor = [UIColor greenColor];
          _tableView.tableHeaderView = tableViewHeader;
          //UITableView 的底部视图
          UIView *tableViewFooter = [[UIView alloc]initWithFrame:CGRectMake(0,0, [UIScreen mainScreen].bounds.size.width, 50)];
          tableViewFooter.backgroundColor = [UIColor yellowColor];
          _tableView.tableFooterView = tableViewFooter;
      }
      return _tableView;
  }
  ```
  #### 8.2.16 去除多余的单元格分割线
  当单元格Cell的数量不够覆盖整个屏幕的时候，系统默认情况下，会自动添加一些分割线。
  去除多余的单元格分割线的设置方法如下，初始化一个空的UIView对象，并把其赋值给表视图的tableFooterView属性。
  ```
  UIView *view = [UIView new];
  view.backgroundColor = [UIColor clearColor];
  _tableView.tableFooterView = view;
  ```
  ### 8.3 集合视图UICollectionView
  #### 8.3.1 UICollectionView简介
  UICollectionView 集合视图，是在IOS6中推出的。它和UITableView共享API设计，但它在UITableView上做了一些扩展。UICollectionView独特的强大之处，就是其完全灵活的布局结构。
  它可以提供网状排列的UI控件。在IOS中，要实现九宫数据显示，最常用的做法就是使用UICollectionView。UICollectionView继承自UIScrollView.
  在使用集合视图时，需要提供两个核心的元素。
  第一：集合视图需要显示的数据。
  第二：集合视图的布局方法。
  
  1. 集合视图简介
  集合视图由3部分组成
  - Cell：单元格
  - Supplementary View:补充视图，指的就是图中的Header与Footer，每个段Section都可以设置不同的补充视图。
  - Decoration View:装饰视图，一般用于背景
  ![6c2bfbd8.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\6c2bfbd8.png)
  
  2. 集合视图的布局
  集合视图有2种布局
  - UICollectionViewFlowLayout
  Flow Layout是一个单元格的线性布局方案，并具有页面和页脚。
  ![e1ebc79c.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\e1ebc79c.png)
  - 自定义布局方式
  这种布局方式具有很大的灵活性，但需要开发者创建一个UICollectionViewLayout类型的对象，并针对布局编写相关的代码。
  ![22962e7d.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\22962e7d.png)
  
  3. 集合视图的常见属性
  集合视图继续自UIScrollView,因此其具有父类的所有属性和方法。
  - 布局对象，用于实现单元格的自定义布局
  ```
  @property(strong) __kindof NSCollectionViewLayout *collectionViewLayout;
  ```
  - 集合视图的初始化方法，需要传递一个UICollectionViewLayout类型的布局对象。
  ```
  - (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout;
  ```
  - 背景视图，会自动填充整个UICollectionView
  ```
  @property(nonatomic, readonly) UIView *backgroundView;
  ```
  - 是否允许选中Cell,默认允许选中.
  ```
  @property(nonatomic) BOOL allowsSelection;
  ```
  - 是否可以多选，默认只能单选
  ```
  - (BOOL)allowsMultipleSelection;
  ```
  #### 8.3.2 UICollectionView数据源协议DataSource
  UICollectionView的数据源对象为集合视图的单元格Cell提供了数据，其基本使用方法与UITableView的数据源方法类似，但区别在于集合视图需要提前注册单元格Cell.
  1. 常用数据源方法
  必须实现的方法
  - 返回单元格个数
  ```
  - (NSInteger)collectionView:(NSCollectionView *)collectionView numberOfItemsInSection:(NSInteger)section;
  ```
  - 根据indexPath属性，返回该单元格的具体样式和显示内容
  ```
  - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  另外，与表视图的数据源协议类似，这里还可以设置集合视图中包含的段Section数量。
  - 返回段Section个数，默认为1
  ```
  - (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView;
  ```
  - 设置头尾视图，同样也要先注册
  ```
  - (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;
  ```
  - 设置单元格是否可以移动
  ```
  - (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 获取被移动单元格的原始位置与最新位置，移动单元格后调用，此方法用于更新数据源中的数据。
  ```
  - (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
  ```
  2. 注册单元格
  在集合视图中的单元格必须在创建集合视图时进行注册，单元格有两种注册方式，分别对应通过代码创建的单元格以及通过XIB创建的单元格.
  - 通过代码创建出的单元格的注册方法
  ```
  - (void)registerClass:(Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;
  ```
  - 通过xib创建出的单元格的注册方法
  ```
  - (void)registerNib:(UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;
  ```
  #### 8.3.3 最简单的集合视图实现
  ```
  #import "ViewController.h"
  @interface ViewController () <UICollectionViewDataSource>
  @property(nonatomic,strong) UICollectionView *collectionView;
  @end
  
  @implementation ViewController
  
  
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.collectionView];
      [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"cell"];
  }
  
  -(UICollectionView *) collectionView{
      if(_collectionView == nil){
          //UICollectionViewLayout是UICollectionViewFlow的父类
          UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc]init];
          _collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
          _collectionView.dataSource = self;
          _collectionView.backgroundColor = [UIColor whiteColor];
      }
      return _collectionView;
  }
  
  -(NSInteger) collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{
      return 100;
  }
  
  -(__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{
      UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"cell" forIndexPath:indexPath];
      cell.backgroundColor = [UIColor yellowColor];
      return cell;
  }
  
  @end
  ```
  
  #### 8.3.4 UICollectionView代理协议方法简介
  通过UICollectionView的代理协议UICollectionViewDelegate中定义的方法，可以捕获用户点击集合视图中单元的行为。
  
  1. 与用户点击相关的代理方法
  - 单元格被选中时调用
  ```
  - (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 设置单元格是否能够被选中
  ```
  - (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 设置单元格是否能够取消选中
  ```
  - (BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 单元格item被取消选中时调用
  ```
  - (void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  
  2. 与单元格高亮显示相关的代理方法
  - 单元格为高亮状态时调用，只有当collectionView:shouldHighlightItemAtIndexPath:方法返回YES时，此方法才有用。
  ```
  - (void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 单元格取消高亮状态时调用
  ```
  - (void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  #### 8.3.5 UICollectionView代理方法实例
  前提要先实现UICollectionViewDlegate代理。
  
  
  - 实现单元格被选中时的代理方法
  ```
  //设置单元格能够选中
  -(BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath{
      return YES;
  }
  //设置单元格能够取消选中
  -(BOOL)collectionView:(UICollectionView *)collectionView shouldDeselectItemAtIndexPath:(NSIndexPath *)indexPath{
      return YES;
  }
  //单元格被选中时调用
  -(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath{
      NSLog(@"%s",__func__);
      UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];
      cell.backgroundColor = [UIColor greenColor];
  }
  //单元格被取消选中时调用
  -(void)collectionView:(UICollectionView *)collectionView didDeselectItemAtIndexPath:(NSIndexPath *)indexPath{
      NSLog(@"%s",__func__);
      UICollectionViewCell *cell = [collectionView cellForItemAtIndexPath:indexPath];
      cell.backgroundColor = [UIColor redColor];
  }
  ```
  - 实现单元格高亮状态显示相关的代理方法
  ```
  //设置单元格能够设置高亮显示
  -(BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath{
      return YES;
  }
  
  //单元格维高亮状态时调用
  -(void)collectionView:(UICollectionView *)collectionView didHighlightItemAtIndexPath:(NSIndexPath *)indexPath{
      NSLog(@"%s",__func__);
  }
  //单元格取消高亮状态时调用
  -(void)collectionView:(UICollectionView *)collectionView didUnhighlightItemAtIndexPath:(NSIndexPath *)indexPath{
      NSLog(@"%s",__func__);
  }
  ```
  #### 8.3.6 UICollectionViewFlowLayout简介
  UICollectionView将其子视图的位置，大小和外观的控制权委托给一个单独的布局对象UICollectionViewLayout。UICollectionViewLayout是一个抽象基类。
  UICollectionView类从名称上理解是一个流式的布局，各个单元格是从左到右依次排列的。当一行排列完成后，会自动切换到下一行。
  ![d76fc0c1.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\d76fc0c1.png)
  
  - 单元格之间的最小行间距
  ![c2382f9d.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\c2382f9d.png)
  
  - 单元格之间的最小列间距
  ![ad63fd98.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\ad63fd98.png)
  - 单元格的尺寸，通过这个属性设置的单元格尺寸是统一的，另外，每个单元格的尺寸都可以不同，如果要完成这种效果，需要实现collectionView:layout:sizeForItemAtIndexPath:
  ![1a0d07a4.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\1a0d07a4.png)
  - 段Section的四边距
  ![7a31c468.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\7a31c468.png)
  
  #### 8.3.7 UICollectionViewFlowLayout使用实例
  - 创建集合视图对象，并设置其布局属性。创建一个UICollectionViewFlowLayout类的布局对象，并对其中布局相关的属性进行设置后，把其作为入参传入集合视图的实例化方法中。
  ```
  -(UICollectionView *) collectionView{
      if(_collectionView == nil){
          //UICollectionViewLayout是UICollectionViewFlow的父类
          UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc]init];
          flowLayout.minimumLineSpacing = 30;
          flowLayout.minimumInteritemSpacing = 40;
          flowLayout.headerReferenceSize = CGSizeMake([UIScreen mainScreen].bounds.size.width,50);
          flowLayout.footerReferenceSize =CGSizeMake([UIScreen mainScreen].bounds.size.width,50);
          
          flowLayout.sectionInset = UIEdgeInsetsMake(10, 20, 30, 40);
      
          _collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
          _collectionView.dataSource = self;
          _collectionView.delegate = self;
          //_collectionView.backgroundColor = [UIColor whiteColor];
      }
      return _collectionView;
  }
  ```
  - 在viewDidLoad方法中注册单元格和段Section的头尾视图
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self.view addSubview:self.collectionView];
      [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@"cellId"];
      //注册header和footer
      [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerView"];
      [self.collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footerView"];
  }
  ```
  - 在集合视图的数据源方法中，设置每个段中单元格的数量以及集合视图中包含的段Section数。
  ```
  -(NSInteger) collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{
      return 10;
  }
  
  -(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView{
      return 10;
  }
  ```
  - 在集合视图的数据源方法中，创建单元格对象
  ```
  -(__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{
      UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"cellId" forIndexPath:indexPath];
      cell.backgroundColor = [UIColor yellowColor];
      return cell;
  }
  ```
  - 实现头尾视图
  ```
  -(UICollectionReusableView *) collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{
      UICollectionReusableView *reusableView = nil;
      if([kind isEqualToString:UICollectionElementKindSectionHeader]){
          UICollectionReusableView *header = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerView" forIndexPath:indexPath];
          header.backgroundColor = [UIColor greenColor];
          reusableView = header;
      }else{
          UICollectionReusableView *footer = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footerView" forIndexPath:indexPath];
          footer.backgroundColor = [UIColor redColor];
          reusableView = footer;
      }
      return reusableView;
  }
  ```
  #### 8.3.8 UICollectionViewDelegateFlowLayout类的代理方法实现
  1. UICollectionViewDelegateFlowLayout介绍
  使用流式布局的集合视图中，其单元格的大小以及位置不仅可以通过属性设置，还可以通过UICollectionViewDelegatelowLayout类中定义的协议方法进行动态设置。UICollectionViewDelegateFlowLayout协议中的所有方法都不是必须实现的，当没有实现该协议中的方法时。
  集合视图的布局样式会由其collectionViewLayout属性来设置。当需要实现该协议中的方法时，需要预先设置集合视图的delegate属性。
  - 设置单元格的大小
  ```
  - (NSSize)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath;
  ```
  - 单元格的边距设置，即Cell整体相对于Header,Footer以及屏幕左右两侧的距离。
  ```
  - (NSEdgeInsets)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section;
  ```
  - 单元格之间横向间距与纵向间距的设置
  ```
  - (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section;
  ```
  ```
  - (CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section;
  ```
  - 设置某个段Section的Header与Footer的大小
  ```
  - (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section;
  ```
  ```
  - (NSSize)collectionView:(NSCollectionView *)collectionView layout:(NSCollectionViewLayout *)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section;
  ```
  
  2. 示例代码
  - 设置预置条件。
  ```
  @interface ViewController () <UICollectionViewDataSource,UICollectionViewDelegateFlowLayout>
  @property(nonatomic,strong) UICollectionView *collectionView;
  @end
  
  @implementation ViewController
  ``` 
  ```
  -(UICollectionView *) collectionView{
      if(_collectionView == nil){
          //UICollectionViewLayout是UICollectionViewFlow的父类
          UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc]init];
          _collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout];
          _collectionView.dataSource = self;
          _collectionView.delegate = self;
          //_collectionView.backgroundColor = [UIColor whiteColor];
      }
      return _collectionView;
  }
  ```
  - 设置单元格Cell的大小
  ```
  -(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath{
      CGFloat screenWidth = [UIScreen mainScreen].bounds.size.width;
      CGFloat cellWidth = (screenWidth-20-40-2*20)/3;
      return CGSizeMake(cellWidth, 60);
  }
  ```
  - 设置单元格的边距。单元格Cell的边距设置，即Cell整体相对于Header、Footer以及屏幕左右两侧的距离，优先级较高
  ```
  -(UIEdgeInsets)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout insetForSectionAtIndex:(NSInteger)section{
      UIEdgeInsets insets = UIEdgeInsetsMake(10, 20, 30, 40);
      return insets;
  }
  ```
  - 设置单元格Cell之间的横向距离与纵向距离
  ```
  -(CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section{
      return 20;;
  }
  ```
  ```
  -(CGFloat)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section{
      return 20;
  }
  ```
  - 设置段Section的header与Footer的大小
  ```
  -(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section{
      CGSize headerSize = CGSizeMake([UIScreen mainScreen].bounds.size.width,50);
      return headerSize;
  }
  ```
  ```
  -(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section{
      CGSize footerSize = CGSizeMake([UIScreen mainScreen].bounds.size.width, 50);
      return footerSize;
  }
  ```
  #### 8.3.9 自定义Cell
  
  ### 8.4 手势UIGestureRecognizer
  
  #### 8.4.1 UIGestureRecognizer简介
  UIKit框架一共提供了6种类型的手势操作，分别为:点击，捏合，旋转，滑动，拖动，长按。手势需要添加到UIView类以及其子类之上，同时每个UIView可以添加多个手势。
  
  1. UIGestureRecognizer类简介
  UIGestureRecognizer类是一个抽象类，不能直接使用，具体使用过程中需要使用子类。UIGestureRecognizer一共包括6个子类，分别对应6中手势。
  - UITapGestureRecognizer:点击
  - UIPinchGestureRecognizer:捏合
  - UIRotationGestureRecognizer:旋转
  - UISwipeGestureRecognizer:滑动
  - UIPanGestureRecognizer:拖动
  - UILongPressGestureRecognizer长按
  
  2. UIGestureRecognizer创建方法
  - 使用-initWithTarget:action:方法创建一个手势类对象，设置当手势事件发生时，调用的方法。
  - 使用addGestureRecognizer:方法，把手势对象添加到一个UIView的对象上。
  - 实现手势事件发生时所调用的方法
  3. UIGestureRecognizer类常用属性以及方法
  UIGestureRecognizer类虽然是一个抽象类，但是其中定义了其子手势类中可以通用的方法和属性。
  - 初始化手势对象并设置手势发生时调用的方法
  ```
  - (instancetype)initWithTarget:(id)target action:(SEL)action;
  ```
  - 获取手势点击的位置
  ```
  - (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(UIView *)view;
  ```
  - 获取手势点击的状态和视图
  ```
  @property(nonatomic,readonly)UIGestureRecognizerState state;
  ```
  常用的UIGestureRecognizerState有以下几个
  UIGestureRecognizerStateBegon:开始手势事件
  UIGestureRecognizerStateEnded:结束手势事件
  UIGestureRecognizerStateChanged:手势位置发生变化
  UIGestrueRecognizerStateFailed:无法识别的手势
  
  - 手势事件对应的视图对象
  ```
  @property(nullable,nonatomic,readonly) UIView *view
  ```
  #### 8.4.2 点击手势UITapGestureRecognizer
  UITapGestureRecognizer类能够识别点击手势，同时能够识别点击/双击，甚至能够识别到使用几根手指来进行点击。
  1. UITapGestureRecognizer类介绍
  - 需要点击的次数，用于识别单击或双击，默认为单击。
  ```
  @property(nonatomic)NSUInteger numberOfTapsRequired;
  ```
  - 点击的手指数，默认为：1
  ```
  @property(nonatomic)NSUInteger numberOfTouchesRequired;
  ```
  2. 单个手指单击手势实现
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //创建UIView对象
      UIView *myView = [[UIView alloc]initWithFrame:CGRectMake(50, 50, 250, 50)];
      myView.backgroundColor = [UIColor redColor];
      [self.view addSubview:myView];
      //单击，单手指
      UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(singleTap:)];
      //单击
      singleTap.numberOfTapsRequired = 1;
      //单手指
      singleTap.numberOfTouchesRequired = 1;
      [myView addGestureRecognizer:singleTap];
  }
  -(void)singleTap:(UITapGestureRecognizer *)tap{
      NSLog(@"单个手势单击触发！");
  }
  ```
  3. 双手指双击手势实现
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //创建UIView对象
      UIView *myView = [[UIView alloc]initWithFrame:CGRectMake(50, 50, 250, 50)];
      myView.backgroundColor = [UIColor redColor];
      [self.view addSubview:myView];
      //单击，单手指
      UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(singleTap:)];
      //单击
      singleTap.numberOfTapsRequired = 2;
      //单手指
      singleTap.numberOfTouchesRequired = 2;
      [myView addGestureRecognizer:singleTap];
  }
  -(void)singleTap:(UITapGestureRecognizer *)tap{
      NSLog(@"两个手指双击触发！");
  }
  ```
  #### 8.4.3 捏合与旋转手势UIPinchGestureRecognizer
  #### 8.4.4 滑动手势UISwipeGestureRecognizer
  #### 8.4.5 拖动手势UIPanGestureRecognizer
  #### 8.4.6 长按手势UILongPressGestureRecognizer
  
  ## 第九章 控制器
  ### 9.1 控制器UIViewController
  #### 9.1.1 控制器简介以及创建控制器
  1. UIViewController简介
  UIViewController是所有控制器的根类，常见的子类有UITableViewController,UICollectionViewController,UINavigationController,UITabbarController。
  创建控制器的方法有：
  - 通过代码创建控制器
  - 通过XIB创建控制器
  - 通过Storyboard创建控制器
  2. 使用代码创建控制器
  
  ![e1f67b57.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\e1f67b57.png)
  在AppDelegate.m文件中，实例化这个控制器类，并设置为窗口window的根控制器，最后显示出来。
  ```
  #import "AppDelegate.h"
  #import "MYViewController.h"
  @interface AppDelegate ()
  @end
  @implementation AppDelegate
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      MYViewController *rootVc = [[MYViewController alloc]init];
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController = rootVc;
      [self.window makeKeyAndVisible];
      return YES;
  }
  ```
  #### 9.1.2 使用XIB以及Storyboard创建控制器
  1. 使用XIB创建控制器
  ![260c1830.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\260c1830.png)
  创建成功后，系统会自动创建3个文件，分别为.h.m.xib文件。
  ![3b0a7ea4.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\3b0a7ea4.png)
  选中.xib文件，可以看到XIB文件的File's Owner属性为XibViewController类。
  ![21a057f7.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\21a057f7.png)
  在AppDelegate.m文件中，实例化这个控制器，并设置为Window的根控制器。**注意实例化控制器使用initWithNibName方法**
  ```
  #import "AppDelegate.h"
  #import "ViewController.h"
  #import "XibViewController.h"
  @interface AppDelegate ()
  @end
  @implementation AppDelegate
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      XibViewController *rootVc = [[XibViewController alloc]initWithNibName:@"XibViewController" bundle:nil];
      self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController = rootVc;
      [self.window makeKeyAndVisible];
      return YES;
  }
  ```
  #### 9.1.3 控制器的生命周期
  1. 与控制器生命周期相关的常用方法
  所谓控制器的生命周期，通俗来讲，就是控制器的创建、视图的加载与显示，以及控制器的销毁等操作。
  - 控制器初始化方法
  ```
  - (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil;
  - (instancetype)initWithCoder:(NSCoder *)coder;
  ```
  - 控制器视图加载与现实方法
  ```
  - (void)loadView;
  - (void)viewDidLoad;
  - (void)viewWillAppear:(BOOL)animated;
  - (void)viewDidAppear:(BOOL)animated;
  - (void)viewWillDisappear:(BOOL)animated;
  - (void)viewDidDisappear:(BOOL)animated;
  - (void)viewWillLayoutSubviews;
  - (void)viewDidLayoutSubviews;
  ```
  - 控制器销毁时候调用的相关方法
  ```
  - (void)dealloc;
  ```
  2. 控制器生命周期相关方法的调用时机
  - 使用代码创建控制器。当使用代码创建控制器时，一般会使用init方法进行实例化。
  ```
  2022-05-09 21:49:32.460288+0800 HelloWorld[226:4098] -[CodeViewController init]
  2022-05-09 21:49:32.462915+0800 HelloWorld[226:4098] -[CodeViewController loadView]
  2022-05-09 21:49:32.463568+0800 HelloWorld[226:4098] -[CodeViewController viewDidLoad]
  2022-05-09 21:49:32.463810+0800 HelloWorld[226:4098] -[CodeViewController viewWillAppear:]
  2022-05-09 21:49:32.467797+0800 HelloWorld[226:4098] -[CodeViewController viewWillLayoutSubviews]
  2022-05-09 21:49:32.467942+0800 HelloWorld[226:4098] -[CodeViewController viewDidLayoutSubviews]
  2022-05-09 21:49:32.470499+0800 HelloWorld[226:4098] -[CodeViewController viewDidAppear:]
  ```
  - 使用XiB创建控制，当使用XIB创建控制器时，一般会使用initWithNibName方法进行实例化。
  ```
  2022-05-09 21:58:21.539530+0800 HelloWorld[279:6834] -[XibViewController initWithNibName:bundle:]
  2022-05-09 21:58:21.542130+0800 HelloWorld[279:6834] -[XibViewController loadView]
  2022-05-09 21:58:21.544401+0800 HelloWorld[279:6834] -[XibViewController viewDidLoad]
  2022-05-09 21:58:21.544983+0800 HelloWorld[279:6834] -[XibViewController viewWillAppear:]
  2022-05-09 21:58:21.549052+0800 HelloWorld[279:6834] -[XibViewController viewWillLayoutSubviews]
  2022-05-09 21:58:21.549196+0800 HelloWorld[279:6834] -[XibViewController viewDidLayoutSubviews]
  2022-05-09 21:58:21.551903+0800 HelloWorld[279:6834] -[XibViewController viewDidAppear:]
  ```
  #### 9.1.4 使用Storyboard切换控制器
  
  #### 9.1.5 使用代码切换控制器
  使用代码切换控制器之前，需要首先创建目标控制器，然后再调用presentViewController方法来完成控制器的切换
  1. 切换新的控制器
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      UIViewController *newVC = [[UIViewController alloc] init];
      newVC.view.backgroundColor = [UIColor redColor];
      [self presentViewController:newVC animated:YES completion:nil];
  }
  ```
  2. 返回原控制器
  当需要返回原控制器时，调用dismissViewControllerAnimated方法，此时该控制器对象会被销毁
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      UIViewController *newVC = [[UIViewController alloc] init];
      newVC.view.backgroundColor = [UIColor redColor];
      [self presentViewController:newVC animated:YES completion:^{
          dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
              [self dismissViewControllerAnimated:newVC completion:nil];
          });
      }];
  }
  ```
  #### 9.1.6 控制器嵌套
  1. 控制器嵌套简介
  所谓控制器嵌套，指的就是在一个父控制器上，再添加若干个子控制器。有些功能的实现可以在子控制器的代码中进行实现，同时子控制器与父控制器之间可以使用代理或者通知的方法进行通信，以便实现父子控制器之间的数据交互。
  UIViewController类中，对于子控制器提供了一些管理方法，包括:添加子控制器，移除子控制器等，常用的方法如下：
  - 获取父控制器对象中所有的子控制器，返回一个数组。
  ```
  @property(nonatomic,readonly)NSArray *childViewControllers;
  ```
  - 添加子控制器
  ```
  - (void)addChildViewController:(UIViewController *)childController;
  ```
  - 移除子控制器
  ```
  - (void)removeFromParentViewController;
  ```
  2. 父子控制器之间的通信
  父控制器和子控制之间可以建立通信机制，例如：当点击子控制器上的某个按钮时，通知父控制器跳转到一个新的控制器。父子控制器之间的通信方法可以采用以下两种方式。
  - 代理：在子控制器的类中，添加代理属性和代理方法，并在父控制器中实现代理方法。
  - 通知：当子控制器某个事件发生时，需要通知多个对象时，即一对多，也可以采用通知的方法。
  
  3. 示例代码
  在SubViewController中，定制子控制器的一些属性。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      self.view.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height *0.5,
                                   [UIScreen mainScreen].bounds.size.width,
                                   [UIScreen mainScreen].bounds.size.height *0.5);
      self.view.backgroundColor = [UIColor greenColor];
      UIImageView *iconImage = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"99logo"]];
      iconImage.frame = CGRectMake(120, 50, 128, 128);
      [self.view addSubview:iconImage];
  }
  ```
  在父控制器类中，添加一个子控制器属性，注意，使用Strong关键字，并实现子控制器的懒加载方法。
  ```
  #import "ViewController.h"
  #import "SubViewController.h"
  @interface ViewController ()
  @property (nonatomic,strong) SubViewController *subVC;
  @end
  @implementation ViewController
  - (void)viewDidLoad {
      [super viewDidLoad];
  }
  -(SubViewController *)subVC{
      if(_subVC == nil){
          _subVC = [[SubViewController alloc]init];
          [self.view addSubview:_subVC.view];
      }
      return _subVC;
  }
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      [self addChildViewController:self.subVC];
  }
  @end
  ```
  在需要创建子控制器的时候，使用addChildViewController:方法添加子控制器。
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      [self addChildViewController:self.subVC];
  }
  ```
  ### 9.2 导航控制器UINavigationController
  #### 9.2.1 导航控制器简介
  1. 控制器类型简介
  - 内容类控制器,主要用于显示内容，有UIViewController,UITableViewController,UICollectionViewController等。
  - 容器类控制器,**主要用于容纳内容类控制器，本身并不主要用于显示有用的内容。**主要负责在不同控制器之间进行转换。有UINavigationController,UITableBarController等。
  
  2. UINavigationController简介
  导航控制器在实际的App中十分常见，iPhone的设置功能中就使用到了导航控制器。通过导航控制器，可以实现控制器之间的跳转与返回。
  - 容器类控制器
  ![0f92511f.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\0f92511f.png)
  - 控制器间关系
  ![955baf5b.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\955baf5b.png)
  - 导航控制器跳转
  ![9554975d.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\9554975d.png)
  
  3. 堆和栈的简介
  导航控制器对于控制器的管理方法才哦用的就是栈的模式，遵守先进后出
  ![22b9bbf3.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\22b9bbf3.png)
  
  4. 创建导航控制器
  - 实例化一个控制器对象，作为导航控制器对象的根控制器rootViewController.
  
  - 实例化UINavigationController对象，并制定该导航控制器对象的根控制器rootViewcontroller.
  ```
  - (instancetype)initWithRootViewController:(UIViewController *)rootViewController;
  ```
  - 定制导航栏的显示样式。例如，可以设置导航栏的标题，需要注意的是该属性是在UINavigationController的父类UIViewController类中定义的。
  ```
  @property(nullable,nonatomic,copy)NSString *title
  ```
  5. 实例代码
  在定制导航栏中间文件的时候，设置的是navRootVC(UIViewController)的title属性，而不是navVC(UINavigationController类)的title属性。
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor redColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      navRootVC.title = @"99iOS.com";
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible];
      return YES;
  }
  ```
  #### 9.2.2 控制器跳转
  导航控制器的定义中，提供了Push与Pop的方法，来实现子控制器之间的跳转，其中Push对应入栈操作，Pop对应出栈操作。
  - 入栈操作，显示新的子控制器。
  ```
  - (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;
  ```
  - 出栈操作，显示目前在栈顶的控制器
  ```
  - (UIViewController *)popViewControllerAnimated:(BOOL)animated;
  ```
  - 出栈操作，显示指定的控制器
  ```
  - (UIViewController *)popViewControllerAnimated:(BOOL)animated;
  ```
  - 出栈操作，显示指定的控制器
  ```
  - (NSArray<__kindof UIViewController *> *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;
  ```
  - 出栈操作，显示导航控制器的根控制器
  ```
  - (NSArray<__kindof UIViewController *> *)popToRootViewControllerAnimated:(BOOL)animated;
  ```
  #### 9.2.3 子控制器的管理
  UINavigationController类中提供了可以访问所有子控制器的方法和属性，因此，可以通过导航控制器获取到其所管理的任意一个子控制器对象。
  另外，任意一个子控制器，也可以获取到管理它的导航控制器，继而可以与其他子控制器进行通信。
  
  1. 管理UINavigationController的子控制器
  导航控制器对象中提供了相关属性，用于获取该导航控制器管理下的所有子控制器，主要包括如下几个属性。
  - 获取导航控制器管理的所有子控制器，导航控制器的ViewController属性是一个数组，有序存放了该导航控制器管理的所有子控制器。
  ```
  @property(nonatomic,copy)NSArrray *viewController;
  ```
  - 获取栈顶控制器
  ```
  @property(nullable,nonatomic,readonly,strong)UIViewController *topViewController;
  ```
  
  2. UIViewController 中有关导航控制器的属性
  在UIViewController 对象中，也可以获取到管理自身的导航控制器，通过该属性，任何一个子控制器，都可以获取管理自身的导航控制器，并且通过该导航控制器继而可以获取到其他子控制器。
  ```
  @interface UIViewController(UINavigationControllerItem)
  @property(nullable,nonatomic,readonly,strong)UINavigationController *navigationController;
  @end
  ```
  #### 9.2.4 UINavigationBar
  UINavigationBar继承自UIView,它是UINavigationController中的一个重要属性，因此，导航栏样式主要是由UINavigationBar决定的。其影响的主要是除导航栏中按钮和标题之外的样式。
  例如背景颜色，背景图片等。而导航栏中左右两侧的按钮和中间的标题是在子控制器中设置的。
  1. UINavigationBar介绍
  UINavigationBar继承自UIView,因此导航栏的样式是由其决定的。另外，导航栏外观的定制主要包括以下两个内容。
  - UINavigationBar自身的外观属性：如背景颜色，文字颜色、BarStyle、背景图片等，所有子控制器都会使用的公共样式。
  ```
  @property(nonatomic,readonly)UINavigationBar *navigationBar;
  ```
  - UINavigationBar上的UINavigationItem:NavigationBar上的按钮都是UINavigationitem对象。
  一个导航控制器的创建过程中，会先创建一个NavigationBar,然后NavigationBar会创建对应控制器的NavigationItem.
  
  2. UINavigationBar的外观属性
  UINavigationBar中提供的有关样式设置主要属性和方法有以下几种。
  - 导航栏整体样式
  ```
  @property(nonatomic,assign)UIBarStyle barStyle;
  ```
  - 导航栏文字颜色
  ```
  @property(null_resettable,nonatomic,strong)UIColor *tintColor;
  ```
  - 导航栏背景颜色
  ```
  @property(nullable,nonatomic,strong)UIColor *barTintColor;
  ```
  - 设置导航栏背景图片
  ```
  - (void)setBackgroundImage:(UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics;
  ```
  3. 获取子控制器的UINavigationItem
  UINavigationBar类中也提供了用于获取在该控制器中的所有UINavigationItem对象，用于管理UINavigationitem的相关属性主要包括
  ```
  @property(nullable,nonatomic,copy)NSArray<UINavigationItem *>*items;
  @property(nullable,nonatomic,readonly,strong) UINavigationItem *topItem;
  @property(nullable,nonatomic,readonly,storng) UINavigationItem *backItem;
  ```
  #### 9.2.5 barStyle属性
  1. barStyle属性介绍
  UINavigationBar中的barStyle属性用于定制导航栏的样式，其有两种取值，分别是默认(UIBarStyleDefault)和黑色(UIBarStyleBlack)。
  
  2. 示例代码
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor redColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      navVC.navigationBar.barStyle = UIBarStyleDefault;
      navRootVC.title = @"99iOS.com";
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible]; 
      return YES;
  }
  ```
  #### 9.2.6 barTintColor与tintColor
  1. barTintColor属性
  barTintColor属性用于设置导航栏背景颜色，通过修改该属性，可以设置导航栏的整体背景颜色。虽然UINavigationBar继承自UIView,但是设置导航栏的背景颜色并不是使用backgroundColor属性，而是barTintColor属性。
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor redColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      navVC.navigationBar.barTintColor =[UIColor greenColor];
      navRootVC.title = @"99iOS.com";
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible];
      return YES;
  }
  ```
  2. tintColor
  tintColor属性用于设置导航栏图标被渲染的颜色。
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor redColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      navVC.navigationBar.barTintColor =[UIColor greenColor];
      navVC.navigationBar.tintColor = [UIColor redColor];
    
      navRootVC.title = @"99iOS.com";
      navRootVC.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"Cancel" style:UIBarButtonItemStylePlain target:self action:nil];
      navVC.navigationBar.tintColor = [UIColor whiteColor];
      
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible];
      return YES;
  }
  ```
  #### 9.2.7 导航栏设置背景图片
  在UINavigationBar类中，提供了setBackgroundImag:forBarMetrics:方法，该方法可以为导航栏添加背景图片。
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor redColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      
      navVC.navigationBar.barStyle = UIBarStyleDefault;
      
      [navVC.navigationBar setBackgroundImage: [UIImage imageNamed:@""] forBarMetrics:UIBarMetricsDefault];
      
      navRootVC.title = @"99iOS.com";
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible];
      return YES;
  }
  ```
  #### 9.2.8 UINavigationItem
  UINavigationItem类的对象主要用于导航栏上显示的按钮以及标题，一般来说，每个子控制器需要显示的标题以及按钮都不相同。
  1. UINavigationItem的常用属性
  UINavigationItem类的对象包含了用于设置导航栏的左侧，右侧以及中间视图的属性。中间可以显示一个UIView类型的titleView,左右两侧可以分别显示一个或者多个按钮。需要注意的是，显示在导航栏两侧的按钮是UIBarButtonItem类的对象，不是UIButton类。
  在UINavigationItem类中。
  - 中间的标题视图
  ```
  @property(nullable, nonatomic, strong) UIView *titleView;
  ```
  - 左侧/右侧单个按钮
  ```
  @property(nonatomic, readwrite, strong) UIBarButtonItem *leftBarButtonItem;
  @property(nonatomic, readwrite, strong) UIBarButtonItem *rightBarButtonItem;
  ```
  - 左侧/右侧设置多个按钮。当需要在导航栏两侧设置多个按钮时，可以创建若干个UIBarButtonItem对象，然后把这些对象放到leftBarButtonItems或rightBarButtonItems数组中。
  ```
  @property(nullable,nonatomic,copy)NSArray<UIBarButtonItem *>*leftBarButtonItems
  @property(nullable,nonatomic,copy)NSArray<UIBarButtonItem *>*rightBarButtonItems
  ```
  - 标题，如果设置了该属性，titleView不生效。UIViewController类也有一个title属性可以用于设置导航栏的标题。但UINavigationItem的title优先级要高。
  ```
  @property(nullable,nonatomic,copy)NSString *title;
  ```
  - 导航栏提示语
  ```
  @property(nullable,nonatomic,copy)NSString *prompt;
  ```
  2. UINavigationItem对象的创建
  在UINavigationItem类的API中提供了initWithTitle方法用于UINavigationItem对象的创建。使用该方法创建的UINavigationItem对象只有中间的标题，左右两侧的按钮需要另外定制
  ```
  -(instancetype)initWithTitle:(NSString *)title;
  ```
  3. UIBarButtonItem类
  UINavigationItem类中定义的按钮，不是UIButton类的，而是UIBarButtonItem类的，并且从UIBarButtonItem类的继承关系来看，其父类并不是UIView,而是UIBarItem,因此，UIBarButtonItem类并不具备诸如:backgroundColor之类的属性。
  ```
  @interface UIBarButtonItem: UIBarItem<NSCoding>
  ```
  在UIBarButtonItem类的定义中，也提供了几种常用的实例化方法。
  - 实例化一个只显示文字的按钮
  ```
  - (instancetype)initWithTitle:(NSString *)title style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;
  ```
  - 实例化一个只有图标的按钮
  ```
  - (instancetype)initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;
  ```
  - 当需要定义UIBarButtonItem类的外观时，可以使用initWithCustomView:方法，该方法传入一个UIView的参数，可以显示定制样式
  ```
  - (instancetype)initWithCustomView:(UIView *)customView;
  ```
  
  
  #### 9.2.9 UINavigationItem 定制示例
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor grayColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      
      UIBarButtonItem *leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"返回" style:UIBarButtonItemStylePlain target:self action:nil];
      navRootVC.navigationItem.leftBarButtonItem = leftBarButtonItem;
      
      UIBarButtonItem *rightBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"write_comment"] style:UIBarButtonItemStylePlain target:self action:nil];
      navRootVC.navigationItem.rightBarButtonItem = rightBarButtonItem;
      navRootVC.navigationItem.title = @"99iOS.com";
      navRootVC.navigationItem.prompt =@"苹果iOS开发进阶之路";
      
      navVC.navigationBar.tintColor = [UIColor redColor];
      
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible];
      
      return YES;
  }
  ```
  #### 9.2.10 UINavigationItem 显示原始图片样式
  在UIBarButtonItem的初始化方法中，提供了initWithCustomView方法，该方法需要传入一个UIView的对象，因此，可以考虑传入一个UIButton对象，把原始图片设置为该UIButton的图片
  ```
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
      UIViewController *navRootVC = [[UIViewController alloc]init];
      navRootVC.view.backgroundColor = [UIColor grayColor];
      UINavigationController *navVC= [[UINavigationController alloc]initWithRootViewController:navRootVC];
      
      UIBarButtonItem *leftBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@"返回" style:UIBarButtonItemStylePlain target:self action:nil];
      navRootVC.navigationItem.leftBarButtonItem = leftBarButtonItem;
      
      UIButton *rightBtn = [UIButton buttonWithType:UIButtonTypeCustom];
      rightBtn.frame = CGRectMake(0, 0, 44, 44);
      [rightBtn setImage:[UIImage imageNamed:@"write_comment"] forState:UIControlStateNormal];
      [rightBtn addTarget:self action:@selector(clickRightBarButton) forControlEvents:UIControlEventTouchUpInside];
      
      UIBarButtonItem *rightBarButtonItem = [[UIBarButtonItem alloc]initWithCustomView:rightBtn];
      navRootVC.navigationItem.rightBarButtonItem = rightBarButtonItem;
      
      navRootVC.navigationItem.title = @"99iOS.com";
      navVC.navigationBar.tintColor = [UIColor redColor];
      
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController =navVC;
      [self.window makeKeyAndVisible];
      
      return YES;
  }
  ```
  
  #### 9.2.11 UINavigationController的代理方法
  UINavigationBar的代理方法可以监听UINavigationBar添加NavigationItem的入栈和出栈操作，一般把导航控制器设置为UINavigationBar的代理对象。
  - 是否允许调用入栈push方法
  ```
  - (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item;
  ```
  - 入栈push动画播放完成后调用
  ```
  - (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item;
  ```
  - 是否允许调用出栈pop方法
  ```
  - (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item;
  ```
  - 出栈pop动画播放完成后调用
  ```
  - (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item;
  ```
  #### 9.2.12 顺传数据
  1. 顺传数据的核心思路是在目标控制中新增一个数据模型的属性，在执行pushViewController方法之前，把源控制器中的数据传递给该属性。
  
  - 在目标控制器中新增属性，用于接收数据
  - 在源控制器中初始化目标控制器，给目标控制器的新增属性赋值，并跳转到目标控制器。
  
  2. 示例代码
  - 在目标控制器中新增属性dataText，用于接收源控制器传递的字符串对象。
  ```
  #import <UIKit/UIKit.h>
  @interface DestinationViewController : UIViewController
  @property (nonatomic,copy) NSString *dataText;
  @end
  ```
  - 在源控制器中，初始化目标控制器DestinationViewController,给目标控制器的dataText属性赋值，并跳转到目标控制器。
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      DestinationViewController *descVC = [[DestinationViewController alloc]init];
      descVC.view.backgroundColor = [UIColor redColor];
      descVC.navigationItem.title = @"目标控制器";
      descVC.dataText = @"99iOS.com";
      [self.navigationController pushViewController:descVC animated:YES];
  }
  ```
  #### 9.2.13 使用代理逆传数据
  1. 示例代码
  - 在DestinationViewController中，新增代理协议DestinationViewControllerDelegate添加一个用于回传数据的代理方法,并新增代理属性
  ```
  #import <UIKit/UIKit.h>
  @class DestinationViewController;
  @protocol DestinationViewControllerDelegate <NSObject>
  -(void) destinationViewController:(DestinationViewController *) destinationViewController
               return2SrcVCWithData:(NSString *) string;
  @end
  
  @interface DestinationViewController : UIViewController
  @property (nonatomic,weak) id <DestinationViewControllerDelegate> delegate;
  @property (nonatomic,copy) NSString *dataText;
  @end
  ```
  - 在目标控制器中，需要执行popViewController:方法之前，通知代理对象调用代理协议中定义的方法。
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      if([self.delegate respondsToSelector:@selector(destinationViewController:return2SrcVCWithData:)]){
          [self.delegate destinationViewController:self return2SrcVCWithData:@"九九学院"];
      }
      [self.navigationController popViewControllerAnimated:YES];
  }
  ```
  - 设置SourceViewController.m类遵守DestinationViewControllerDelegate代理协议
  ```
  @interface SourceViewController ()<DestinationViewControllerDelegate>
  ```
  - 设置目标控制器的代理对象。在SourceViewController.m中，在实例化目标控制器后，设置其代理对象为源控制器
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      DestinationViewController *descVC = [[DestinationViewController alloc]init];
      descVC.view.backgroundColor = [UIColor redColor];
      descVC.navigationItem.title = @"目标控制器";
      descVC.dataText = @"99iOS.com";
      descVC.delegate = self;
      [self.navigationController pushViewController:descVC animated:YES];
  }
  ```
  - 在SourceViewController.m中，在代理方法中实现具体功能。
  ```
  -(void)destinationViewController:(DestinationViewController *)destinationViewController return2SrcVCWithData:(NSString *)string{
      NSLog(@"目标控制器回传的字符串数据:%@",string);
  }
  ```
  #### 9.2.14 使用通知逆传数据
  与代理相比，通知的优点在于可以支持一对多的进行数据传递。使用通知进行数据逆向传递。
  - 在源控制器SourceViewController.m中，注册观察者
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      // Do any additional setup after loading the view.
      [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveMessage:) name:@"destinationVCReturn" object:nil];
  }
  ```
  - 在源控制器SourceViewController.m中，实现收到通知后的操作，即实现receiveMessage方法。从目标控制器中传递的通知中，携带了传递过来的数据对象。
  ```
  -(void)receiveMessage:(NSNotification *)notification{
      NSString *string = (NSString *)notification.object;
      NSLog(@"目标控制器回传的字符串数据(使用通知):%@",string);
  }
  ```
  - 在生命周期最后一步结束通知订阅
  ```
  -(void)receiveMessage:(NSNotification *)notification{
      NSString *string = (NSString *)notification.object;
      NSLog(@"目标控制器回传的字符串数据(使用通知):%@",string);
  }
  ```
  - 在目标控制器DestinationViewController.m中，在目标控制器出栈前调用popViewControllerAnimated方法前，推送通知给各个观察值，在推送的通知中传递需要交互的数据对象。
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      [[NSNotificationCenter defaultCenter]postNotificationName:@"destinationVCReturn" object:@"九九学院"];
      [self.navigationController popViewControllerAnimated:YES];
  }
  ```
  #### 9.2.15 使用Block逆传数据
  - 在目标控制器DestinationViewController.h中，添加Block属性
  ```
  @interface DestinationViewController : UIViewController
  @property (nonatomic,weak) id <DestinationViewControllerDelegate> delegate;
  @property (copy) PassDataBlock block;
  @end
  ```
  - 在目标控制器DestinationViewController.m中，设置Block中代码的执行时机，即在返回上一个控制器之前调用。
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      if(self.block){
          self.block(@"九九学院");
      }
      [self.navigationController popViewControllerAnimated:YES];  
  }
  ```
  - 在源控制器SourceViewController.m中，给目标控制器对象的Block赋值，即调用Block时需要执行的操作。
  ```
  -(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
      DestinationViewController *descVC = [[DestinationViewController alloc]init];
      descVC.view.backgroundColor = [UIColor redColor];
      descVC.navigationItem.title = @"目标控制器";
      descVC.dataText = @"99iOS.com";
      descVC.delegate = self;
      
      descVC.block = ^(NSString *string){
          NSLog(@"目标控制器回传的字符串数据(使用Block):%@",string);
      };
      
      [self.navigationController pushViewController:descVC animated:YES];
  }
  ```
  #### 9.2.16 工具栏toolBar
  导航器控制器中，除了在顶部具有一个navigationBar之外，在底部还有一个toolBar,在默认情况下，toolBar是被隐藏起来的。
  1. toolBar简介
  toolBar可以理解为显示在屏幕底部的navigationBar,它具有同NavigationBar一样的特性，上面的按钮都是UIBarButtonItem类的对象。
  ![07483430.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\07483430.png)
  
  ### 9.3 UITabBarController
  #### 9.3.1 UITabBarController的常用属性和方法
  UITabBarController类用来实现底部的功能菜单以及切换。
  一个UITabBarController管理着4~5个UINavigationController,然后每个UINavigationController又管理着一组UIViewController对象或者子类对象。
  
  2. UITabBarController常用属性
  在UITabBarController类中，有两个核心属性，分别为ViewControllers和tabBar,其分别管理UITabBarController的子控制器以及底部菜单栏的样式。
  - viewController用于存储UITabBarController所需要管理的子控制器，通常这些子控制器时UINavigationController类的对象。
  ```
  @property(nonatomic, copy) NSArray<__kindof UIViewController *> *viewControllers;
  ```
  - tabBar用于定制tabBar的整体外观样式，例如，背景颜色，背景图片等，需要注意的是:tabBar上每个按钮的样式定制并不由tabBar决定。这个与导航栏navigationBar是类似的。
  ```
  @property(nonatomic, readonly) UITabBar *tabBar;
  ```
  - selectedViewController设置被选中的子控制器，被选中的子控制器会显示被选中的状态。
  ```
  @property(readonly, strong) NSViewController *selectedViewController;
  ```
  - selectedIndex 根据序号设置被选中的子控制器
  ```
  @property NSInteger selectedIndex;
  ```
  3. UIViewController类中的tabBarItem与tabBarController
  与UINavigationController类似，UITabBarController类中也对UIViewController类的属性进行了扩展，增加了tabButton这个关键属性，因此每个子控制器的UITabBarItem样式，其实是在子控制器对象中进行设置的。这样保证了定制的灵活性。另外，tabBarController属性使每个子控制器都可以获取到管理它的UITabBarController对象。
  
  #### 9.3.2 UITabBar的常用属性和方法
  UITabBar类对象tabBar是UITabBarController中的一个属性，其负责定义底部功能栏的整体外观样式，但每个菜单按钮的样式并不是由UITabBar类对象控制的。
  而是有各个子控制器中的tabBarItem属性决定的。UITabBar类中定义了如下一些常用的属性和方法。
  - tintColor tabBar整体渲染的颜色
  - barTintColor tabBar的整体背景颜色
  ```
  @property(nonatomic, strong) UIColor *barTintColor;
  ```
  - backgroundImage 为tabBar设置背景图片
  ```
  @property(nonatomic, strong) UIImage *backgroundImage;
  ```
  - barStyle tabBar的整体风格样式，默认为白色，可以改为黑色
  ```
  @property(nonatomic) UIBarStyle barStyle;
  ```
  - items,获取tabBar上面的所有UITabBarItem类的对象，即底部菜单栏上面的按钮，可以对其样式进行修改.
  ```
  @property(nullable,nonatomic,copy)NSArray<UITabBarItem *> *items;
  ```
  #### 9.3.3 UITabBarItem的常用属性和方法
  UITabBarItem是用于定义底部tabBar上每个按钮样式的类，UITabBarItem对象的设置是在各个子控制器中设置的。
  1. UITabBarItem简介
  在TabBar上每个按钮都是UITabBarItem类的对象，虽然其看上去是按钮，但UITabBarItem类并不是UIView的子类，而是NSObject的子类。
  ```
  @interface UITabBarItem:UIBarItem
  @interface UIBarItem:NSObject<NSCoding,UIAppearance>
  ```
  2. UITabBarItem的常用属性和方法
  - UITabBarItem类的实例化方法，该方法需要传递3个参数，分别为每个UITabBarItem的底部文字描述，中间的图片以及选中后显示的图片。需要注意的是，选中状态下文字的颜色需要设置tabBar的tintColor属性。
  ```
  - (instancetype)initWithTitle:(NSString *)title image:(UIImage *)image selectedImage:(UIImage *)selectedImage;
  ```
  - badgeValue 每个UITabBarItem对象右上角的提示信息
  ```
  @property(nonatomic, assign) NSUInteger badgeValue;
  ```
  - badgeColor iOS10中新加入的属性，可以定制badge的颜色，默认为红色，也可以修改为其他颜色。
  ```
  @property(nonatomic, readwrite, copy) UIColor *badgeColor;
  ```
  #### 9.3.4 微信TabBar实现
  对于TabBar来说，通常是在App开发的最初阶段就开发完成的。相当于App的框架，后期只需要去定制其中各个子控制器类的功能即可。
  1. 微信TabBar实现思路
  微信的整体框架包括4个功能模块:微信、通讯录、发现和我，每个功能模块都是对应一个UINavigationController对象，这4个UINavigationController对象装进一个UITabBarController中进行统一管理。
  - 创建子控制器：分别创建各个功能模块对应的UINavigationController对象，并设置其tabBarItem属性。
  - 创建UITabBarController对象，把4个UINavigationController对象装进viewControllers属性中。
  - 定制TabBar的外观
  - 其他属性的设置以及功能实现
  2. 示例代码
  - 创建子控制器，并设置其tabBarItem的属性
  ```
      UIViewController *homeVC = [[UIViewController alloc]init];
      homeVC.title = @"微信";
      UINavigationController *homeNaviVC = [[UINavigationController alloc]initWithRootViewController:homeVC];
      UITabBarItem *item0 = [[UITabBarItem alloc] initWithTitle:homeVC.title image:[UIImage imageNamed:@"tabbar_mainframe"] selectedImage:[UIImage imageNamed:@"tabbar_mainframeHL"]];
      homeNaviVC.tabBarItem = item0;
      
      UIViewController *contactVC = [[UIViewController alloc]init];
      contactVC.title = @"通讯录";
      UINavigationController *contactNaviVC = [[UINavigationController alloc]initWithRootViewController:contactVC];
      UITabBarItem *item1 = [[UITabBarItem alloc] initWithTitle:contactVC.title image:[UIImage imageNamed:@"tabbar_contacts"] selectedImage:[UIImage imageNamed:@"tabbar_contactsHL"]];
      contactNaviVC.tabBarItem = item1;
      
      UIViewController *discoverVC = [[UIViewController alloc]init];
      discoverVC.title =@"发现";
      UINavigationController *discoverNaviVC = [[UINavigationController alloc]initWithRootViewController:discoverVC];
      UITabBarItem *item2 = [[UITabBarItem alloc]initWithTitle:discoverVC.title image:[UIImage imageNamed:@"tabbar_discover"] selectedImage:[UIImage imageNamed:@"tabbar_discoverHL"]];
      discoverNaviVC.tabBarItem = item2;
      
      UIViewController *myVC = [[UIViewController alloc]init];
      myVC.title = @"我";
      UINavigationController *myNaviVC = [[UINavigationController alloc]initWithRootViewController:myVC];
      UITabBarItem *item3 = [[UITabBarItem alloc]initWithTitle:myVC.title image:[UIImage imageNamed:@"tabbar_me"] selectedImage:[UIImage imageNamed:@"tabbar_meHL"]];
      myNaviVC.tabBarItem = item3;
  ```
  - 创建UITabBarController对象，把4个UINavigationController对象存入ViewControllers属性中
  ```
  UITabBarController *tabBarVC = [[UITabBarController alloc]init];
  tabBarVC.viewControllers = @[homeNaviVC,contactNaviVC,discoverNaviVC,myNaviVC];
  tabBarVC.selectedViewController = homeNaviVC;
  ```
  - 定制tabBar外观
  ```
  tabBarVC.tabBar.backgroundImage = [UIImage imageNamed:@"tabbarBkg"];
  tabBarVC.tabBar.tintColor = [UIColor colorWithRed:31/255.0 green:185/255.0 blue:34/255.0 alpha:1.0];
  ```
  - 定制每个tabBarItem的外观,由于tabBar的tintColor属性在起作用，通常点击tabBarItem时，显示原始素材的样式，因此，需要设置图片的渲染模式为UIImageRenderingModelAlwaysOriginal.
  ```
      for(UITabBarItem *item in tabBarVC.tabBar.items){
          UIImage *image = item.selectedImage;
          UIImage *correctImage = [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];
          item.selectedImage = correctImage;
      }
  ```
  - 设置启动时加载UITabBarController对象
  ```
      self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
      self.window.rootViewController = tabBarVC;
      [self.window makeKeyAndVisible];
  ```
  
  #### 9.3.5 UITabBarController的代理协议
  UITabBarController类中也定义了其代理协议UITabBarControllerDelegate,可以监测有关UITabBarController的用户交互行为，并调用不同的方法。
  例如在切换不同的子控制器时，可以在代理方法中发送网络请求，来更新控制器的界面数据。UITabBarControllerDelegate的代理协议中的以下几个方法在实际开发中比较常用。
  - 当切换子控制器时调用。可以用于切换控制器时准备界面数据。
  ```
  - (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController;
  ```
  - 设置子控制器能否被选中
  ```
  - (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController;
  ```
  ### 9.4 UIWindow、UIView与UIViewController 关系
  #### 9.4.1 概念简介
  1. UIWindow(窗口)
  UIWindow是一个特殊的UIView,UIWindow类继承自UIView,一个App只有一个UIWindow,但特定情况下也会出现多个UIWindow.ios启动完毕后，创建的第一个视图控件就是UIWindow，此时需要给UIWindow对象指定根控制器，
  即设置rootViewController属性，系统会自动把rootViewController的view添加到window上，从而在屏幕上就可以显示出程序启动后的初始界面。rootVeiwController是应用程序的根控制器，只要App未被销毁，则rootViewController就不会被销毁。
  
  2. UIView(视图)
  每个UIView都负责在屏幕上一个特定矩形区域的显示，可以通过设置backgroundColor属性来查看该矩形区域的范围。每个UIView对象除了要负责渲染矩形区域的内容之外，还要响应该区域中发生的交互事件，因为UIView继承自UIResponder类，并且每个UIView对象中都可以添加一个或多个子UIView
  队形。UIView对象只有显示在UIWindow上，用户才能看到界面的样式。通过UIView类的window属性，可以获得该UIView对象所在的UIWindow对象。
  
  3. UIViewController(视图控制器)
  每个UIViewController都有一个view属性，用于显示该控制器的外观样式，UIViewController类负责管理在View上显示的数据，并协调它们和应用程序其他部分的关系。UIViewController类负责创建其管理的视图，并且在内存不足时，将它们从内容移出。
  可以再didReceiveMemoryWarning方法中实现。除此之外，视图控制器还为某些标准的系统行为提供自动响应。例如，在设备方法变化时，如果应用程序支持该方向，视图控制器可以对其管理的视图进行尺寸调整，使其适应新的方向。
  
  #### 9.4.2 关系描述
  以使用浏览器浏览网页为例，UIWindow相当于显示器屏幕，UIView相当于不同的网页，UIViewController相当于控制网页切换的用户。
  
  ## 第十章 其它UI控件
  ### 10.1 WKWebView
  ### 10.2 UITextView
  ### 10.3 UIPageControl
  ### 10.4 UIPickerView
  ### 10.5 UISilder
  ### 10.6 UIDataPicker
  ### 10.7 UISegmentedControl
  
  # 第三部分 iOS开发进阶
  ## 第十一章 多线程
  ### 11.1 线程基础知识
  1. 线程与进程
  - 对于任意一个iOS应用，程序运行起来后，默认会产生一个主线程(MainThread)。主线程专门用来处理UIKit对象的操作，如界面的显示与更新、处理用户交互事件等。
  - 对于耗时的操作，需要再另外创建一个线程，放到后台处理，当处理完成得到结果后，再返回主线程去设置UI界面，这就涉及线程间通信的相关知识。
  - 多线程同时处理任务，还会涉及线程安全的问题，当多个线程对一个对象进行同时操作时，就会影响结果的正确性。因此，线程对某个对象操作时，需要使用到锁的机制，即当一个线程操作一个对象的过程中，会给这个对象上锁，其他线程就不能够访问该对象了。枷锁虽然解决了线程安全的问题，但带来的另外一个弊端就是影响了程序运行的效率。
  - 当给一个自定义类中添加属性时，属性关键字其中就有atomic和nonatomic的区分，其中atomic是线程安全的，当有线程访问这个属性时，会为该属性的setter方法加锁，atomic是默认值。但是在实际的开发中，都会把属性设置nonatomic关键字。
  2. NSThread类
  NSThread类是苹果官方提供的管理线程的类，提供了一些线程管理的方法。但是随着GCD和NSOperation的推出，NSThread的使用场景已经大大减少。
  - 获取当前线程对象
  ```
  +(NSThread *)currentThread;
  ```
  - 获取主线程对象
  ```
  +(NSThread *)mainThread;
  ```
  - 使主线程休眠ti秒
  ```
  +(void)sleepForTimeInterval:(NSTimeInterval)ti;
  ```
  3. 示例代码
  - 实现获取字符串的方法，在每个方法中都会阻塞主线程3秒
  ```
  -(NSString *) generateString1{
      [NSThread sleepForTimeInterval:3.0];
      NSString *string = @"hello world!";
      return string;
  }
  
  -(NSString *) generateString2{
      [NSThread sleepForTimeInterval:3.0];
      NSString *string =@"www.99iOS.com";
      return string;
  }
  
  -(NSString *) generateString3 {
      [NSThread sleepForTimeInterval:3.0];
      NSString *string = @"2017";
      return string;
  }
  ```
  - 实现显示内容按钮的点击操作
  ```
  - (IBAction)showContent:(id)sender {
      //记录开始时间
      NSLog(@"\\n Start Time:%@, \\n Current Thread: %@, \\n Main Thread: %@", [NSDate date], [NSThread currentThread], [NSThread mainThread]);
      self.label1.text = [self generateString1];
      self.label2.text = [self generateString2];
      self.label3.text = [self generateString3];
      //记录结束时间
      NSLog(@"\\n End Time:%@, \\n Current Thread: %@, \\n Main Thread: %@", [NSDate date], [NSThread currentThread], [NSThread mainThread]);
  }
  ```
  ### 11.2 GCD
  #### 11.2.1 GCD 基本概念介绍
  相比于NSThread,GCD中已经完全屏蔽了有关线程的概念，而是引入了任务和队列，把任务放到队列中执行，指定任务和队列的类型。其他有关线程管理的事务完全交由GCD来处理。大大简化了多任务开发的难度。
  
  1. GCD简介
  由于GCD对线程管理进行了封装，因此，当使用GCD时，只需要把任务添加到一个队列中执行，有关线程调度的工作完全交由GCD完成。
   - 在Block中定义需要执行的任务内容。
   - 把任务添加到队列queue中。
  GCD对队列中的任务，按照先进先出的原则，根据任务添加到队列的顺序来对队列进行处理，GCD会根据任务和队列的类型，自动在多个线程之间分配工作。
  
  2. 任务
  在GCD中，需要处理的事务统一使用Block封装起来，称为任务。任务有两种类型，同步任务和异步任务。通过调用不同的函数，来设置任务的类型。同时，任务编写在函数的Block参数中。
  - 异步任务:执行任务时，会在另外的线程中执行，即可能会创建新的线程。
  ```
  void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);
  ```
  - 同步任务:执行任务时，会在当前的线程中执行，当前线程有可能是主线程，也有可能是子线程。
  ```
  void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);
  ```
  3. 队列
  GCD中，队列是一个重要概念。系统提供了若干预定义的队列，其中包括可以获取应用程序的主队列。另外，工程师可以自由创建不同类型的队列。例如:并行队列和串行队列，队列的类型决定了任务的执行方式。GCD队列严格按照先进先出的原则，添加到GCD队列中的任务，始终会按照加入队列的顺序被执行。
  - 并行队列: 并行队列中的任务可以在多线程之间分配执行，分配的原则由GCD控制，因此，并行队列的任务，虽然执行时按照先进先出进行分配的，但由于各个任务被分配到不同的线程执行，因此其完成时间有可能不同。
  ```
  dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags);
  ```
  - 串行队列: 串行队列中的任务时按照顺序一个一个完成的，当一个任务完成后，才去执行下一个任务，因此，串行队列对应一个线程执行。
  ```
  dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);
  ```
  - 主队列: 主队列也是一个串行队列，主队列中的任务都在主线程中执行。
  ```
  dispatch_queue_main_t dispatch_get_main_queue(void);
  ```
  #### 11.2.2 队列与任务组合
  在GCD中存在队列和任务两个核心概念，同时队列又分为并行队列、串行队列和主队列，任务包括异步任务和同步任务。GCD的使用方法就是把任务放到队列中执行，因为根据不同的任务类型和队列类型，就会存在6种组合。
  1. 异步任务+并行队列
  ```
  //获取并行队列
      dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
      //创建异步任务，并放到并行队列中执行
      dispatch_async(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task1:%d",i);
          }
          NSLog(@"task1----%@",[NSThread currentThread]);
      });
      dispatch_async(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task2:%d",i);
          }
          NSLog(@"task2----%@",[NSThread currentThread]);
      });
      dispatch_async(queue, ^{
          for(int i = 0;i<2;i++){
              NSLog(@"task3:%d",i);
          }
          NSLog(@"task3---%@",[NSThread currentThread]);
      });
  ```
  异步任务+并行队列组合情况下，每个任务会在不同的线程中同时执行。
  2. 异步任务+串行队列
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //创建串行队列
      dispatch_queue_t queue = dispatch_queue_create("com.99ios", NULL);
      //创建异步任务
      dispatch_async(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task1:%d",i);
          }
          NSLog(@"task1----%@",[NSThread currentThread]);
      });
      dispatch_async(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task2:%d",i);
          }
          NSLog(@"task2----%@",[NSThread currentThread]);
      });
      dispatch_async(queue, ^{
          for(int i = 0;i<2;i++){
              NSLog(@"task3:%d",i);
          }
          NSLog(@"task3---%@",[NSThread currentThread]);
      });
  }
  ```
  所有任务都在一个线程中执行，并且完成一个后，再执行一个。
  3. 异步任务+主队列
  把异步任务放在主队列中执行，由于主队列是一个特殊的串行队列，因此任务时串行执行的，但由于主队列对应序号为1的线程，因此，即便是异步任务，也不会再创建新的线程。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //获取主队列
      dispatch_queue_t mainQueue = dispatch_get_main_queue();
      //创建异步任务
      dispatch_async(mainQueue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task1:%d",i);
          }
          NSLog(@"task1----%@",[NSThread currentThread]);
      });
      dispatch_async(mainQueue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task2:%d",i);
          }
          NSLog(@"task2----%@",[NSThread currentThread]);
      });
      dispatch_async(mainQueue, ^{
          for(int i = 0;i<2;i++){
              NSLog(@"task3:%d",i);
          }
          NSLog(@"task3---%@",[NSThread currentThread]);
      });
  }
  ```
  4. 同步任务+并行队列
  同步任务的执行是在当前线程中完成的，因此，即便是把同步任务放在并行队列中执行，由于只有1个线程，任务也是一个一个按顺序执行。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //获取并行队列
      dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
      //同步执行
      dispatch_sync(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task1:%d",i);
          }
          NSLog(@"task1----%@",[NSThread currentThread]);
      });
      dispatch_sync(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task2:%d",i);
          }
          NSLog(@"task2----%@",[NSThread currentThread]);
      });
      dispatch_sync(queue, ^{
          for(int i = 0;i<2;i++){
              NSLog(@"task3:%d",i);
          }
          NSLog(@"task3---%@",[NSThread currentThread]);
      });
  }
  ```
  5. 同步任务+串行队列
  同步任务放在串行队列中执行，任务会在当前线程依次执行。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //获取串行队列
      dispatch_queue_t queue = dispatch_queue_create("com.99ios", NULL);
      //同步执行
      dispatch_sync(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task1:%d",i);
          }
          NSLog(@"task1----%@",[NSThread currentThread]);
      });
      dispatch_sync(queue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task2:%d",i);
          }
          NSLog(@"task2----%@",[NSThread currentThread]);
      });
      dispatch_sync(queue, ^{
          for(int i = 0;i<2;i++){
              NSLog(@"task3:%d",i);
          }
          NSLog(@"task3---%@",[NSThread currentThread]);
      });
  }
  ```
  6. 同步任务+主队列
  这种情况下，主线程会被阻塞，程序会挂死，不能使用
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //获取主队列
      dispatch_queue_t mainQueue = dispatch_get_main_queue();
      //同步执行
      //1
      dispatch_sync(mainQueue, ^{ //block1
          for(int i = 0 ;i<2;i++){
              NSLog(@"task1:%d",i);
          }
          NSLog(@"task1----%@",[NSThread currentThread]);
      });
      //2
      dispatch_sync(mainQueue, ^{
          for(int i = 0 ;i<2;i++){
              NSLog(@"task2:%d",i);
          }
          NSLog(@"task2----%@",[NSThread currentThread]);
      });
      //3
      dispatch_sync(mainQueue, ^{
          for(int i = 0;i<2;i++){
              NSLog(@"task3:%d",i);
          }
          NSLog(@"task3---%@",[NSThread currentThread]);
      });
  }
  ```
  当调用dispatch_sync会阻塞线程。执行完1之后主线程需要执行2,3,此时Block1等在2,3的代码执行完成，而代码1需要等待Block1执行完成。这就造成了1和Block1相互等待，成了死锁。
  #### 11.2.3 线程间通信
  由于UI的更新和操作是由主线程负责的，因此，当使用子线程获取到数据时，需要返回主线程对UI界面进行更新，这时就涉及线程间的通信。
  1. 在涉及网络数据获取的过程中，一般会使用异步任务+并发队列进行数据获取。当获取到网络服务器返回的数据后，需要在主线程中把数据显示在屏幕上，因此这就涉及线程间的通信。在并列队列中的任务还可以嵌套子任务，嵌套的子任务可以设置为在主线程中执行的任务。
  
  2. 示例代码
  ```
  - (IBAction)downLoadImageView:(id)sender {
      //获取并行队列
      dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
      
      NSLog(@"0---%@", [NSThread currentThread]);
      
      //异步任务
      dispatch_async(queue, ^{
          //从网络下载图片
          NSString *urlString = @"http://7xta2c.com1.z0.glb.clouddn.com/99logo.png";
          NSURL *url = [NSURL URLWithString:urlString];
          NSData *imageData = [NSData dataWithContentsOfURL:url];
          UIImage *image = [UIImage imageWithData:imageData];
          NSLog(@"1---%@", [NSThread currentThread]);
          
          //返回主线程设置UI
          dispatch_async(dispatch_get_main_queue(), ^{
              self.imageView.image = image;
              NSLog(@"2---%@", [NSThread currentThread]);
          });
          
      });
      
      NSLog(@"3---%@", [NSThread currentThread]);
  }
  ```
  #### 11.2.4 队列组dispatch group
  在使用GCD进行任务操作时，有时会希望若干个任务执行之间有先后执行的依赖关系，例如，当A,B两个异步任务完成后，再去完成C任务，这时就可以使用队列组dispatch group 来完成。
  1. 队列组基本介绍
  在串行队列中，任务是按照进入队列的顺序依次执行，因此任务和任务之间有明确的先后顺序的。但是对于并行队列的任务来说，由于任务会被自动分配到不同的线程中执行，因此任务完成的顺序是不确定的。假如希望给并行队列中的任务设置执行顺序。
  例如，当任务A和任务B完成后，再去完成任务C，就需要使用到任务组dispatch group.
  
  - 创建队列组
  ```
  dispatch_group_t dispatch_group_create(void);
  ```
  - 向队列组中插入一个异步任务
  ```
  void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
  ```
  - 队列组中其他任务执行完成后，执行的任务，通常可以用来设置UI界面
  ```
  void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);
  ```
  #### 11.2.5 延迟执行操作
  
  1. 使用GCD实现延迟执行
  在GCD中可以使用dispatch_after()函数，封装一段代码到Block中，在设置的延迟时间dispatch_time_t之后执行。
  ```
  void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);
  ```
  如下所示:在2.0秒后，输出一段日志。在该方法中，延迟执行的代码在主队列中执行，也可以修改执行的队列。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
          NSLog(@"延迟2.0秒后打印出来的日志");
      });
  }
  ```
  2. 使用NSRunLoop类中的方法实现延迟执行
  在NSRunLoop类中，也提供了有关延迟执行的方法。
  ```
  - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray<NSRunLoopMode> *)modes;
  - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;
  ```
  下面的代码中也实现了延迟2.0秒打印一段日志的操作
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      [self performSelector:@selector(printInfo) withObject:nil afterDelay:2.0];
  }
  
  -(void)printLog{
      NSLog(@"延迟2.0秒后打印出来的日志！");
  }
  ```
  ### 11.3 NSOperation
  
  #### 11.3.1 NSOperation 基本使用
  NSOperation在iOS 4后也基于GCD实现，但是相对于GCD来说可控性更强，并且可以加入操作依赖。
  1. NSOperation的类族
  NSOperation是一个抽象类，不能够直接使用NSOperation,因此系统提供了NSBlockOperation和NSInvocationOperation两个子类，还可以使用自定义CustomOperation类。
  对于NSBlockOperation类来讲，可以把任务封装在一个Block块之内。NSBlockOperation类提供了如下操作方法，用于创建一个NSBlockOperation对象，任务封装在Block中。
  ```
  + (instancetype)blockOperationWithBlock:(void (^)(void))block;
  ```
  对于NSInvocationOperation类来说，需要执行的任务直接指定已定义的方法。
  ```
  (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;
  ```
  2. 无队列情况下执行任务
  在不创建队列的情况下，可以直接调用NSOperation类的start方法来执行某个任务。该任务是在当前线程进行执行的。如果是在主线程调用的start方法，那么则会在主线程中执行任务。
  ```
  -(void)executeInCurrentThread{
      NSBlockOperation *task1 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task-----%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task2 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task2-----%@",[NSThread currentThread]);
      }];
      [task1 start];
      [task2 start];
  }
  ```
  3. 在队列中执行任务
  当把任务放到队列中进行执行时，系统会自动并行执行所有任务，对于开多少条线程之类的事务，完全交由系统处理，开发者只要把任务添加到队列中即可。另外，可以通过设置队列的maxConcurrentOperationCount属性，来设置并行执行任务的数量。
  ```
  -(void)executeInQueue{
      NSBlockOperation *task1 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task1------%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task2 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task2 ------%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task3 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task3 ------%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task4 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task4 ------%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task5 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task5 ------%@",[NSThread currentThread]);
      }];
      
      NSOperationQueue *queue = [[NSOperationQueue alloc]init];
      queue.maxConcurrentOperationCount = 5;
      [queue addOperation:task1];
      [queue addOperation:task2];
      [queue addOperation:task3];
      [queue addOperation:task4];
      [queue addOperation:task5];
  }
  ```
  4. 在任务中添加新任务
  通过调用NSOperation类的addExecutionBlock方法，可以为某个NSOperation对象增加额外的任务。当把这些新增的任务放到队列中执行时，也是并行执行的。
  ```
  - (void)addExecutionBlock:(void (^)(void))block;
  ```
  下面的示例代码中在任务中添加新任务，所有的任务都会并行执行。
  ```
  -(void)addTaskInOperation{
      NSBlockOperation *task1 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task1 -----%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task2 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task2 -----%@",[NSThread currentThread]);
      }];
      [task1 addExecutionBlock:^{
          NSLog(@"task1 add task------ %@",[NSThread currentThread]);
      }];
      [task2 addExecutionBlock:^{
          NSLog(@"task2 add task-----%@",[NSThread currentThread]);
      }];
      NSOperationQueue *queue = [[NSOperationQueue alloc]init];
      [queue addOperation:task1];
      [queue addOperation:task2];
  }
  ```
  5. 在队列中直接添加任务
  通过调用NSOperationQueue的addOperationWithBlock方法，可以向队列中直接添加任务Block。
  ```
  -(void)addTaskInQueue{
      NSBlockOperation *task1 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task1 -----%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task2 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task2 -----%@",[NSThread currentThread]);
      }];
      [task1 addExecutionBlock:^{
          NSLog(@"task1 add task------ %@",[NSThread currentThread]);
      }];
      [task2 addExecutionBlock:^{
          NSLog(@"task2 add task-----%@",[NSThread currentThread]);
      }];
      NSOperationQueue *queue = [[NSOperationQueue alloc]init];
      [queue addOperation:task1];
      [queue addOperation:task2];
      [queue addOperationWithBlock:^{
          NSLog(@"queue task-----%@",[NSThread currentThread]);
      }];
  }
  ```
  6. 在任务中创建completionBlock
  在NSOperation类中，可以通过设置completionBlock来创建所有任务执行完成后，自动调用一个Block,该Block的执行时在任务执行后被调用的，有先后顺序。
  ```
  -(void)addCompletionBlock {
      NSBlockOperation *task1 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task1 -----%@",[NSThread currentThread]);
      }];
      NSBlockOperation *task2 = [NSBlockOperation blockOperationWithBlock:^{
          NSLog(@"task2 -----%@",[NSThread currentThread]);
      }];
      [task1 addExecutionBlock:^{
          NSLog(@"task1 add task------ %@",[NSThread currentThread]);
      }];
      task1.completionBlock = ^{
          NSLog(@"task1 end!!!%@",[NSThread currentThread]);
      };
      
      [task2 addExecutionBlock:^{
          NSLog(@"task2 add task-----%@",[NSThread currentThread]);
      }];
      task2.completionBlock = ^{
          NSLog(@"task2 end!!!%@",[NSThread currentThread]);
      };
      
      NSOperationQueue *queue = [[NSOperationQueue alloc]init];
      [queue addOperation:task1];
      [queue addOperation:task2];
  }
  ```
  7. NSOperation与GCD的区别
  - GCD的底层是C语言构成，而NSOperation及相关对象是Objective-C的对象。
  - KVO可以应用到NSOperation中，可以监听一个Operation是否完成或取消，比GCD更有效地掌控执行的后台任务。
  
  #### 11.3.2 线程间通信
  与GCD相同，对于放在后台线程执行的任务执行完成后，通常是通过网络获取数据后返回主线程进行界面UI的更新。在NSOperationQueue类中，也可以获取主线程队列，相关更新UI的任务必须放在主队列中完成。
  ```
  - (IBAction)downloadImage:(id)sender {
      //创建任务
      NSBlockOperation *downloadTask = [NSBlockOperation blockOperationWithBlock:^{
          //下载网络图片
          NSString *urlStr = @"http://7xta2c.com1.z0.glb.clouddn.com/99logo.png";
          NSURL *url = [NSURL URLWithString:urlStr];
          NSData *imageData = [NSData dataWithContentsOfURL:url];
          UIImage *image = [UIImage imageWithData:imageData];
          //返回主线程设置UI
          NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
          [mainQueue addOperationWithBlock:^{
              self.imageView.image = image;
          }];
      }];
      //创建队列
      NSOperationQueue *queue = [[NSOperationQueue alloc] init];
      [queue addOperation:downloadTask];
  }
  ```
  #### 11.3.3 任务间的执行依赖
  在GCD中可以使用队列组来设置任务之间的依赖关系，而在NSOperation中则提供了更加方便直观的方式来设置任务执行的先后顺序关系。通过NSOperation类中的addDependency方法，即可添加任务之间的依赖关系。
  由于addDependency是NSOperation类中的方法，与队列无关，因此也可以针对不同队列中的任务设置任务执行的先后依赖关系。
  ```
  - (IBAction)downloadTwoImage:(id)sender {
      //创建两个任务，两个任务完成后，返回主线程执行第三个更新Label的任务
      NSBlockOperation *task1 = [NSBlockOperation blockOperationWithBlock:^{
          //下载网络图片
          NSString *urlStr = @"http://7xta2c.com1.z0.glb.clouddn.com/99logo.png";
          NSURL *url = [NSURL URLWithString:urlStr];
          NSData *imageData = [NSData dataWithContentsOfURL:url];
          UIImage *image1 = [UIImage imageWithData:imageData];
          NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
          [mainQueue addOperationWithBlock:^{
              self.imageView1.image = image1;
          }];
      }];
      NSBlockOperation *task2 = [NSBlockOperation blockOperationWithBlock:^{
          //下载网络图片
          NSString *urlStr = @"http://7xta2c.com1.z0.glb.clouddn.com/99logo.png";
          NSURL *url = [NSURL URLWithString:urlStr];
          NSData *imageData = [NSData dataWithContentsOfURL:url];
          UIImage *image2 = [UIImage imageWithData:imageData];
          NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
          [mainQueue addOperationWithBlock:^{
              self.imageView2.image = image2;
          }];
      }];
      NSBlockOperation *task3 = [NSBlockOperation blockOperationWithBlock:^{
          NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];
          [mainQueue addOperationWithBlock:^{
              self.label.text = @"下载完成";
          }];
      }];
      //设置任务之间的执行依赖关系
      [task3 addDependency:task1];
      [task3 addDependency:task2];
      [task2 addDependency:task1];
      NSOperationQueue *queue = [[NSOperationQueue alloc] init];
      [queue addOperation:task1];
      [queue addOperation:task2];
      [queue addOperation:task3];
  }
  ```
  
  ## 第十二章 网络
  
  ## 第十三章 数据持久化
  ### 13.1 沙盒
  #### 13.1.1 沙盒基础
  1. 什么是沙盒
  iOS中的沙盒机制是一种安全体系，它规定了应用程序只能再本应用的文件夹内读取文件，不可以访问其他区域的内容，此区域被称为沙盒。所有的非代码文件都保存在这个地方，比如图片、声音、属性列表和文本文件等。
  - 每个应用程序都有属于本应用的沙盒存储空间。
  - 应用程序不能随意跨越自己的沙盒去访问其他的应用程序沙盒的内容。
  - 应用程序向外读写数据都需要经过权限认证。
  正是因为沙河机制的存在，iOS以及MacOS的软件安全性要比Android以及Windows应用的安全性高。
  
  2. 沙盒目录介绍
  默认情况下，每个应用的沙盒包含3个文件夹:Documents、Library和tmp。由于沙盒机制的存在，应用只能在这几个目录中读写文件。使用iTunes与iphone同步时，会备份所有的Documents和Library文件。iPhone在重新时，会丢弃所有的tmp文件。
  - Documents: 苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录。
  - Library: 存储程序的默认设置或其他状态信息，其中又包含了Caches文件夹和Preferences文件夹。
  - Library/Caches: 存放缓存文件，iTunes不会备份此目录，但此目录下文件在应用退出时不会被删除。
  - Library/Preferences: 存放偏好设置的plist文件。
  - tmp: 提供一个即时创建临时文件的地方。
  
  3. 获取沙盒中文件夹的路径
  - App沙盒的路径.
  ```
  NSString *homePath = NSHomeDirectory();
  ```
  - 获取沙盒中Documents文件夹目录
  ```
      NSArray *documentsArr = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
      NSString *documentsPath = [documentsArr objectAtIndex:0];
      NSLog(@"%@",documentsPath);
  ```
  - 获取Library文件夹目录
  ```
      NSArray *libraryArr = NSSearchPath
  ```
  - 获取Library文件夹目录
  ```
      NSArray *libraryArr = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
      NSString *libraryPath = [libraryArr objectAtIndex:0];
      NSLog(@"%@",libraryPath);
  ```
  - 获取Caches文件夹目录
  ```
      NSArray *cachesArr = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
      NSString *cachesPath = [cachesArr objectAtIndex:0];
      NSLog(@"%@",cachesPath);
  ```
  - 获取tmp文件目录
  ```
      NSString *tmpPath = NSTemporaryDirectory();
      NSLog(@"%@",tmpPath);
  ```
  #### 13.1.2 在Mac上查看沙盒目录
  ### 13.2 Plist文件
  #### 13.2.1 Plist简介
  1. Plist简介
  鉴于Plist属于文件存储，不是数据库存储，所以当数据量不是特别大时，建议采用。一般来说，App在本地不会存储大量的数据，前端所需的数据一般都是存储在远程服务器的数据库中。对于手持终端来说，Plist存储对于绝大多数情况下，都能够满足数据持久化的要求。
  
  2. 手工创建Plist文件
  - 在Xcode中，新建文件，选择PropertyList
  - Plist文件创建完成后，可以在Xcode中选中这个Plist文件，并新增一些记录。
  
  3. 读取Plist文件中的内容
  Plist文件创建完成后，就可以使用Foundation框架中提供的文件存取方法读取Plist文件中的数据。
  - 获取Plist文件所在路径，由于是手工新增的Plist文件，因此存储在mainBundle中。
  ```
    NSString *path = [[NSBundle mainBundle]pathForResource:@"website" ofType:@"plist"];
  ```
  - 读取Plist文件中的内容，返回结果存储在一个字典对象中。
  ```
   NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];
  ```
  #### 13.2.2 Plist文件的读取
  Plist文件的顶层结构通常是由一个字典或者一个数组构成的。因此,Plist文件的读取思路，就是把Plist文件中的所有数据一次性读取出来，然后放到一个字典对象或数组对象中，供后续操作使用。
  1. 读取Plist文件返回数组
  当Plist文件的顶层结构是一个数组时，通常会用于存储一些具有相同数据结构的数据，这个结构与数据库的表是类似的。
  - 手工添加一个Plist文件，顶层结构是一个Array，然后再添加两条记录。
  ![eadfde7f.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\eadfde7f.png)
  - 获取Plist文件的路径
  ```
  NSString *arrayPistPath = [[NSBundle mainBundle]pathForResource:@"websites" ofType:@"plist"];
  ```
  - 使用arrayWithContentsOfFile:方法，读取Plist方法，结果存放在一个数组对象中。
  ```
  NSString *arrayPistPath = [[NSBundle mainBundle]pathForResource:@"websites" ofType:@"plist"];
  NSMutableArray *arrayM = [NSMutableArray arrayWithContentsOfFile:arrayPistPath];
  ```
  2. 读取Plist文件返回字典
  - 手工添加一个Plist文件，顶层结构是一个字典。
  ![f98149d3.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\f98149d3.png)
  - 获取Plist文件的路径。
  ```
  NSString *dicPistPath = [[NSBundle mainBundle]pathForResource:@"website" ofType:@"plist"];
  ```
  - 使用dictionaryWithContentsOfFile方法，读取Plist文件，结果存放在一个字典对象中。
  ```
  NSString *dicPistPath = [[NSBundle mainBundle]pathForResource:@"website" ofType:@"plist"];
  NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:dicPistPath];
  ```
  
  #### 13.2.3 Plist文件的写入
  Plist文件的操作也属于文件操作的范畴，通常可以使用writeToFile方法，把一个字典对象或数组对象写入一个指定的Plist文件中进行保存。
  - 首先准备需要写入的数据对象。
  ```
  NSMutableDictionary *dict = [NSMutableDictionary dictionary];
  [dict setValue:%@"99iOS" forKey:@"webName"];
  ```
  - 准备Plist文件的路径，通常考虑写入沙盒中的Documents目录中。
  ```
      NSArray *documentsArr = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
      NSString *documentsPath = [documentsArr objectAtIndex:0];
      NSString *dictPlistPath = [documentsPath stringByAppendingPathComponent:@"dict.plist"];
  ```
  - 使用NSArray类或NSDictionary类中提供的writeToFile:方法，写入指定的Plist文件。
  ```
  [dict writeToFile:dictPlistPath atomically:yes];
  ```
  
  #### 13.2.4 操作实例
  1. 创建模型Model
  - 创建一个Person类，其中包含姓名name以及年龄age两个属性。
  ```
  @property(nonatomic,strong) NSString *name;
  @property(nonatomic,strong) NSNumber *age;
  ```
  - 由于Plist文件中只能保存Foundation框架中定义的NSString、NSDictionary以及NSArray等类型的数据，而不能保存对象，所以需要再Person.h中添加一个方法，通过该方法可以把Plist文件保存的数据转换成对象。
  ```
  +(instancetype) personWithDict:(NSDictionary *)dict;
  ```
  - 在Person.m中实现personWithDict:方法的功能。
  ```
  +(instancetype)personWithDict:(NSDictionary *)dict{
      Person *person = [[Person alloc] init];
      person.name = dict[@"name"];
      person.age = dict[@"age"];
      return person;
  }
  ```
  2. 创建用于Plist操作的Service类
  - 在Service.h文件中添加两个方法，分别用于写入新增数据以及读取所有联系人。
  ```
  - (void)addPersonWithDict:(NSDictionary *)dict;
  - (NSArray *)readAllPerson;
  ```
  - 在Service.m文件中，实现上述方法的功能。
  ```
  /* 获取plist文件的路径*/
  -(NSString *)personPlistFilePath{
      NSArray *documentArray = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);
      NSString *documentPath = [documentArray firstObject];
      NSString *personPlistFilePath = [documentPath stringByAppendingPathComponent:@"person.plist"];
      return personPlistFilePath;
  }
  
  -(void)addPersonWithDict:(NSDictionary *)dict{
      //获取Plist文件路径
      NSString *plistPath = [self personPlistFilePath];
      //检查Plist文件是否存在
      NSFileManager *fileManager = [NSFileManager defaultManager];
      if(![fileManager fileExistsAtPath:plistPath]){
          [fileManager createFileAtPath:plistPath contents:nil attributes:nil];
      }
      //读取Plist中的文件
      NSMutableArray *personArrayM = [NSMutableArray arrayWithContentsOfFile:plistPath];
      //判断arrayM是否为空，为空则创建
      if(personArrayM == nil){
          personArrayM = [NSMutableArray array];
      }
      //传入的dict插入数组中
      [personArrayM addObject:dict];
      //写入文件
      [personArrayM writeToFile:plistPath atomically:YES];
  }
  
  -(NSArray *)readAllPerson{
      //获取plist文件路径
      NSString *plistPath = [self personPlistFilePath];
      //读取plist文件
      NSArray *personArray = [NSArray arrayWithContentsOfFile:plistPath];
      return personArray;;
  }
  ```
  3. 实现写入功能
  - 在ViewController.m文件中，实现写入Plist文件的功能
  ```
  - (IBAction)writeToPlist:(id)sender {
      NSNumberFormatter *formatter = [[NSNumberFormatter alloc]init];
      NSNumber *age = [formatter numberFromString:self.ageTextField.text];
      NSDictionary *personItemDict = @{
          @"name" :self.nameTextField.text,
          @"age":age,
      };
      [[[Service alloc]init] addPersonWithDict:personItemDict];
  }
  ```
  4. 实现读取功能
  ```
  - (IBAction)readFromPlist:(id)sender {
      NSArray *personArray = [[[Service alloc]init]readAllPerson];
      for(NSDictionary *dict in personArray){
          Person *person = [Person personWithDict:dict];
          NSLog(@"%@,%@",person.name,person.age);
      }
  }
  ```
  ### 13.3. 偏好设置NSUserDefaults
  #### 13.3.1 NSUserDefaults 简介
  1. 偏好设置简介
  Foundation框架提供了一套标准的解决方法为应用提供了偏好设置功能。每个应用都有一个NSUserDefaults实例，通过它来存取偏好设置。NSUserDefaults基本上支持所有的原生数据类型NSString,NSNumber,NSDate,NSArray,NSDictionary,BOOL,NSInterger.
  - 偏好设置也是保存在应用的沙盒中，保存的路径在Library/Preferences路径下。
  - 偏好设置可以理解为是一个特殊的Plist文件，但由于其本质上还是Plist文件，因此，存储形式还是使用键值对的方式。
  2. 偏好设置常用方法和属性 
  在Foundation框架中的NSUserDefaults.h文件中，提供了NSUserDefaults类的方法和属性，常用的方法和属性有以下几个。
  - standardUserDefaults 获取系统默认的偏好设置对象。
  ```
  @property(class, readonly, strong) NSUserDefaults *standardUserDefaults;
  ```
  - 偏好设置写入方法
  ![483e5ae3.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\483e5ae3.png)
  - 偏好设置读取方法
  ![6202091b.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\6202091b.png)
  - 移除某个键值对
  ```
  - (void)removeObjectForKey:(NSString *)aKey;
  ```
  - synchronize: 立即写入偏好设置Plist文件中。
  ```
  - (BOOL)synchronize;
  ```
  #### 13.3.2 读写示例
  1. 存储数据(新增/更新)
  ```
      NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
      [defaults setObject:[NSDate date] forKey:@"LastLoginTime"];
      [defaults setBool:NO forKey:@"IsFirstLogin"];
      [defaults setValue:@"99iOS" forKey:@"UserName"];
      
      [defaults synchronize];
  ```
  2. 读取数据
  ```
      NSUserDefaults *readdefaults = [NSUserDefaults standardUserDefaults];
      NSDate *lastLoginTime = [readdefaults objectForKey:@"LastLoginTime"];
      BOOL isFirstLogin = [readdefaults boolForKey:@"IsFirstLogin"];
      NSString *userName = [readdefaults valueForKey:@"UserName"];
      NSLog(@"%@--%d--%@",lastLoginTime,isFirstLogin,userName);
  ```
  
  3. 删除数据
  ```
      NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
      [defaults removeObjectForKey:@"LastLoginTime"];
  ```
  ### 13.4 归档
  ### 13.5 SQLite
  #### 13.5.1 数据库的操作
  对于简单的数据，完全可以使用Plist来存取数据。随着数据逐渐变大，查询数据和修改数据就会变得越来越麻烦。另外，使用Plist来存取数据无法解决的一个问题是，每次查询数据需要将整个文件都加载到内存中。
  
  1. 数据类型
  ![fb3975d9.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\fb3975d9.png)
  
  2. 导入SQLite
  在工程的TARGETS中选择Build Phases选项，在Link Binary With Libraries中添加libsqlite3.dylib到工程中。在添加的过程中，存在libsqlite3.dylib和libsqlite3.0.tbd.这两者的区别是:libsqlite3.dylib总是链向最新的libsqlite库.
  在程序需要使用SQLite的类中添加头文件。
  ```
  #import<sqlite3.h>
  ```
  3. 创建数据库
  - 在控制器类中添加一个sqlite3 类型的属性
  ```
  #import <sqlite3.h>
  @interface ViewController ()
  @property (nonatomic,assign)sqlite3 *db;
  @end
  ```
  - 在ViewController.m中，添加如下的方法，为用户创建一个SQLite数据库
  ```
  -(BOOL)openDatabaseWithName:(NSString *) databaseName{
      NSString *docsDir = nil;
      NSArray *dirPath = nil;
      
      dirPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
      docsDir = [dirPath objectAtIndex:0];
      
      NSString *databasePath = [[NSString alloc] initWithString:[docsDir stringByAppendingPathComponent:databaseName]];
      
      NSFileManager *fileManager = [NSFileManager defaultManager];
      
      const char *dbPath = [databasePath UTF8String];
      
      if(![fileManager fileExistsAtPath:databasePath]){
          if(sqlite3_open(dbPath, &_db)== SQLITE_OK){
              NSLog(@"数据库打开/创建 成功：%@",databasePath);
              return YES;
          }
          else{
              NSLog(@"数据库打开/创建 失败：%@",databasePath);
              return NO;
          }
      }else{
          NSLog(@"数据库已创建：%@",databasePath);
          if(sqlite3_open(dbPath, &_db) == SQLITE_OK){
              NSLog(@"数据库打开/创建 成功：%@",databasePath);
              return YES;
          }else{
              NSLog(@"数据库打开/创建 成功：%@",databasePath);
              return NO;
          }
          return YES;
      }
  }
  ```
  - 关闭数据库
  ```
  - (void)closeDB {
      if (NULL == _db) {
          NSLog(@"数据库不存在");
      } else {
          sqlite3_close(_db); // 关闭数据库
      }
  }
  ```
  #### 13.5.2 表的操作
  1. 创建表
  ```
  -(BOOL)createTable{
      if(NULL == _db){
          NSLog(@"数据库不存在，创建联系人，表失败");
          return NO;
      }
      char *errMsg = NULL;
      const char *sql = "CREATE TABLE IF NOT EXISTS CONTACTS (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, address TEXT, phone TEXT)";
      if(sqlite3_exec(_db, sql, NULL, NULL, &errMsg)!=SQLITE_OK){
          NSLog(@"创建，联系人表失败");
          return NO;
      }
      NSLog(@"创建联系人表成功");
      return YES;
  }
  ```
  2. 删除表
  ```
  -(BOOL)dropTable{
      if(NULL == _db){
          NSLog(@"数据库不存在，删除联系人，表失败");
          return NO;
      }
      char *errMsg = NULL;
      const char *sql = "DROP TABLE CONTACTS;";
      if(sqlite3_exec(_db, sql, NULL, NULL, &errMsg)!=SQLITE_OK){
          NSLog(@"删除，联系人表失败");
          return NO;
      }
      NSLog(@"删除联系人表成功");
      return YES;
  }
  ```
  #### 13.5.3 数据记录的操作
  1. 添加数据
  ```
  - (BOOL)insertContact:(NSString *)name address:(NSString *)address phone:(NSString *)phone{
      if(NULL == _db){
          NSLog(@"数据库不存在，添加联系人失败");
          return NO;
      }
      char *errMsg = NULL;
      NSString *sqlString = [NSString stringWithFormat:@"INSERT INTO CONTACTS (name,address,phone) VALUES('%@','%@','%@');",name,address,phone];
      const char *sql = [sqlString UTF8String];
      if(sqlite3_exec(_db, sql, NULL, NULL, &errMsg) != SQLITE_OK){
          NSLog(@"添加联系人失败");
          return NO;
      }
      NSLog(@"添加联系人成功");
      return YES;
  }
  
  ```
  
  2. 查询数据
  ```
  -(void)printAllContact{
      if(NULL == _db){
          NSLog(@"数据库不存在，添加联系人失败");
          return;
      }
      const char *sql = "SELECT * FROM CONTACTS";
      sqlite3_stmt *stmt = NULL;
      if(sqlite3_prepare_v2(_db, sql, -1, &stmt, nil)==SQLITE_OK){
          while (sqlite3_step(stmt) == SQLITE_ROW) {
              char *name = (char*)sqlite3_column_text(stmt, 1);
              NSString *nameString = [[NSString alloc]initWithUTF8String:name];
              char *address = (char *)sqlite3_column_text(stmt, 2);
              NSString *addressString = [[NSString alloc]initWithUTF8String:address];
              char *phone = (char *)sqlite3_column_text(stmt, 3);
              NSString *phoneString = [[NSString alloc]initWithUTF8String:phone];
              
              NSLog(@"name:%@,address:%@,phone:%@",nameString,addressString,phoneString);
          }
          sqlite3_finalize(stmt);
      }
  }
  ```
  - sqlite3_prepare_v2 是执行语句前编译语句，如果返回SQLITE_OK表示查询成功
  - sqlite3_step为执行查询语句，如果返回SQLITE_ROW则表示查询到记录
  - sqlite3_column_text用于获取查询到记录的值。
  - sqlite3_finalize语句需要和sqlite3_prepare_v2成对出现，否则会造成内存泄漏。
  
  3. 删除数据
  ```
  -(BOOL)deleteAllContactWithName:(NSString *)name{
      if(NULL ==_db){
          NSLog(@"数据库不存在，删除联系人失败");
          return NO;
      }
      char *errMsg = NULL;
      NSString *sqlString = [NSString stringWithFormat:@"DELETE FROM CONTACTS WHERE name='%@'",name];
      const char *sql = [sqlString UTF8String];
      if(sqlite3_exec(_db, sql, NULL, NULL, &errMsg)!=SQLITE_OK){
          NSLog(@"删除联系人失败");
          return NO;
      }
      NSLog(@"删除联系人成功");
      return YES;
  }
  ```
  4. 修改数据
  ```
  -(BOOL)updatePhone:(NSString *)phone forContactWithName:(NSString *)name{
      if(NULL ==_db){
          NSLog(@"数据库不存在，更新联系人失败");
          return NO;
      }
      char *errMsg = NULL;
      NSString *sqlString = [NSString stringWithFormat:@"UPDATE CONTACTS SET phone='%@' WHERE name='%@'",phone,name];
      const char *sql = [sqlString UTF8String];
      if(sqlite3_exec(_db, sql, NULL, NULL, &errMsg)!=SQLITE_OK){
          NSLog(@"更新联系人失败");
          return NO;
      }
      NSLog(@"更新联系人成功");
      return YES;
  }
  ```
  ### 13.6 FMDB
  #### 13.6.1 基本介绍
  FMDB是使用Object-C 对SQLite的API进行封装的库，使用起来会比直接使用C语言API容易。
  
  ### 13.7 Core Data
  #### 13.7.1 概念简介
  Core Data是苹果官方提供的管理数据层对象的框架，它提供了对象关系映射的功能，即能够将Objective-C对象转换成数据，保存在SQLite数据库文件中,也能够将保存在数据库中的数据还原成Objective-C对象。在此数据操作期间，不需要编写任何SQL语句。
  Core Data针对对象生命周期，以及持久化的对象图管理中的一些常见问题提供了解决方案。Core Data的主要任务是负责数据更改的管理、序列化到磁盘、最小化内存占用以及查询数据。
  1. Core Data中的术语
  - 实体: 在Core Data中定义的类。在关系型数据库中，一个实体对应于一张表。
  - 属性: 实体的一部分信息。比如，一个雇员实体有名字属性、职位属性、工资属性。在数据库中一个属性对应表中一个字段。
  - 关系: 多个实体间的链接。在Core Data里两个实体的关系称为一对一关系。一个和多个实体的关系称为一对多的关系。
  
  2. Core Data中的核心类
  - NSManagedObjectModel:管理对象模型，用于描述应用程序的数据模型，这个模型包含实体(Entity)、特性(Property)、读取请求(Fetch Request)等，Core Data默认使用SQLite数据库作为存储源，因此你可以把数据类型当成数据库的表结构。
  - NSManagedObjectContext:管理对象上下文，参与对数据对象进行各种操作的全过程，并监测数据对象的变化，以提供对undo/redo的支持及更新绑定到数据的UI.
  - NSPersistentContainer: 相当于数据文件管理器，处理底层的堆数据文件的读取与写入。
  
  3. Core Data中的常用方法
  对于Core Data的操作，与SQLite类似，主要就是涉及数据的增、删、改、查相关操作。
  - 实例化一个管理对象。在Core Data中管理的都是NSManagedObject对象，在NSManagedObject.h中也提供了用于创建NSManagedObject对象的方法。
  ```
  - (__kindof NSManagedObject *)initWithEntity:(NSEntityDescription *)entity insertIntoManagedObjectContext:(NSManagedObjectContext *)context;
  ```
  
  - 执行查询请求。在NSManagedObjectContext类中，提供了用于查询的方法，在该方法中，需要传递一个NSFetchRequest类型的参数作为查询请求，该参数中包含了查询条件等相关信息。
  ```
  - (NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError * _Nullable *)error;
  ```
  
  - 查询条件的设置。在Core Data中，不需要编写SQL语句，但提供了NSFetchRequest类，在该类中，可以设置相关的查询条件，包括需要查询的对象、结果的排序方法(NSSortDescriptor)以及查询条件(NSPredicate类)。
  ```
  + (instancetype)fetchRequestWithEntityName:(NSString *)entityName;
  @property(nullable,nonatomic,strong) NSArray<NSSortDescriptor *> *sortDescriptors
  @property(nullable,nonatomic,strong) NSPredicate *predicate;
  ```
  
  - 插入与删除对象。在NSManagedObjectContext类中，提供了用于针对NSManagedObject类对象的插入以及删除方法，利用这些方法就不再需要编写INSERT语句以及DELETE语句。
  ```
  - (void)insertObject:(NSManagedObject *)object;
  - (void)deleteObject:(NSManagedObject *)object;
  ```
  
  #### 13.7.2 使用示例
  1. 创建项目时，勾选Use Core Data选项
  
  ![29e55c28.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\29e55c28.png)
  
  2. 通过.xcdatamodeld来添加一个Entity.
  ![63ebde5a.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\63ebde5a.png)
  3. 单击Xcode的Editor菜单，选中Create NsManagedObject SubClass来添加实体类，另外在编译选项中添加CoreData.framework.并且删除CompileSources中的Person+CoreDataProperties.m
  ![c2027895.png](:storage\\2038464d-5804-41ee-8efc-46aa7202649d\\c2027895.png)
  4. 准备工作
  在ViewController.m中引入需要使用的其他类的头文件。
  ```
  #import "ViewController.h"
  #import <CoreData/CoreData.h>
  #import "Person+CoreDataClass.h"
  #import "AppDelegate.h"
  
  @interface ViewController ()<UITextFieldDelegate>
  @property (weak, nonatomic) IBOutlet UITableView *tableView;
  @property (nonatomic,strong) UIAlertController *alert;
  @property (nonatomic,strong) NSMutableArray<Person *> *personList;
  
  @end
  
  @implementation ViewController
  
  - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
      return self.personList.count;
  }
  
  - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"TableViewCell"];
      cell.textLabel.text = self.personList[indexPath.row].name;
      return cell;
  }
  
  #pragma mark - Getter
  - (NSMutableArray<Person *> *)personList {
      if (nil == _personList) {
          _personList = [NSMutableArray<Person *> arrayWithCapacity:10];
      }
      return _personList;
  }
  
  @end
  
  ```
  
  5. 查询数据
  在ViewDidLoad方法中，添加代码，可以实现当打开App会自动从管理对象上下文中获取存储的数据。并显示到UITableView中。
  ```
  - (void)viewDidLoad {
      [super viewDidLoad];
      //1. 获取NSManagedObjectContext对象
      AppDelegate *appDelegate = (id)[UIApplication sharedApplication].delegate;
      NSManagedObjectContext *context = appDelegate.persistentContainer.viewContext;
      //2. 生成一个Person 的查询对象
      NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@"Person"];
      //3. 设置查询对象排序描述符，这样能使得查询的结果按需排序
      NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"name" ascending:YES];
      NSArray *sortDescriptors = [NSArray arrayWithObject:sort];
      fetchRequest.sortDescriptors = sortDescriptors;
      
      //4. 设置查询条件，这边直接返回TRUE，表示查询所有数据
      NSPredicate *predicate = [NSPredicate predicateWithValue:YES];
      fetchRequest.predicate = predicate;
      //5. 执行查询语句，并更新tableview的显示
      NSArray *results = [context executeFetchRequest:fetchRequest error:nil];
      [self.personList addObjectsFromArray:results];
      //更新表视图
      [self.tableView reloadData];
  }
  ```
  6. 添加数据
  通过Person实体并添加预选创建的管理对象上下文中。
  ```
  - (BOOL)textFieldShouldReturn:(UITextField *)textField {
      [self.alert dismissViewControllerAnimated:YES completion:^{
          NSLog(@"%@", textField.text);
          // 1. 获取NSManagedObjectContext对象
          AppDelegate *appDelegate = (id)[UIApplication sharedApplication].delegate;
          NSManagedObjectContext *context = appDelegate.persistentContainer.viewContext;
          // 2. 创建Person实体描述
          NSEntityDescription *entity = [NSEntityDescription entityForName:@"Person"
                                                    inManagedObjectContext:context];
          // 3. 创建一个Person实体
          Person *person = (id)[[NSManagedObject alloc] initWithEntity:entity
                                        insertIntoManagedObjectContext:context];
          person.name = textField.text;
          // 4. 添加Person实体到UITableView数据源
          [self.personList addObject:person];
          [self.tableView reloadData];
      }];
      self.alert = nil;
      return YES;
  }
  
  - (IBAction)onClickedAddButton:(id)sender {
      self.alert = [UIAlertController alertControllerWithTitle:@"添加名字" message:nil preferredStyle:UIAlertControllerStyleAlert];
      __weak typeof(self) weakSelf = self;
      [self.alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {
          textField.delegate = weakSelf;
      }];
      [self presentViewController:self.alert animated:YES completion:nil];
  }
  
  ```
  7. 更新数据
  ```
  - (IBAction)onClickedEditLastOneButton:(id)sender {
      NSLog(@"修改最后一行");
      Person *person = self.personList.lastObject;
      person.name = [NSString stringWithFormat:@"已修改:%@", person.name];
      [self.tableView reloadData];
  }
  ```
  8. 删除数据
  ```
  - (IBAction)onClickedDeleteLastOneButton:(id)sender {
      if (self.personList.count == 0) {
          NSLog(@"没有数据了，不能进行操作");
          return;
      }
      
      NSLog(@"删除最后一行");
      // 1. 获取最后一个Person对象
      Person *person = self.personList.lastObject;
      // 2. 获取NSManagedObjectContext对象
      AppDelegate *appDelegate = (id)[UIApplication sharedApplication].delegate;
      NSManagedObjectContext *context = appDelegate.persistentContainer.viewContext;
      [context deleteObject:person];
      // 3. 判断Person对象如果被删除，则从self.personList中把它移除。随后更新表视图
      if ([person isDeleted]) {
          [self.personList removeObject:person];
      }
      [self.tableView reloadData];
  }
  ```
  ### 13.8 Realm
  #### 13.8 Realm 基本介绍
  Realm是一个跨平台的移动数据库引擎，它是专门为移动应用所设计的数据持久化解决方案。Realm并不是对SQLite或者CoreData的简单封装，它建立了自己独特的数据库存储引擎，可以方便，高效地完成数据库的各种操作。
  Realm是一款专门针对移动平台设计的数据库，因此其能够无缝支持iOS以及Android,并且支持Objective-C,Swift,Java,ReactNative等多种编程语言编写。
  与SQLite或者CoreData相比，Realm最大的优势在于学习门槛极低，由于其是直接针对对象进行读写的，因此，不必像SQLite一样，需要预先掌握SQL语句，也不像CoreData那么繁琐。
  
  
'''
linesHighlighted: [
  1791
  1790
  5349
  5393
]
isStarred: false
isTrashed: false
