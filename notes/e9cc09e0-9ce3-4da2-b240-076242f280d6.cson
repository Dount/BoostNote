createdAt: "2019-10-16T02:39:38.018Z"
updatedAt: "2020-06-08T09:56:05.814Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Java面试题"
tags: []
content: '''
  # Java面试题
  [TOC]
  ## 1、基础语法
  
  ### 字符串拼接的方式以及效率
  1. 使用+直接拼接，String 是final对象，不会被修改，每次使用+进行拼接都会创建新的对象，而不是改变原来的对象，效率低，是线程安全的。
  2. 使用StringBuffer可变字符串，是线程安装的（StringBuffer的方式使用了Synchronized关键字进行修饰）。
  3. 使用StringBuilder可变字符串，效率最高，但是线程不安全。
  
  ### 简述final,finally和finalize区别
  1. final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方式不可重写，被final修饰的变量引用不可变，引用的内容可以更改。
  2. finally用于try-catch 代码块中，无论是否发生异常最后都将被执行，作用是释放资源。
  3. finalize 是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。
  
  ### ==和equals有什么区别?equals和hashCode有什么联系
  1. 如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。
  2. 如果没有重写的话，equals默认按照==进行比较，如果重写了equals() 方法，则按照对应的比较规则比较。
  3. 两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。
  理解：
  如果是Integer类的hashcode返回的是值比较，对象不一定相同 √
  如果是String类的hashcode 值是算法计算出来的，有可能导致hashcode值相同的情况，两个对象不一定相同 √
  
  ### Array和ArrayList的区别
  1.Array长度在定义之后就不运行改变了，而ArrayList是长度可变的，可以自动化扩容。
  2.Array只能存储相同类型的数据，ArrayList可以存储不同类型的数据。
  3.ArrayList提供了更多操作数据的方法。
  
  ### 简述JDK8的新特性
  1.接口中可以添加default修饰的非抽象方法，可以有方法和内容。
  2.可以使用lambda表达式，减少代码冗余
  3.函数式接口，使用@Functionalinterface注解标明，该接口有且仅有一个抽象方法。
  4.方法引用，可以直接引用已有java类或对象的方法或构造器，进一步简化lambda表达式，
  5.stream流，用于解决已有集合/数组类库的弊端，简化其操作，有foreach遍历，filter过滤，map映射，concat合并等功能。
  6.增加日期相关的API
  
  ### Stream流
  1.Stream流是JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。
  2.Stream流的获取
    1）集合：直接调用Stream()方法获取
    2）数组：使用静态方法Stream.of()/Arrays.stream()获取
  3.常用方法
    1)forEach()遍历
    2)count()统计个数
    3)filter()按条件过滤
    4)limit()取前面n个元素
    5)skip()跳过前面n个元素
    6)map()映射加工
    7)concat()合并stream流
  4.终结方法
    foreach/count调用终结方法后流不能继续使用
  5.非终结方法
    每次调用完返回一个新的Stream对象，可以继续使用。
  6.收集Stream流
    1）把流转为Set集合 collect(Collections.toSet())
    2) 把流转为List集合 collect(Collections.toList())
    3) 把流转为Collection集合 collect(Collections.toCollection())
    4) 把流转为数组toArray()
  
  ## 面向对象
  
  ### 简述面向对象的特性
    1）封装：建议成员变量私有，然后提供公有的getter/setter方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露。可以提高安全性，实现代码的组件化
    2）继承：一种子类到父类的关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。
    3) 多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，右边对象可以实现组件化切换，业务功能随之改变，便于扩展和维护。
  ### 列举Object类的方法
     1）equals(Object obj):判断其他对象是否与当前对象相等。
     2）toString():打印当前对象的字符串表示
     3) wait():导致当前线程等待，等待其它线程唤醒，会释放锁。
     4) notify()/notifyAll():随机唤醒一个/全部线程
     5) hashCode():返回当前对象的hashCode值。
     6) finalize():当垃圾回收期要回收对象前调用。
     7) clone:创建并返回对象的一个副本.
  ### 接口和抽象类有什么区别
    1）接口中只能定义public static final 修饰的常量，抽象类中可以定义普通变量。
    2）接口和抽象类都不能实例化，但接口没有构造器，抽象类有构造器。
    3）接口可以多实现，抽象类只能单集成。
    4）接口在JDK1.8之前只能定义public abstract修饰的方法，JDK1.8开始可以定义默认方法和静态方法，JDK1.9开始可以定义私有方法，抽象类中的方法没有限制。
    
  ### 什么时候应该使用接口，什么时候应该使用抽象类
    1）如果知道某个类应该成为基类，那么第一选择应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。
    2）在接口和抽象类的选择上，必须遵守：行为模型应该总是通过接口而不是抽象类定义。又由于java不允许多继承，最好是选择接口去实现。
    
  ### 内部类有什么作用？有哪些分类？
    Q1.内部类有更好的封装性，有更多的权限修饰符，封装性可以得到更多的控制。
    Q2.内部类的分类
        1）静态内部类：由于static修饰，属于类本身，只加载一次。类可以定义的成分，静态内部类都可以定义。可以访问外部类的静态变量和方法，
        通过new外部类，静态内部类构造器，来创建对象。
        2）成员内部类：属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过new 外部类构造器.静态内部类构造器来创建对象。
        3）局部内部类：定义在方法、构造器、代码块、循环中。只能定义实例成员变量和实例方法，作用范围仅在局部代码块中。
        4）匿名内部类：没有名字局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，对象类型相当于当前new的子类类型。
  
  ### 泛型和泛型擦除
    1.泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制运行程序在编译时检测非法的类型。
    2.在编译阶段采用泛型时带上类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除。因此泛型主要用于编译阶段，在编译后生成的java字节代码文件中不包含泛型中的类型信息。
  
  ### 泛型标记的规范
    1.Element,在集合中使用，表示在集合中存放的元素
    2.指Type,表示java类，包括基本的类以及自定义类
    3.指Key,表示键，例如Map集合中的key.
    4.指value,表示值，例如Map集合中的Value
    5.指Number,表示数值类型.
    6.?，表示不确定的java类型
  
  ### 泛型限定是什么
    1.类型通配符使用？表示所有具体的参数类型，在使用泛型的时候，如果希望将类的继承关系加入泛型应用中就需要对泛型做限定，具体的泛型限定有对泛型上限的限定以及对泛型下限的限定。
    2.对泛型上限限定使用</?extends T>它表示该通配符所代表的类型是T类的子类型或T接口的子接口。
    3.对泛型下限的限定使用</?super T>它表示该通配符所代表的的类型是T类的父类型或T接口的父接口。
  
  ## 异常
  
  ### java异常类层次结构图
  
  ![Exception.png](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)
  在java中，所有的异常都有一个共同的祖先java.lang包中的Throwable类。Throwable:有两个重要的子类：Exception(异常)和Error（错误）,二者都是java异常处理的重要子类，各自都包含大量子类。
  
  异常和错误的区别：异常能被程序本身处理，错误是无法处理。
  
  ### 异常有哪些分类？出现的原因是什么？
  1.Throwable是所有错误和异常的父类,Throwable分为Error和Exception.
  2.Error指Java程序运行错误。出现Error通常是因为系统的内容部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error, 系统只能记录错误的原因和安全终止。
  3.Exception指java程序运行异常，即运行中发生了不期望的情况，分为RuntimeException和CheckedException.RuntimeException指在Java 虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。CheckedException指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。
  
  ### 有哪些异常处理方式?
  1.抛出异常:遇到异常不进行具体处理，而是将异常抛出给调用者，由调用者根据情况处理。抛出异常有2种形式，一种是throws,作用在方法上，一种是Throw,作用在方法内。
  2.使用trycatch进行异常的捕获处理，try中发生的异常会被catch代码块捕获，根据情况进行处理，如果有finally代码块无论是否发生异常都会执行，一般用于释放资源，JDK1.7开始可以将资源定义在try代码块中自动释放减少代码。
  
  
  ### Error(错误)
  Error(错误)：是程序无法处理的错误，表示运行应用程序中较严重问题，大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM(java虚拟机)出现的问题。
  例如，java虚拟机运行错误（Virtual Machine Error）,当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。
  
  这些错误表示故障发生于虚拟机自身，或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该视图去处理它所引起的异常状况。在java中，错误通过Error的子类描述。
  
  ### Exception(异常)
  Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。
  
  ### Throwable类常用方法
  
  - **public string getMessage()**:返回异常发生时的简要描述
  - **public string toString()**:返回异常发生时的详细信息
  - **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
  - **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息
  
  ### 异常处理总结
  
  - **try 块：** 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
  - **catch 块：** 用于处理try捕获到的异常。
  - **finally 块：** 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return
  语句时，finally语句块将在方法返回之前被执行。
  
  **在以下4种特殊情况下，finally块不会被执行：**
  
  1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
  2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
  3. 程序所在的线程死亡。
  4. 关闭CPU。
  
  下面这部分内容来自issue:<https://github.com/Snailclimb/JavaGuide/issues/190>。
  
  **注意：** 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：
  
  ```java
      public static int f(int value) {
          try {
              return value * value;
          } finally {
              if (value == 2) {
                  return 0;
              }
          }
      }
  ```
  如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。
  
  ## 集合
  ### 简述一下集合主要有哪些类和接口，各自有什么特点。
  1.主要有两个接口Collection和Map.
  2.Collection包括List,Set和Queue
    1）List是有序的，主要包括ArrayList，LinkedList和Vector，ArrayList底层通过数组实现，线程不安全，Vector是线程安全的ArrayList，但效率较低，LinkedList底层通过双向链表实现，与ArrayList相比增删快查询慢。
    2) Set是唯一且无序的，主要包括HashSet，LinkedHashSet和TreeSet。HashSet底层其实就是HashMap，利用了key来保证元素的唯一性。LinkedHashSet可以按照key的操作顺序排序，TreeSet支持按照默认或指定的排序规则排序。
    3) Queue是队列结构，主要有ArrayBlockingQueue基于数组的阻塞队列、LinkedBlockingQueue基于链表的阻塞队列等
  3.Map以key-value键值对的形式存储元素,包括：HashMap、LinkedHashMap和TreeMap。
    1）HashMap底层通过数组+链表/红黑树实现
    2）LinkedHashMap可以按照key的操作顺序对集合排序
    3）TreeMap可以按照默认或指定的排序规则对集合排序
  
  ### HashMap是线程安全吗？
  1.HashMap是线程不安全的，可以使用ConcurrentHashMap保证线程安全。
  2.ConcurrentHashMap基于减小锁粒度的思想，通过使用分段锁来实现线程安全，内部细分为很多Segment数据段，默认情况下为16个，对每个Segment的数据都单独进行加锁操作，Segment的个数为锁的并发度。ConcurrentHashMap是由Segment数组和HashEntry数组组成的，Segment继承了可重入锁，HashEntry用来存储键值对数据。
  3.Segment的结构和HashMap类似，是数组和链表结构，每个Segment里面都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据要对其进行i修改必须先获得对应的Segment锁。
  4.多线程下只要加入的数据hashCode映射的数据段不一样就可以做到并行的线程安全。
  
  ### List,Set,Map有什么区别？
  1.List是有序，可重复，有索引的集合，继承了Collection集合全部功能除了Collection的三种遍历方式外，可用索引遍历。
  2.Set是无序，不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或者自定义的比较规则排序。
  [Java中的Set总结 - 简书](https://www.jianshu.com/p/d6cff3517688)
  
  3.Map是无序，以Key-value的键值对形式存储元素的集合。键不可重复，值无需求，重复的键对应的值会覆盖之前的值。
  
  ### HashSet是如何去重的？
  1.对于基本类型的包装类，可以直接按值进行比较。
  2.对于引用数据类型，会先比较HashCode()返回值是否相同，如果不同则代表不是同一个对象。如果相同继续比较equals（） 方法返回值是否相同，都相同说明是同一个对象。
  3.如果希望内容相同的对象就代表对象相同，那么除了重写equals()方法还要重写hashCode()方法，因为内容相同的对象hashCode()值不一定相同，因为只有hashCode()和equals()都相同才说明是同一个对象。
  
  ### HashMap和HashSet的底层是怎么实现的？
  1.JDK1.8之前，HashMap的底层是数组加链表实现。数组中的每个元素都是一个单链表，链表中的每个元素都是Entry的实现类Node的一个实例，Node包括4个属性：key,value,hash值和用于指向单链表下一个元素的next.
  2.HashMap在查找数据时，根据hash值可以快速定位到数组的具体下标，然后对链表进行遍历查找数据的时间复杂度为O(n)
  3.JDK1.8之后， HashMap底层改为数组+链表或红黑树，当链表中的元素超过8个之后，HashMap会将链表结构转换未红黑树以提高查询效率，时间复杂度为O(logn)。
  4.HashSet的底层是基于HashMap实现的，HashSet中的元素只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关操作基本上都是直接调用底层HashMap的相关方法来完成的。
  
  ### Collection和Collections有什么区别
  1.Collection是一个集合接口，它包括List有序结合，Set无序集合，Queue队列等。
  2.Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll 可以直接对Collection集合批量的添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或按比较器进行排序。
  
  ### 迭代器是什么？
  1.迭代器实现了iterator接口，是用于遍历Collection集合元素的一个指针。
  2.主要有三个方法
    1）通过iterator()获得集合的迭代器
    2）通过hasNext()判断集合当中是否还有元素，如果有返回true,没有则返回false. 初始化迭代器位于第一个元素之前。
    3）通过next()获取集合的下一个元素，并向后移动一个元素的单位。
  
  ### Queue接口中add()/offer(),remove()/poll(),element()/peek()方法有什么区别？
  1.add()和offer()都是向队列尾部插入一个元素，区别是当超出队列界限时，add方法会抛出异常，而offer会返回false.
  2.remove()和poll都是从队列头部移除一个元素并返回，区别是队列为空时remove()方法抛出异常，poll()方法则是返回null值。
  3.element()和peek()都是用于查询队列头部的元素，区别是队列为空时，element抛出一个异常，而peek返回null.
  
  ### 有哪些线程安全的集合类？
  1.Vector,是线程安全的ArrayList,底层用数组实现，通过synchronized修饰方法保证线程安全。
  2.HashTable是线程安全的HashMap,继承自Dictionary,通过synchronized修饰方法保证线程安全。性能较差
  3.ConcurentHashMap,线程安全的HashMap,通过分段锁实现线程安全，性能较好。
  
  ## 集合（补充）
  Java集合类主要由两个接口派生出：Collection和Map，这两个接口是Java集合的根接口。
  
  Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是 Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。
  
  Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。
  
  ### List和Set比较
  List,Set都是继承自Collection接口，Map则不是; List特点：元素有放入顺序，元素可重复; Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法; 
  
  ### List和Vector比较
  Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；
  两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同，Vector可以设置增长因子，而ArrayList不可以。
  
  ## 多线程
  ### 创建线程有哪几种实现方式？分别有什么优缺点？
  1.继承Thread 类，重写run()方法
    优点：编码简单，
    缺点：不能继承其它类
  2.实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。
    优点：可以继承其它类，避免了单继承的局限性；适合多个相同程序代码的线程共享一个资源，实现解耦操作，代码和线程独立。
    缺点：实现相对复杂
  3.实现Callable接口，重写Call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。
    优点:是相比方式二可以获取返回值。
    缺点：实现复杂。
  4.通过线程池创建。
  
  ### 线程有哪些状态
  1.New:用new操作创建一个新线程，此时程序还未开始运行线程中的代码
  2.Runnable: 调用start()方法后进入可运行状态。
  3.Blocked:阻塞状态，内部锁获取失败时进入阻塞状态。
  4.Waiting:等待其他线程唤醒时进入等待状态。
  5.Timed Waiting:计时等待，带超时参数的方法，例如Sleep(Long time)
  6.Terminated:终止状态，线程正常运行完毕或未捕获异常终止。
  
  ### 多线程不可见问题的原因和解决方式？
  1.不可见的原因是每个线程有自己的工作内存，线程都是从主内存拷贝共享变量的副本值。每个线程都是在自己的工作内存操作共享变量的。
  2.解决方式：
    1）加锁:获得锁后线程会清空工作内存，从主内存拷贝共享变量最新的值成为副本，修改后刷新会主内存，再释放锁。
    2）使用volatile关键字：被volatile 修饰的变量会通知其他线程之前读取到的值已失效，线程会加载最新值到自己的工作内存。
    
  ### 什么是线程安全问题，如何解决？
  1.线程安全问题：当多个线程共享一个全局变量，对其做写操作时，可能会受到其他线程的干扰，从而引发线程安全问题
  2.解决方法：
    1）使用内部锁synchronized，可以使用同步代码块，如果是实例方法可用this作为锁对象，如果是静态方法，可以用类.class作为锁，或者使用同步方法底层和同步代码块一样，如果是实例方法默认用this作为锁，如果是静态方法默认使用类.class。
    2）使用java.util.concurrent包中的锁，例如ReentrantLock。
  
  [Java并发编程：synchronized - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3923737.html)
  
  [Java并发编程：Lock - Matrix海子 - 博客园]
  (https://www.cnblogs.com/dolphin0520/p/3923167.html)
  
  ### 说一说volatile关键字的作用
  1.保证被修饰的变量对所有线程可见，在一个线程修改了变量的值后，新的值对于其他线程是可以立即获取的。
  2.禁止指令重排序，被修饰的变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile修饰的变量时总是会返回最新写入的值。
  3.不会执行加锁操作，不会导致线程阻塞，主要适用于一个变量被多个线程共享，多个线程均可对这个变量执行赋值或读取的操作。
  4.④volatile可以严格保证变量的单次读写操作的原子性，但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作。
  
  ### 说一说synchronized关键字的作用
  1.用于为Java对象、方法、代码块提供线程安全的操作，属于排它的悲观锁，也属于可重入锁。
  2.被synchronized修饰的方法和代码块在同一时刻只能有一个线程访问，其他线程只有等待当前线程释放锁资源后才能访问。
  3.Java中的每个对象都有一个monitor监视器对象，加锁就是在竞争monitor，对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方是否加锁是通过一个标记位来判断的。
  
  ### volatile和synchronized的区别？ 
  1.volatile只能修饰实例变量和类变量,而synchronized可以修饰方法以及代码块。
  2.volatile只能保证数据的可见性，但是不保证原子性，synchronized是一种排它机制，可以保证原子性。只有在特殊情况下才适合取代synchronized：对变量的写操作不依赖于当前值（例如i++），或者是单纯的变量赋值；该变量没有被包含在具有其他变量的不等式中，不同的volatile变量不能互相依赖，只有在状态真正独立于程序内的其它内容时才能使用volatile。
  3.cccvolatile是一种轻量级的同步机制，在访问volatile修饰的变量时并不会执行加锁操作，线程不会阻塞，使用synchronized加锁会阻塞线程。
  
  ### 讲一讲ReentrantLock
  1.ReentrantLock是Lock接口的实现类，是一个可重入锁，通过AQS实现。
  2.支持公平锁与非公平锁，还提供了可响应中断锁（线程在等待锁的过程中可以根据需要取消对锁的请求，通过interrupt方法中断）、可轮询锁（通过tryLock获取锁，如果有可用锁返回true否则立即返回false）、定时锁（通过带long时间参数的tryLock方法获取锁，如果在给定时间内获取到可用锁且当前线程未被中断返回true，如果超过指定时间则返回false，如果获取锁时被终断则抛出异常并清除已终止状态）等避免死锁的方法。
  3.通过lock和unlock方法显式地加锁和释放锁。
  
  ### synchronized和ReentrantLock有哪些区别？
  1.synchronized是隐式锁，ReentrantLock是显式锁，使用时必须在finally代码块中进行释放锁的操作。
  2.synchronized是非公平锁，ReentrantLock可以实现公平锁。
  3.ReentrantLock可响应中断，可轮回，为处理锁提高了更多灵活性。
  4.synchronized是一个关键字，是JVM级别，ReentrantLock是一个接口，是API级别。
  5.synchronized采用悲观并发策略，ReentrantLock采用的是乐观并发策略，会先尝试以CAS方式获取锁。
  
  ### Lock接口有哪些方法？
  1.lock()：给对象加锁。
  2.tryLock()/tryLock(long time,TimeUnit unit)：尝试给对象加锁，成功返回true，可以无参也可以指定等待时间。
  3.unlock()：释放锁，锁只能由持有者释放否则抛出异常。
  4.newCondition()：创建条件对象，使用条件对象管理那些已经获得锁但不满足有效条件的线程，调用await()方法把线程进入等待集，调用sign()/signAll()解除阻塞。5.lockInterruptibly()：如果当前线程未被中断则获取该锁。
  
  ### Java中的锁有什么作用？有哪些分类？
  1.Java中的锁主要用于保障多并发情况下数据的一致性，线程必须先获取锁才能进行操作，可以保证数据的安全。
  2.从乐观和悲观的角度可以分为乐观锁和悲观锁。
  3.从获取资源的公平性可以分为公平锁和非公平锁。
  4.从是否共享资源的角度可以分为共享锁和排它锁。
  5.从锁的状态角度可分为偏向锁、轻量级锁和重量级锁。同时在JVM中还设计了自旋锁以更快地使用CPU资源。
  
  ### 讲一讲乐观锁和悲观锁
  1.乐观锁:采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁。但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法，具体过程为：比较当前版本号与上一次的版本号，如果一致则更新，否则重复进行读、比较、写操作。Java中的乐观锁是基于CAS操作实现的，CAS是一种原子性操作，在对数据更新之前先比较当前值和传入的值是否一样，一样则更新否则直接返回失败状态。
  2.悲观锁:采用悲观的思想处理数据，每次读取数据时都认为别人会修改数据，所以每次都会上锁，其他线程将被阻塞。Java中的悲观锁基于AQS实现，该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到则会转为悲观锁。
  
  ### 讲一讲自旋锁
  1.自旋锁认为如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等待小段时间，在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致锁时间消耗。
  2.优点：减少CPU的上下文切换，对于占用锁时间非常短或锁竞争不激烈的代码块来说性能很高。
  3.缺点：在持有锁的线程长时间占用锁或竞争过于激烈时，线程会长时间自旋浪费CPU资源，有复杂锁依赖的情况不适合使用自旋锁。
  
  ### 讲一讲公平锁与非公平锁
  1.公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给排队时间最长的线程。
  2.非公平锁指在分配锁时不考虑线程排队等待的情况，直接尝试获取锁，获取不到锁就在排到队尾等待。
  3.因为公平锁需要在多核情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁，ReentrantLock默认的lock方法也是非公平锁。
  
  ### 讲一讲读写锁
  1.Lock接口提供的锁是普通锁，为了提高性能Java提供了读写锁，读写锁分为读锁和写锁，读锁之间不互斥，读锁与写锁，写锁之间都互斥。
  2.如果系统要求共享数据可以同时支持很多线程并发读，但不能支持很多线程并发写，那么读锁能大大提高效率。如果系统要求共享数据在同一时刻只能有一个线程在写，且写的过程中不能读，则需要使用写锁。
  3.提高juc的locks包中ReadWriteLock的实现类ReentrantReadWriteLock的readLock()和writeLock()来分别获取读锁和写锁。
  
  ### 讲一讲共享锁与排它锁
  1.共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。
  2.排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。
  3.排它锁是一种悲观的加锁策略，同一时刻只允许一个线程读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。
  
  ### 锁有哪些状态？
  1. 无锁，偏向锁，轻量级锁和重量级锁。
  2. 重量级锁是基于操作系统互斥量实现的，会导致进程在用户态和内核态之间来回切换，开销较大，synchronized内部基于监视器实现，监视器基于底层操作系统实现，因此属于重量级锁，运行效率不高。JDK1.6后为了减少获取锁和释放锁带来的性能消耗提高性能，引入了轻量级锁和偏向锁。
  3. 轻量级锁是相对于重量级锁而言的，核心设计实在没有多线程竞争的前提下，减少重量级锁的使用来提高性能。适用于线程交替执行同步代码块的情况，如果同一时刻有多线程访问同一个锁，会导致轻量级锁膨胀成重量级锁。
  4. 偏向锁用于在某个线程获取某个锁后，消除这个线程锁重入的开销，看起来似乎是这个线程得到了锁的偏袒。偏向锁的主要目的是在同一个线程多次获取某个所的情况下尽量减少轻量级锁的执行路径，因为轻量级锁需要多次CAS操作，而偏向锁只需要切换ThreadID时执行一次CAS操作，提高效率。出现多线程竞争锁时，JVM会自动撤销偏向锁。偏向锁是进一步提高轻量级锁性能的。
  5. 随着锁竞争越来越严重，锁可能从偏向锁升级到轻量级锁再到重量级锁，但在Java中只会单向升级不会降级。
  
  ### 如何进行锁优化？
  1.减少锁持有的时间：只在有线程安全要求的程序上加锁来尽量减少同步代码块对锁的持有时间。
  2.减小锁粒度：将单个耗时较多的锁操作拆分为多个耗时较少的锁操作来增加锁的并行度，减少同一个锁上的竞争。在减少锁的竞争后，偏向锁、轻量级锁的使用率才会提高，例如ConcurrentHashMap中的分段锁。
  3.读分离：指根据不同的应用场景将锁的功能进行分离以应对不同的变化，最常见的锁分离思想就是读写锁，这样既保证了线程安全又提高了性能。
  4.锁粗化：指为了保障性能，会要求尽可能将锁的操作细化以减少线程持有锁的时间，但如果锁分的太细反而会影响性能提升，这种情况下建议将关联性强的锁操作集中处理。
  5.锁消除：注意代码规范，消除不必要的锁来提高性能。
  
  ### 线程池是什么？为什么需要线程池
  1.在生产中为每一个任务创建一个线程存在一些缺陷，如果无限制地大量创建线程会消耗很多资源，影响系统稳定性和性能，产生内存溢出等问题。
  2.线程池是管理一组同构工作线程的资源池，线程池与工作队列密切相关，工作队列中保存了所有需要等待执行的任务。工作线程的任务很简单，从工作队列获取任务，执行任务，返回线程池并等待下一次任务。
  3.线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销，另一个好处是当请求到达时工作线程通常已经存在，不会出现等待线程而延迟任务的执行，提高了响应性。通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。
  
  ### 创建线程池时，ThreadPoolExecutor构造器中都有哪些参数，有什么含义?
  1.corePoolSize： 线程池核心大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。
  2.maximumPoolSize： 线程池最大大小，表示可同时活动的线程数量的上限。
  3.keepAliveTime：存活时间，如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过基本大小时，这个线程将被终止。
  4.unit： 存活时间的单位，可选的参数为TimeUnit枚举中的几个静态变量： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。
  5.workQueue： 线程池所使用的阻塞队列。
  6.thread factory：线程池使用的创建线程工厂方法，可省略，将使用默认工厂。
  7.handler：所用的拒绝执行处理策略，可省略，将使用默认拒绝执行策略。
  
  ### 创建线程池的方法有哪些？
  可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。
  1.newFixedThreadPool:
  作用：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。
  
  特征： 
  （1）线程池中的线程处于一定的量，可以很好的控制线程的并发量 
  （2）线程可以重复被使用，在显示关闭之前，都将一直存在 
  （3）超出一定量的线程被提交时候需在队列中等待
  
  创建方式： 
  （1）Executors.newFixedThreadPool(int nThreads)；//nThreads为线程的数量 
  （2）Executors.newFixedThreadPool(int nThreads，ThreadFactory threadFactory)；//nThreads为线程的数量，threadFactory创建线程的工厂方式'
  
  2.newCachedThreadPool:
  作用：创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。
  
  特征： 
  （1）线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） 
  （2）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟） 
  （3）当线程池中，没有可用线程，会重新创建一个线程
  
  创建方式： Executors.newCachedThreadPool();
  
  3.newSingleThreadExecutor:
  作用：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。
  
  特征： 
  （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行
  
  创建方式： 
  （1）Executors.newSingleThreadExecutor() ； 
  （2）Executors.newSingleThreadExecutor(ThreadFactory threadFactory)；// threadFactory创建线程的工厂方式
  
  4.newScheduledThreadPool:
  作用： 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
  
  特征： 
  （1）线程池中具有指定数量的线程，即便是空线程也将保留 
  （2）可定时或者延迟执行线程活动
  
  创建方式： 
  （1）Executors.newScheduledThreadPool(int corePoolSize)；// corePoolSize线程的个数 
  （2）newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)；// corePoolSize线程的个数，threadFactory创建线程的工厂
  
  5.newSingleThreadScheduledExecutor
  作用： 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。
  
  特征： 
  （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行 
  （2）可定时或者延迟执行线程活动
  
  创建方式： 
  （1）Executors.newSingleThreadScheduledExecutor() ； 
  （2）Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) ；//threadFactory创建线程的工厂
  
  
  ### 线程池的工作原理？
  [Java并发编程：线程池的使用 - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3932921.html)
  
  ### Executor 与Executors的区别
  1.Executor 接口对象能执行我们的线程任务；
  2.Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。
  ExecutorService 接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能够获得任务执行的状态并且可以获取任务的返回值。
  
  ### 简述ExecutorService的生命周期
  1.ExecutorService的生命周期有3种状态：运行、关闭和已终止。
  2.ExecutorService在初始创建时处于运行状态。
  3.shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。在ExecutorService关闭后提交的任务将有“拒绝执行处理器REH”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。
  4.等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已终止。通常在调用awaitTermination后会理解调用shutdown，从而产生同步地关闭ExecutorService的效果。
  
  ### 什么是CAS?
  1.CAS指Compare And Swap，比较并交换。CAS(V,E,N)算法包括三个参数，V表示要更新的变量的值，E表示预期的值，N表示新值。在且仅在V的值和E相等时才会将V的值设置为N，如果不同则说明已经有其他线程做了更改，当前线程就什么也不做。最后CAS返回当前V的真实值。
  2.CAS操作采用了乐观锁的思想，有多个线程同时使用CAS操作一个共享变量时只有一个线程会成功，失败的线程不会被挂起仅会被告知失败，并且允许再次尝试，或者放弃操作。基于这样的原理虽然CAS没有使用锁，也可以及时发现其他线程的操作进行适当地并发处理。
  
  ### CAS有什么问题？ 
  1.CAS算法地实现有一个重要前提：需要取出内存中某时刻的数据，然后在下一刻进行比较、替换，但在这个时间差内数据可能已经发生了变化，导致ABA问题。
  
  ### ABA是什么问题？
  ABA问题指线程1从内存V位置取出A，这时线程2也从内存中取出A，并将其首先修改为B，接着又修改为A，这时线程1在进行CAS操作时会发现内存中数据仍是A，然后线程1操作成功。尽管从操作角度来说线程1成功了，但是在该过程中实际上数据已发生了变化但并未被感知到，某些应用场景下可能会出现数据不一致的问题。
  
  ### 如何解决ABA问题。
  乐观锁通过版本号来解决ABA问题，具体的操作是每次执行数据修改操作时都会带上一个版本号，如果预期版本号和数据版本号一致就进行操作，并将版本号加1，否则执行失败。
  
  ### 讲一讲wait、sleep、yield、join方法的区别
  1.wait是Object类的方法，调用wait方法的线程会进入WAITING状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法释放锁资源。
  2.sleep是Thread类的方法，调用sleep方法导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是TIMED-WAITING状态。
  3.yiled是Thread类的方法，yiled方法使当前线程让出CPU时间片给优先级相同或更高的线程，回到RUNNABLE状态，与其他线程一起重新竞争CPU时间片。
  4.join是Thread累的方法，join方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的join方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。
  
  ### 什么是守护线程？
  1.守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。守护线程不依赖于终端，但是依赖于JVM，当JVM中仅剩下守护线程时，JVM就会退出。
  2.通过setDaemon方法定义一个守护线程，守护线程的优先级较低，将一个用户线程设置为守护线程必须要在启动守护线程之前。
  
  ### start和run方法的区别？
  1.start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。
  2.run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。
  
  
  ## JVM
  ### 类加载器的原理
  程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。
  
  ### JVM中类加载的过程（机制）？
  虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型
  [深入浅出Java类加载过程 - 神仙果 - 博客园](https://www.cnblogs.com/luohanguo/p/9469851.html)
  ![14265221-905453ee556fc809.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bf372989.png)
  #### 加载
  1.java虚拟机将.class文件读入内存，并为之创建一个class对象。
  2.任何类被使用时系统都会为其创建一个且仅有一个class对象。
  3.这个class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。
  ![1272523-20180813175012975-888131295.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\0230423b.png)
  
  #### 链接
  将java类的二进制代码合并到JVM的运行状态之中。
  
  验证:验证class文件的字节流是否符合jvm规范,确保加载的类信息符合jvm规范，没有安全方面的
  
  准备:正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。而此时的设置初始值为默认值，具体赋值在初始化阶段完成。
  
  解析:虚拟机常量池内的符号引用替换为直接引用的过程。
  
  #### 初始化
  主要对类变量进行初始化，执行类构造器的过程，仅仅对static修饰的变量或者语句进行初始化。
  例Person person=new Person();
  1. 找到class文件，将它加载到内存
  2. 在堆内存中分配内存地址
  3. 初始化
  4. 将堆内存地址指给栈内存中的p变量
  
  **初始化顺序**
  1、父类的静态变量
  2、父类的静态代码块
  3、子类的静态变量
  4、子类的静态代码块
  5、父类的非静态变量
  6、父类的非静态代码块
  7、父类的构造方法
  8、子类的非静态变量
  9、子类的非静态代码块
  10、子类的构造方法
  
  ### 类加载器的分类
  ![14265221-549d6e3ca7ab0b5a.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bb6f8847.png)
  #### 引导类加载器(bootstrap class loader)
  （1）它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自java.lang.ClassLoader。
  （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。
  
  #### 扩展类加载器(extensions class loader)
  （1）用来加载 Java 的扩展库(JAVA_HOME/jre/ext/* .jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
  （2）由sun.misc.Launcher$ExtClassLoader实现。
  
  #### 应用程序类加载器(application class loader)
  （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
  （2）由sun.misc.Launcher$AppClassLoader实现。
  
  #### 自定义类加载器
  （1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。
  
  ### 类加载器的代理模式
  代理模式即是将指定类的加载交给其他的类加载器（类加载器之间的层次关系）。常用双亲委托机制。
  #### 双亲委托机制
  某个特定的类加载器接收到类加载的请求时，会将加载任务委托给自己的父类，直到最高级父类引导类加载器（bootstrap class loader），如果父类能够加载就加载，不能加载则返回到子类进行加载。如果都不能加载则报错。ClassNotFoundException
  ![2019062814264974.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\90ad5fee.png)
  
  #### 为什么使用双亲委托模型
  使得java类随着它的类加载器一起具有一种带有优先级的层级关系，从而使得基础类得到统一。
  例如：例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。
  
  
  ## java类的引用于对象引用
  [JAVA类加载过程&主动引用和被动引用](https://www.baidu.com/link?url=ZaJO63OX4cc1VaIpQzrwvVJeltj2MMT179nj_yaFwtEF7-7K8IIrPTqjXY7PlHYR&wd=&eqid=b9cda6fb0010d68b000000045da6939f)
  ### 主动引用
  #### 碰到如下四种情况才会触发主动引用：
  1. 使用new关键字实例化对象(new)
  2. 读取类的静态成员变量(getstatic)
  3. 设置类的静态成员变量(setstatic)
  4. 调用静态方法(invokestatic)
  #### 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
  通过调用java.lang.Class.forName(String className) 
  #### 当初始化一个类的时候，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。
  #### 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
  
  ### 被动引用
  #### 通过子类引用父类的静态字段，不会导致子类初始化
  #### 通过数组定义来引用，不会触发此类的初始化
  #### 常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量初始化
  
  ### java对象引用
  [Java中四种引用 - 张界 - 博客园](https://www.cnblogs.com/pascall/p/10281775.html)
  #### 强引用
  如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
  ```
  String str = "hello";    // 强引用
  str = null;              // 取消强引用
  ```
  #### 软引用
  在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。
  ```
  SoftReference<String> softName = new  SoftReference<>("张三");
  ```
  #### 弱引用
  具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。
  ```
  WeakReference<String> weakName = new WeakReference<String>("hello");
  ```
  #### 虚引用
  如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
  虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
  ```
  ReferenceQueue<String> queue = new ReferenceQueue<String>();
  PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
  ```
  
  
  ## GC机制
  ### GC概括
  Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。
  
  ### 检测出垃圾方法
  #### 引用计数法
  给每个对象添加引用计数器，每个地方引用它，计数器就+1，失效时-1。如果两个对象互相引用时，就导致无法回收。 
  #### 可达性分析算法
  以根集对象为起始点进行搜索，如果对象不可达的话就是垃圾对象。根集（Java栈中引用的对象、方法区中常量池中引用的对象、本地方法中引用的对象等。JVM在垃圾回收的时候，会检查堆中所有对象是否被这些根集对象引用，不能够被引用的对象就会被垃圾回收器回收。）
  ### 垃圾回收算法
  #### 标记-清楚
  标记：首先标记所有需要回收的对象，在标记完成之后统计回收所有被标记的对象，它的标记过程即为上面的可达性分析算法。 清除：清除所有被标记的对象 缺点： 效率不足，标记和清除效率都不高 空间问题，标记清除之后会产生大量不连续的内存碎片，导致大对象分配无法找到足够的空间，提前进行垃圾回收。
  #### 复制回收算法
  将可用的内存按容量划分为大小相等的2块，每次只用一块，当这一块的内存用完了，就将存活的对象复制到另外一块上面，然后把已使用过的内存空间一次清理掉。
  #### 标记-整理
  在老年代的对象大都是存活对象，复制算法在对象存活率教高的时候，效率就会变得比较低。根据老年代的特点，有人提出了“标记-压缩算法(Mark-Compact)”
  标记过程与标记-清除的标记一样，但后续不是对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。
  这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
  #### 分带收集算法
  根据对象存活的周期不同将内存划分为几块，一般是把Java堆分为老年代和新生代，这样根据各个年代的特点采用适当的收集算法。
  
  新生代每次收集都有大量对象死去，只有少量存活，那就选用复制算法，复制的对象数较少就可完成收集。 老年代对象存活率高，使用标记-压缩算法，以提高垃圾回收效率。
  
  ## 6、常量池
  ### 6.1 Integer中的128(-128~127)
  当数值范围为-128~127时：如果两个new出来Integer对象，即使值相同，通过“==”比较结果为false，但两个对象直接赋值，则通过“==”比较结果为“true，这一点与String非常相似。 
  当数值不在-128~127时:无论通过哪种方式，即使两个对象的值相等，通过“==”比较，其结果为false； 当一个Integer对象直接与一个int基本数据类型通过“==”比较，其结果与第一点相同；
  ### 6.2 为什么是-128~127
  在Integer类中有一个静态内部类IntegerCache，在IntegerCache类中有一个Integer数组，用以缓存当数值范围为-128~127时的Integer对象。
  
  ## 文献
  [【7万字干货】2021Java实习必看面试两百题解析_资源分享_牛客网](https://www.nowcoder.com/discuss/395523?type=0&order=0&pos=16&page=0)
  
  [Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/)
'''
linesHighlighted: [
  174
  470
]
isStarred: false
isTrashed: false
