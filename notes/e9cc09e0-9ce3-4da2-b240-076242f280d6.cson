createdAt: "2019-10-16T02:39:38.018Z"
updatedAt: "2020-08-14T03:18:55.473Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Java面试题"
tags: []
content: '''
    # Java面试题
  [TOC]
  ## 1、基础语法
  
  ### 字符串拼接的方式以及效率
  1. 使用+直接拼接，String 是final对象，不会被修改，每次使用+进行拼接都会创建新的对象，而不是改变原来的对象，效率低，是线程安全的。
  2. 使用StringBuffer可变字符串，是线程安装的（StringBuffer的方式使用了Synchronized关键字进行修饰）。
  3. 使用StringBuilder可变字符串，效率最高，但是线程不安全。
  
  ### 简述final,finally和finalize区别
  1. final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方式不可重写，被final修饰的变量引用不可变，引用的内容可以更改。
  2. finally用于try-catch 代码块中，无论是否发生异常最后都将被执行，作用是释放资源。
  3. finalize 是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。
  
  ### ==和equals有什么区别?equals和hashCode有什么联系
  1. 如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。
  2. 如果没有重写的话，equals默认按照==进行比较，如果重写了equals() 方法，则按照对应的比较规则比较。
  3. 两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。
  理解：
  如果是Integer类的hashcode返回的是值比较，对象不一定相同 √
  如果是String类的hashcode 值是算法计算出来的，有可能导致hashcode值相同的情况，两个对象不一定相同 √
  
  ### Array和ArrayList的区别
  1.Array长度在定义之后就不运行改变了，而ArrayList是长度可变的，可以自动化扩容。
  2.Array只能存储相同类型的数据，ArrayList可以存储不同类型的数据。
  3.ArrayList提供了更多操作数据的方法。
  
  ### 简述JDK8的新特性
  1.接口中可以添加default修饰的非抽象方法，可以有方法和内容。
  2.可以使用lambda表达式，减少代码冗余
  3.函数式接口，使用@Functionalinterface注解标明，该接口有且仅有一个抽象方法。
  4.方法引用，可以直接引用已有java类或对象的方法或构造器，进一步简化lambda表达式，
  5.stream流，用于解决已有集合/数组类库的弊端，简化其操作，有foreach遍历，filter过滤，map映射，concat合并等功能。
  6.增加日期相关的API
  
  ### Stream流
  1.Stream流是JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。
  2.Stream流的获取
    1）集合：直接调用Stream()方法获取
    2）数组：使用静态方法Stream.of()/Arrays.stream()获取
  3.常用方法
    1)forEach()遍历
    2)count()统计个数
    3)filter()按条件过滤
    4)limit()取前面n个元素
    5)skip()跳过前面n个元素
    6)map()映射加工
    7)concat()合并stream流
  4.终结方法
    foreach/count调用终结方法后流不能继续使用
  5.非终结方法
    每次调用完返回一个新的Stream对象，可以继续使用。
  6.收集Stream流
    1）把流转为Set集合 collect(Collections.toSet())
    2) 把流转为List集合 collect(Collections.toList())
    3) 把流转为Collection集合 collect(Collections.toCollection())
    4) 把流转为数组toArray()
  
  ## 面向对象
  
  ### 简述面向对象的特性
    1）封装：建议成员变量私有，然后提供公有的getter/setter方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露。可以提高安全性，实现代码的组件化
    2）继承：一种子类到父类的关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。
    3) 多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，右边对象可以实现组件化切换，业务功能随之改变，便于扩展和维护。
  ### 列举Object类的方法
     1）equals(Object obj):判断其他对象是否与当前对象相等。
     2）toString():打印当前对象的字符串表示
     3) wait():导致当前线程等待，等待其它线程唤醒，会释放锁。
     4) notify()/notifyAll():随机唤醒一个/全部线程
     5) hashCode():返回当前对象的hashCode值。
     6) finalize():当垃圾回收期要回收对象前调用。
     7) clone:创建并返回对象的一个副本.
  ### 接口和抽象类有什么区别
    1）接口中只能定义public static final 修饰的常量，抽象类中可以定义普通变量。
    2）接口和抽象类都不能实例化，但接口没有构造器，抽象类有构造器。
    3）接口可以多实现，抽象类只能单集成。
    4）接口在JDK1.8之前只能定义public abstract修饰的方法，JDK1.8开始可以定义默认方法和静态方法，JDK1.9开始可以定义私有方法，抽象类中的方法没有限制。
    
  ### 什么时候应该使用接口，什么时候应该使用抽象类
    1）如果知道某个类应该成为基类，那么第一选择应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。
    2）在接口和抽象类的选择上，必须遵守：行为模型应该总是通过接口而不是抽象类定义。又由于java不允许多继承，最好是选择接口去实现。
    
  ### 内部类有什么作用？有哪些分类？
    Q1.内部类有更好的封装性，有更多的权限修饰符，封装性可以得到更多的控制。
    Q2.内部类的分类
        1）静态内部类：由于static修饰，属于类本身，只加载一次。类可以定义的成分，静态内部类都可以定义。可以访问外部类的静态变量和方法，
        通过new外部类，静态内部类构造器，来创建对象。
        2）成员内部类：属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过new 外部类构造器.静态内部类构造器来创建对象。
        3）局部内部类：定义在方法、构造器、代码块、循环中。只能定义实例成员变量和实例方法，作用范围仅在局部代码块中。
        4）匿名内部类：没有名字局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，对象类型相当于当前new的子类类型。
  
  ### 泛型和泛型擦除
    1.泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制运行程序在编译时检测非法的类型。
    2.在编译阶段采用泛型时带上类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除。因此泛型主要用于编译阶段，在编译后生成的java字节代码文件中不包含泛型中的类型信息。
  
  ### 泛型标记的规范
    1.Element,在集合中使用，表示在集合中存放的元素
    2.指Type,表示java类，包括基本的类以及自定义类
    3.指Key,表示键，例如Map集合中的key.
    4.指value,表示值，例如Map集合中的Value
    5.指Number,表示数值类型.
    6.?，表示不确定的java类型
  
  ### 泛型限定是什么
    1.类型通配符使用？表示所有具体的参数类型，在使用泛型的时候，如果希望将类的继承关系加入泛型应用中就需要对泛型做限定，具体的泛型限定有对泛型上限的限定以及对泛型下限的限定。
    2.对泛型上限限定使用</?extends T>它表示该通配符所代表的类型是T类的子类型或T接口的子接口。
    3.对泛型下限的限定使用</?super T>它表示该通配符所代表的的类型是T类的父类型或T接口的父接口。
  
  ## 异常
  
  ### java异常类层次结构图
  
  ![Exception.png](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)
  在java中，所有的异常都有一个共同的祖先java.lang包中的Throwable类。Throwable:有两个重要的子类：Exception(异常)和Error（错误）,二者都是java异常处理的重要子类，各自都包含大量子类。
  
  异常和错误的区别：异常能被程序本身处理，错误是无法处理。
  
  ### 异常有哪些分类？出现的原因是什么？
  1.Throwable是所有错误和异常的父类,Throwable分为Error和Exception.
  2.Error指Java程序运行错误。出现Error通常是因为系统的内容部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error, 系统只能记录错误的原因和安全终止。
  3.Exception指java程序运行异常，即运行中发生了不期望的情况，分为RuntimeException和CheckedException.RuntimeException指在Java 虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。CheckedException指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。
  
  ### 有哪些异常处理方式?
  1.抛出异常:遇到异常不进行具体处理，而是将异常抛出给调用者，由调用者根据情况处理。抛出异常有2种形式，一种是throws,作用在方法上，一种是Throw,作用在方法内。
  2.使用trycatch进行异常的捕获处理，try中发生的异常会被catch代码块捕获，根据情况进行处理，如果有finally代码块无论是否发生异常都会执行，一般用于释放资源，JDK1.7开始可以将资源定义在try代码块中自动释放减少代码。
  
  
  ### Error(错误)
  Error(错误)：是程序无法处理的错误，表示运行应用程序中较严重问题，大多数错误与代码编写者执行的操作无关，而表示代码运行时JVM(java虚拟机)出现的问题。
  例如，java虚拟机运行错误（Virtual Machine Error）,当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM)一般会选择线程终止。
  
  这些错误表示故障发生于虚拟机自身，或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该视图去处理它所引起的异常状况。在java中，错误通过Error的子类描述。
  
  ### Exception(异常)
  Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。
  
  ### Throwable类常用方法
  
  - **public string getMessage()**:返回异常发生时的简要描述
  - **public string toString()**:返回异常发生时的详细信息
  - **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
  - **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息
  
  ### 异常处理总结
  
  - **try 块：** 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
  - **catch 块：** 用于处理try捕获到的异常。
  - **finally 块：** 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return
  语句时，finally语句块将在方法返回之前被执行。
  
  **在以下4种特殊情况下，finally块不会被执行：**
  
  1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
  2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
  3. 程序所在的线程死亡。
  4. 关闭CPU。
  
  下面这部分内容来自issue:<https://github.com/Snailclimb/JavaGuide/issues/190>。
  
  **注意：** 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：
  
  ```java
      public static int f(int value) {
          try {
              return value * value;
          } finally {
              if (value == 2) {
                  return 0;
              }
          }
      }
  ```
  如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。
  
  ## 集合
  ### 简述一下集合主要有哪些类和接口，各自有什么特点。
  1.主要有两个接口Collection和Map.
  2.Collection包括List,Set和Queue
    1）List是有序的，主要包括ArrayList，LinkedList和Vector，ArrayList底层通过数组实现，线程不安全，Vector是线程安全的ArrayList，但效率较低，LinkedList底层通过双向链表实现，与ArrayList相比增删快查询慢。
    2) Set是唯一且无序的，主要包括HashSet，LinkedHashSet和TreeSet。HashSet底层其实就是HashMap，利用了key来保证元素的唯一性。LinkedHashSet可以按照key的操作顺序排序，TreeSet支持按照默认或指定的排序规则排序。
    3) Queue是队列结构，主要有ArrayBlockingQueue基于数组的阻塞队列、LinkedBlockingQueue基于链表的阻塞队列等
  3.Map以key-value键值对的形式存储元素,包括：HashMap、LinkedHashMap和TreeMap。
    1）HashMap底层通过数组+链表/红黑树实现
    2）LinkedHashMap可以按照key的操作顺序对集合排序
    3）TreeMap可以按照默认或指定的排序规则对集合排序
  
  ### HashMap是线程安全吗？
  1.HashMap是线程不安全的，可以使用ConcurrentHashMap保证线程安全。
  2.ConcurrentHashMap基于减小锁粒度的思想，通过使用分段锁来实现线程安全，内部细分为很多Segment数据段，默认情况下为16个，对每个Segment的数据都单独进行加锁操作，Segment的个数为锁的并发度。ConcurrentHashMap是由Segment数组和HashEntry数组组成的，Segment继承了可重入锁，HashEntry用来存储键值对数据。
  3.Segment的结构和HashMap类似，是数组和链表结构，每个Segment里面都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据要对其进行i修改必须先获得对应的Segment锁。
  4.多线程下只要加入的数据hashCode映射的数据段不一样就可以做到并行的线程安全。
  
  ### List,Set,Map有什么区别？
  1.List是有序，可重复，有索引的集合，继承了Collection集合全部功能除了Collection的三种遍历方式外，可用索引遍历。
  2.Set是无序，不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或者自定义的比较规则排序。
  [Java中的Set总结 - 简书](https://www.jianshu.com/p/d6cff3517688)
  
  3.Map是无序，以Key-value的键值对形式存储元素的集合。键不可重复，值无需求，重复的键对应的值会覆盖之前的值。
  
  ### HashSet是如何去重的？
  1.对于基本类型的包装类，可以直接按值进行比较。
  2.对于引用数据类型，会先比较HashCode()返回值是否相同，如果不同则代表不是同一个对象。如果相同继续比较equals（） 方法返回值是否相同，都相同说明是同一个对象。
  3.如果希望内容相同的对象就代表对象相同，那么除了重写equals()方法还要重写hashCode()方法，因为内容相同的对象hashCode()值不一定相同，因为只有hashCode()和equals()都相同才说明是同一个对象。
  
  ### HashMap和HashSet的底层是怎么实现的？
  1.JDK1.8之前，HashMap的底层是数组加链表实现。数组中的每个元素都是一个单链表，链表中的每个元素都是Entry的实现类Node的一个实例，Node包括4个属性：key,value,hash值和用于指向单链表下一个元素的next.
  2.HashMap在查找数据时，根据hash值可以快速定位到数组的具体下标，然后对链表进行遍历查找数据的时间复杂度为O(n)
  3.JDK1.8之后， HashMap底层改为数组+链表或红黑树，当链表中的元素超过8个之后，HashMap会将链表结构转换未红黑树以提高查询效率，时间复杂度为O(logn)。
  4.HashSet的底层是基于HashMap实现的，HashSet中的元素只是存放在了底层HashMap的key上， 而value使用一个static final的Object对象标识。因此HashSet 的实现比较简单，相关操作基本上都是直接调用底层HashMap的相关方法来完成的。
  
  ### Collection和Collections有什么区别
  1.Collection是一个集合接口，它包括List有序结合，Set无序集合，Queue队列等。
  2.Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll 可以直接对Collection集合批量的添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或按比较器进行排序。
  
  ### 迭代器是什么？
  1.迭代器实现了iterator接口，是用于遍历Collection集合元素的一个指针。
  2.主要有三个方法
    1）通过iterator()获得集合的迭代器
    2）通过hasNext()判断集合当中是否还有元素，如果有返回true,没有则返回false. 初始化迭代器位于第一个元素之前。
    3）通过next()获取集合的下一个元素，并向后移动一个元素的单位。
  
  ### Queue接口中add()/offer(),remove()/poll(),element()/peek()方法有什么区别？
  1.add()和offer()都是向队列尾部插入一个元素，区别是当超出队列界限时，add方法会抛出异常，而offer会返回false.
  2.remove()和poll都是从队列头部移除一个元素并返回，区别是队列为空时remove()方法抛出异常，poll()方法则是返回null值。
  3.element()和peek()都是用于查询队列头部的元素，区别是队列为空时，element抛出一个异常，而peek返回null.
  
  ### 有哪些线程安全的集合类？
  1.Vector,是线程安全的ArrayList,底层用数组实现，通过synchronized修饰方法保证线程安全。
  2.HashTable是线程安全的HashMap,继承自Dictionary,通过synchronized修饰方法保证线程安全。性能较差
  3.ConcurentHashMap,线程安全的HashMap,通过分段锁实现线程安全，性能较好。
  
  ## 集合（补充）
  Java集合类主要由两个接口派生出：Collection和Map，这两个接口是Java集合的根接口。
  
  Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是 Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。
  
  Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。
  
  ### List和Set比较
  List,Set都是继承自Collection接口，Map则不是; List特点：元素有放入顺序，元素可重复; Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法; 
  
  ### List和Vector比较
  Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；
  两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同，Vector可以设置增长因子，而ArrayList不可以。
  
  ## 多线程
  ### 创建线程有哪几种实现方式？分别有什么优缺点？
  1.继承Thread 类，重写run()方法
    优点：编码简单，
    缺点：不能继承其它类
  2.实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。
    优点：可以继承其它类，避免了单继承的局限性；适合多个相同程序代码的线程共享一个资源，实现解耦操作，代码和线程独立。
    缺点：实现相对复杂
  3.实现Callable接口，重写Call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。
    优点:是相比方式二可以获取返回值。
    缺点：实现复杂。
  4.通过线程池创建。
  
  ### 线程有哪些状态
  1.New:用new操作创建一个新线程，此时程序还未开始运行线程中的代码
  2.Runnable: 调用start()方法后进入可运行状态。
  3.Blocked:阻塞状态，内部锁获取失败时进入阻塞状态。
  4.Waiting:等待其他线程唤醒时进入等待状态。
  5.Timed Waiting:计时等待，带超时参数的方法，例如Sleep(Long time)
  6.Terminated:终止状态，线程正常运行完毕或未捕获异常终止。
  
  ### 多线程不可见问题的原因和解决方式？
  1.不可见的原因是每个线程有自己的工作内存，线程都是从主内存拷贝共享变量的副本值。每个线程都是在自己的工作内存操作共享变量的。
  2.解决方式：
    1）加锁:获得锁后线程会清空工作内存，从主内存拷贝共享变量最新的值成为副本，修改后刷新会主内存，再释放锁。
    2）使用volatile关键字：被volatile 修饰的变量会通知其他线程之前读取到的值已失效，线程会加载最新值到自己的工作内存。
    
  ### 什么是线程安全问题，如何解决？
  1.线程安全问题：当多个线程共享一个全局变量，对其做写操作时，可能会受到其他线程的干扰，从而引发线程安全问题
  2.解决方法：
    1）使用内部锁synchronized，可以使用同步代码块，如果是实例方法可用this作为锁对象，如果是静态方法，可以用类.class作为锁，或者使用同步方法底层和同步代码块一样，如果是实例方法默认用this作为锁，如果是静态方法默认使用类.class。
    2）使用java.util.concurrent包中的锁，例如ReentrantLock。
  
  [Java并发编程：synchronized - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3923737.html)
  
  [Java并发编程：Lock - Matrix海子 - 博客园]
  (https://www.cnblogs.com/dolphin0520/p/3923167.html)
  
  ### 说一说volatile关键字的作用
  1.保证被修饰的变量对所有线程可见，在一个线程修改了变量的值后，新的值对于其他线程是可以立即获取的。
  2.禁止指令重排序，被修饰的变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile修饰的变量时总是会返回最新写入的值。
  3.不会执行加锁操作，不会导致线程阻塞，主要适用于一个变量被多个线程共享，多个线程均可对这个变量执行赋值或读取的操作。
  4.④volatile可以严格保证变量的单次读写操作的原子性，但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作。
  
  ### 说一说synchronized关键字的作用
  1.用于为Java对象、方法、代码块提供线程安全的操作，属于排它的悲观锁，也属于可重入锁。
  2.被synchronized修饰的方法和代码块在同一时刻只能有一个线程访问，其他线程只有等待当前线程释放锁资源后才能访问。
  3.Java中的每个对象都有一个monitor监视器对象，加锁就是在竞争monitor，对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方是否加锁是通过一个标记位来判断的。
  
  ### volatile和synchronized的区别？ 
  1.volatile只能修饰实例变量和类变量,而synchronized可以修饰方法以及代码块。
  2.volatile只能保证数据的可见性，但是不保证原子性，synchronized是一种排它机制，可以保证原子性。只有在特殊情况下才适合取代synchronized：对变量的写操作不依赖于当前值（例如i++），或者是单纯的变量赋值；该变量没有被包含在具有其他变量的不等式中，不同的volatile变量不能互相依赖，只有在状态真正独立于程序内的其它内容时才能使用volatile。
  3.cccvolatile是一种轻量级的同步机制，在访问volatile修饰的变量时并不会执行加锁操作，线程不会阻塞，使用synchronized加锁会阻塞线程。
  
  ### 讲一讲ReentrantLock
  1.ReentrantLock是Lock接口的实现类，是一个可重入锁，通过AQS实现。
  2.支持公平锁与非公平锁，还提供了可响应中断锁（线程在等待锁的过程中可以根据需要取消对锁的请求，通过interrupt方法中断）、可轮询锁（通过tryLock获取锁，如果有可用锁返回true否则立即返回false）、定时锁（通过带long时间参数的tryLock方法获取锁，如果在给定时间内获取到可用锁且当前线程未被中断返回true，如果超过指定时间则返回false，如果获取锁时被终断则抛出异常并清除已终止状态）等避免死锁的方法。
  3.通过lock和unlock方法显式地加锁和释放锁。
  
  ### synchronized和ReentrantLock有哪些区别？
  1.synchronized是隐式锁，ReentrantLock是显式锁，使用时必须在finally代码块中进行释放锁的操作。
  2.synchronized是非公平锁，ReentrantLock可以实现公平锁。
  3.ReentrantLock可响应中断，可轮回，为处理锁提高了更多灵活性。
  4.synchronized是一个关键字，是JVM级别，ReentrantLock是一个接口，是API级别。
  5.synchronized采用悲观并发策略，ReentrantLock采用的是乐观并发策略，会先尝试以CAS方式获取锁。
  
  ### Lock接口有哪些方法？
  1.lock()：给对象加锁。
  2.tryLock()/tryLock(long time,TimeUnit unit)：尝试给对象加锁，成功返回true，可以无参也可以指定等待时间。
  3.unlock()：释放锁，锁只能由持有者释放否则抛出异常。
  4.newCondition()：创建条件对象，使用条件对象管理那些已经获得锁但不满足有效条件的线程，调用await()方法把线程进入等待集，调用sign()/signAll()解除阻塞。5.lockInterruptibly()：如果当前线程未被中断则获取该锁。
  
  ### Java中的锁有什么作用？有哪些分类？
  1.Java中的锁主要用于保障多并发情况下数据的一致性，线程必须先获取锁才能进行操作，可以保证数据的安全。
  2.从乐观和悲观的角度可以分为乐观锁和悲观锁。
  3.从获取资源的公平性可以分为公平锁和非公平锁。
  4.从是否共享资源的角度可以分为共享锁和排它锁。
  5.从锁的状态角度可分为偏向锁、轻量级锁和重量级锁。同时在JVM中还设计了自旋锁以更快地使用CPU资源。
  
  ### 讲一讲乐观锁和悲观锁
  1.乐观锁:采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁。但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法，具体过程为：比较当前版本号与上一次的版本号，如果一致则更新，否则重复进行读、比较、写操作。Java中的乐观锁是基于CAS操作实现的，CAS是一种原子性操作，在对数据更新之前先比较当前值和传入的值是否一样，一样则更新否则直接返回失败状态。
  2.悲观锁:采用悲观的思想处理数据，每次读取数据时都认为别人会修改数据，所以每次都会上锁，其他线程将被阻塞。Java中的悲观锁基于AQS实现，该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到则会转为悲观锁。
  
  ### 讲一讲自旋锁
  1.自旋锁认为如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等待小段时间，在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致锁时间消耗。
  2.优点：减少CPU的上下文切换，对于占用锁时间非常短或锁竞争不激烈的代码块来说性能很高。
  3.缺点：在持有锁的线程长时间占用锁或竞争过于激烈时，线程会长时间自旋浪费CPU资源，有复杂锁依赖的情况不适合使用自旋锁。
  
  ### 讲一讲公平锁与非公平锁
  1.公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给排队时间最长的线程。
  2.非公平锁指在分配锁时不考虑线程排队等待的情况，直接尝试获取锁，获取不到锁就在排到队尾等待。
  3.因为公平锁需要在多核情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁，ReentrantLock默认的lock方法也是非公平锁。
  
  ### 讲一讲读写锁
  1.Lock接口提供的锁是普通锁，为了提高性能Java提供了读写锁，读写锁分为读锁和写锁，读锁之间不互斥，读锁与写锁，写锁之间都互斥。
  2.如果系统要求共享数据可以同时支持很多线程并发读，但不能支持很多线程并发写，那么读锁能大大提高效率。如果系统要求共享数据在同一时刻只能有一个线程在写，且写的过程中不能读，则需要使用写锁。
  3.提高juc的locks包中ReadWriteLock的实现类ReentrantReadWriteLock的readLock()和writeLock()来分别获取读锁和写锁。
  
  ### 讲一讲共享锁与排它锁
  1.共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。
  2.排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。
  3.排它锁是一种悲观的加锁策略，同一时刻只允许一个线程读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。
  
  ### 锁有哪些状态？
  1. 无锁，偏向锁，轻量级锁和重量级锁。
  2. 重量级锁是基于操作系统互斥量实现的，会导致进程在用户态和内核态之间来回切换，开销较大，synchronized内部基于监视器实现，监视器基于底层操作系统实现，因此属于重量级锁，运行效率不高。JDK1.6后为了减少获取锁和释放锁带来的性能消耗提高性能，引入了轻量级锁和偏向锁。
  3. 轻量级锁是相对于重量级锁而言的，核心设计实在没有多线程竞争的前提下，减少重量级锁的使用来提高性能。适用于线程交替执行同步代码块的情况，如果同一时刻有多线程访问同一个锁，会导致轻量级锁膨胀成重量级锁。
  4. 偏向锁用于在某个线程获取某个锁后，消除这个线程锁重入的开销，看起来似乎是这个线程得到了锁的偏袒。偏向锁的主要目的是在同一个线程多次获取某个所的情况下尽量减少轻量级锁的执行路径，因为轻量级锁需要多次CAS操作，而偏向锁只需要切换ThreadID时执行一次CAS操作，提高效率。出现多线程竞争锁时，JVM会自动撤销偏向锁。偏向锁是进一步提高轻量级锁性能的。
  5. 随着锁竞争越来越严重，锁可能从偏向锁升级到轻量级锁再到重量级锁，但在Java中只会单向升级不会降级。
  
  ### 如何进行锁优化？
  1.减少锁持有的时间：只在有线程安全要求的程序上加锁来尽量减少同步代码块对锁的持有时间。
  2.减小锁粒度：将单个耗时较多的锁操作拆分为多个耗时较少的锁操作来增加锁的并行度，减少同一个锁上的竞争。在减少锁的竞争后，偏向锁、轻量级锁的使用率才会提高，例如ConcurrentHashMap中的分段锁。
  3.读分离：指根据不同的应用场景将锁的功能进行分离以应对不同的变化，最常见的锁分离思想就是读写锁，这样既保证了线程安全又提高了性能。
  4.锁粗化：指为了保障性能，会要求尽可能将锁的操作细化以减少线程持有锁的时间，但如果锁分的太细反而会影响性能提升，这种情况下建议将关联性强的锁操作集中处理。
  5.锁消除：注意代码规范，消除不必要的锁来提高性能。
  
  ### 线程池是什么？为什么需要线程池
  1.在生产中为每一个任务创建一个线程存在一些缺陷，如果无限制地大量创建线程会消耗很多资源，影响系统稳定性和性能，产生内存溢出等问题。
  2.线程池是管理一组同构工作线程的资源池，线程池与工作队列密切相关，工作队列中保存了所有需要等待执行的任务。工作线程的任务很简单，从工作队列获取任务，执行任务，返回线程池并等待下一次任务。
  3.线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销，另一个好处是当请求到达时工作线程通常已经存在，不会出现等待线程而延迟任务的执行，提高了响应性。通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。
  
  ### 创建线程池时，ThreadPoolExecutor构造器中都有哪些参数，有什么含义?
  1.corePoolSize： 线程池核心大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。
  2.maximumPoolSize： 线程池最大大小，表示可同时活动的线程数量的上限。
  3.keepAliveTime：存活时间，如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过基本大小时，这个线程将被终止。
  4.unit： 存活时间的单位，可选的参数为TimeUnit枚举中的几个静态变量： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。
  5.workQueue： 线程池所使用的阻塞队列。
  6.thread factory：线程池使用的创建线程工厂方法，可省略，将使用默认工厂。
  7.handler：所用的拒绝执行处理策略，可省略，将使用默认拒绝执行策略。
  
  ### 创建线程池的方法有哪些？
  可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。
  1.newFixedThreadPool:
  作用：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。
  
  特征： 
  （1）线程池中的线程处于一定的量，可以很好的控制线程的并发量 
  （2）线程可以重复被使用，在显示关闭之前，都将一直存在 
  （3）超出一定量的线程被提交时候需在队列中等待
  
  创建方式： 
  （1）Executors.newFixedThreadPool(int nThreads)；//nThreads为线程的数量 
  （2）Executors.newFixedThreadPool(int nThreads，ThreadFactory threadFactory)；//nThreads为线程的数量，threadFactory创建线程的工厂方式'
  
  2.newCachedThreadPool:
  作用：创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。
  
  特征： 
  （1）线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） 
  （2）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟） 
  （3）当线程池中，没有可用线程，会重新创建一个线程
  
  创建方式： Executors.newCachedThreadPool();
  
  3.newSingleThreadExecutor:
  作用：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。
  
  特征： 
  （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行
  
  创建方式： 
  （1）Executors.newSingleThreadExecutor() ； 
  （2）Executors.newSingleThreadExecutor(ThreadFactory threadFactory)；// threadFactory创建线程的工厂方式
  
  4.newScheduledThreadPool:
  作用： 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
  
  特征： 
  （1）线程池中具有指定数量的线程，即便是空线程也将保留 
  （2）可定时或者延迟执行线程活动
  
  创建方式： 
  （1）Executors.newScheduledThreadPool(int corePoolSize)；// corePoolSize线程的个数 
  （2）newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)；// corePoolSize线程的个数，threadFactory创建线程的工厂
  
  5.newSingleThreadScheduledExecutor
  作用： 创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。
  
  特征： 
  （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行 
  （2）可定时或者延迟执行线程活动
  
  创建方式： 
  （1）Executors.newSingleThreadScheduledExecutor() ； 
  （2）Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) ；//threadFactory创建线程的工厂
  
  
  ### 线程池的工作原理？
  [Java并发编程：线程池的使用 - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3932921.html)
  
  ### Executor 与Executors的区别
  1.Executor 接口对象能执行我们的线程任务；
  2.Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。
  ExecutorService 接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能够获得任务执行的状态并且可以获取任务的返回值。
  
  ### 简述ExecutorService的生命周期
  1.ExecutorService的生命周期有3种状态：运行、关闭和已终止。
  2.ExecutorService在初始创建时处于运行状态。
  3.shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。在ExecutorService关闭后提交的任务将有“拒绝执行处理器REH”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。
  4.等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已终止。通常在调用awaitTermination后会理解调用shutdown，从而产生同步地关闭ExecutorService的效果。
  
  ### 什么是CAS?
  1.CAS指Compare And Swap，比较并交换。CAS(V,E,N)算法包括三个参数，V表示要更新的变量的值，E表示预期的值，N表示新值。在且仅在V的值和E相等时才会将V的值设置为N，如果不同则说明已经有其他线程做了更改，当前线程就什么也不做。最后CAS返回当前V的真实值。
  2.CAS操作采用了乐观锁的思想，有多个线程同时使用CAS操作一个共享变量时只有一个线程会成功，失败的线程不会被挂起仅会被告知失败，并且允许再次尝试，或者放弃操作。基于这样的原理虽然CAS没有使用锁，也可以及时发现其他线程的操作进行适当地并发处理。
  
  ### CAS有什么问题？ 
  1.CAS算法地实现有一个重要前提：需要取出内存中某时刻的数据，然后在下一刻进行比较、替换，但在这个时间差内数据可能已经发生了变化，导致ABA问题。
  
  ### ABA是什么问题？
  ABA问题指线程1从内存V位置取出A，这时线程2也从内存中取出A，并将其首先修改为B，接着又修改为A，这时线程1在进行CAS操作时会发现内存中数据仍是A，然后线程1操作成功。尽管从操作角度来说线程1成功了，但是在该过程中实际上数据已发生了变化但并未被感知到，某些应用场景下可能会出现数据不一致的问题。
  
  ### 如何解决ABA问题。
  乐观锁通过版本号来解决ABA问题，具体的操作是每次执行数据修改操作时都会带上一个版本号，如果预期版本号和数据版本号一致就进行操作，并将版本号加1，否则执行失败。
  
  ### 讲一讲wait、sleep、yield、join方法的区别
  1.wait是Object类的方法，调用wait方法的线程会进入WAITING状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法释放锁资源。
  2.sleep是Thread类的方法，调用sleep方法导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是TIMED-WAITING状态。
  3.yiled是Thread类的方法，yiled方法使当前线程让出CPU时间片给优先级相同或更高的线程，回到RUNNABLE状态，与其他线程一起重新竞争CPU时间片。
  4.join是Thread累的方法，join方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的join方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。
  
  ### 什么是守护线程？
  1.守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。守护线程不依赖于终端，但是依赖于JVM，当JVM中仅剩下守护线程时，JVM就会退出。
  2.通过setDaemon方法定义一个守护线程，守护线程的优先级较低，将一个用户线程设置为守护线程必须要在启动守护线程之前。
  
  ### start和run方法的区别？
  1.start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。
  2.run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。
  
  
  ## JVM
  ### 类加载器的原理
  程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。
  
  ### JVM中类加载的过程（机制）？
  虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型
  [深入浅出Java类加载过程 - 神仙果 - 博客园](https://www.cnblogs.com/luohanguo/p/9469851.html)
  ![14265221-905453ee556fc809.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bf372989.png)
  #### 加载
  1.java虚拟机将.class文件读入内存，并为之创建一个class对象。
  2.任何类被使用时系统都会为其创建一个且仅有一个class对象。
  3.这个class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。
  ![1272523-20180813175012975-888131295.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\0230423b.png)
  
  #### 链接
  将java类的二进制代码合并到JVM的运行状态之中。
  
  验证:验证class文件的字节流是否符合jvm规范,确保加载的类信息符合jvm规范，没有安全方面的
  
  准备:正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。而此时的设置初始值为默认值，具体赋值在初始化阶段完成。
  
  解析:虚拟机常量池内的符号引用替换为直接引用的过程。
  
  #### 初始化
  主要对类变量进行初始化，执行类构造器的过程，仅仅对static修饰的变量或者语句进行初始化。
  例Person person=new Person();
  1. 找到class文件，将它加载到内存
  2. 在堆内存中分配内存地址
  3. 初始化
  4. 将堆内存地址指给栈内存中的p变量
  
  **初始化顺序**
  1、父类的静态变量
  2、父类的静态代码块
  3、子类的静态变量
  4、子类的静态代码块
  5、父类的非静态变量
  6、父类的非静态代码块
  7、父类的构造方法
  8、子类的非静态变量
  9、子类的非静态代码块
  10、子类的构造方法
  
  ### 类加载器的分类
  ![14265221-549d6e3ca7ab0b5a.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bb6f8847.png)
  #### 引导类加载器(bootstrap class loader)
  （1）它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自java.lang.ClassLoader。
  （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。
  
  #### 扩展类加载器(extensions class loader)
  （1）用来加载 Java 的扩展库(JAVA_HOME/jre/ext/* .jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
  （2）由sun.misc.Launcher$ExtClassLoader实现。
  
  #### 应用程序类加载器(application class loader)
  （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
  （2）由sun.misc.Launcher$AppClassLoader实现。
  
  #### 自定义类加载器
  （1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。
  
  ### 类加载器的代理模式
  代理模式即是将指定类的加载交给其他的类加载器（类加载器之间的层次关系）。常用双亲委托机制。
  #### 双亲委托机制
  某个特定的类加载器接收到类加载的请求时，会将加载任务委托给自己的父类，直到最高级父类引导类加载器（bootstrap class loader），如果父类能够加载就加载，不能加载则返回到子类进行加载。如果都不能加载则报错。ClassNotFoundException
  ![2019062814264974.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\90ad5fee.png)
  
  #### 为什么使用双亲委托模型
  使得java类随着它的类加载器一起具有一种带有优先级的层级关系，从而使得基础类得到统一。
  例如：例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。
  
  ###简述JVM的内存区域
  JVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存。
  1.程序计数器是一块很小的内存空间，用于存储当前线程执行字节码文件的行号指示器。
  2.虚拟机栈是描述Java方法执行过程的内存模型，帧栈中存储了局部变量表，操作数栈，动态链接，方法出口等信息。
  3.本地方法区，和虚拟机栈作用类似，区别是虚拟机栈为Java方法服务，本地方法栈为Native方法服务。
  4.JVM运行过程中创建的对象和生成的数据都存储在堆中，堆是被线程共享的内存区域，也是垃圾回收最主要的内存区域。
  5.方法区用来存储常量，静态变量、类信息、即时编译器编译后的机器码、运行时常量池等数据。
  
  ### 谈一谈JVM的运行时内存
  JVM的运行时内存也叫做JVM堆，从GC角度更将其分为新生代，老年代和永久代。
  其中新生代默认占1/3堆空间，老年代默认占2/3堆空间，永久代占非常少的堆空间。
  新生代又分为Eden区、ServivorFrom区和ServivorTo区，Eden区默认占8/10新生代空间，ServivorFrom区和ServivorTo区默认分别占1/10新生代空间。
  
  ### 谈谈新生代的垃圾回收机制
  新生代的GC过程叫做MinorGC，采用复制算法实现，具体过程如下：
  1.把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区，如果某对象的年龄达到老年代的标准，则将其复制到老年代，同时把这些对象的年龄加1。如果ServivorTo区的内存空间不够，则也直接将其复制到老年代。如果对象属于大对象，则也直接复制到老年代。
  2.清空Eden区和ServivorFrom区中的对象。
  3.将ServivorFrom区和ServivorTo区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。
  
  ### 谈谈老年代的垃圾回收机制
  1.老年代主要存放有长生命周期的对象和大对象，老年代的GC叫MajorGC。
  2.在老年代，对象比较稳定，MajorGC不会频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，过后仍然出现老年代空间不足或无法找到足够大的连续内存空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。
  3.MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。因为要先扫描老年代的所有对象再回收，所以MajorGC的时间较长。容易产生内存碎片，在老年代没有内存空间可分配时，会出现内存溢出异常。
  
  ### 谈一谈永久代
  1.永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时被放入永久代。
  2.永久代和老年代、新生代不同，GC不会在程序运行期间对永久代的内存进行清理，这也导致了永久代的内存会随着加载的Class文件的增加而增加，在加载的Class文件过多时会出现内存溢出异常，比如Tomcat引用jar文件过多导致JVM内存不足而无法启动。
  3.在JDK1.8中，永久代已经被元数据区取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此元空间的大小不受JVM内存的限制，只和操作系统的内存有关。
  4.在JDK1.8中，JVM将类的元数据放入本地内存中，将常量池和类的静态常量放入Java堆中，这样JVM能够加载多少元数据信息就不再由JVM的最大可用内存空间决定，而由操作系统的实际可用内存空间决定。
  
  
  ### 如何确定对象是否是垃圾
  1.Java采用引用计数法和可达性分析来确定对象是否应该被回收。引用计数法容易产生循环引用的问题，可达性分析通过根搜索算法实现。根搜索算法以一系列GC Roots的点作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡。根搜索算法主要针对栈中的引用、方法区的静态引用和JNI中的引用展开分析。
  2.引用计数法：在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引用计数减1；如果一个对象的引用计数为0，则表示此刻该对象没有被引用，可以被回收。引用计数法容易产生循环引用问题，循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收。
  3.可达性分析：为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以被回收。具体做法是首先定义一些GC Roots对象，然后以这些GC Roots对象作为起点向下搜索，如果在GC Roots和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象要经过至少两次标记才能判断其是否可被回收，如果两次标记后该对象仍然不可达，则将被垃圾回收器回收。
  
  ### 有哪些GC算法？分别有什么特点？
  #### 标记清除算法
  标记出所有需要回收的对象，然后清除可回收的对象。效率较低，并且因为在清除后没有重新整理可用的内存空间，如果内存中可被回收的小对象居多，会引起内存碎片化问题。
  
  #### 复制回收算法
  将可用内存分为区域1和区域2，将新生成的对象放在区域1，在区域1满后对区域1进行一次标记，将标记后仍然存活的对象复制到区域2，然后清除区域1。效率较高并且易于实现，解决了内存碎片化的问题，缺点是浪费了大量内存，同时在系统中存在长生命周期对象时会在两区域间来回复制影响系统效率。
  
  #### 标记整理算法
  结合了标记清除算法和复制算法的优点，标记过程和标记清除算法一样，标记后将存活的对象移动到一端，清理另一端。
  
  #### 分带收集算法
  根据对象不同类型把内存划分为不同区域，把堆划分为新生代和老年代。由于新生代的对象生命周期较短，主要采用复制算法。将新生代划分为一块较大的Eden区和两块较小的Survivor区，Servivor区又分为ServivorTo和ServivorFrom区。JVM在运行过程中主要使用Eden和SurvivorFrom区，进行垃圾回收时将这个两个区域存活的对象复制到SurvivorTo区并清除这两个区域。老年代主要存储长生命周期的大对象，因此采用标记清除或标记整理算法。
  
  ### java类的引用
  [JAVA类加载过程&主动引用和被动引用](https://www.baidu.com/link?url=ZaJO63OX4cc1VaIpQzrwvVJeltj2MMT179nj_yaFwtEF7-7K8IIrPTqjXY7PlHYR&wd=&eqid=b9cda6fb0010d68b000000045da6939f)
  #### 主动引用
  碰到如下四种情况才会触发主动引用：
  1. 使用new关键字实例化对象(new)
  ```
  package com.dhb.classload;
  
  public class NewClass {
  
      static {
          System.out.println("NewClass init ...");
      }
  
  }
   class Init1{
      public static void main(String[] args) {
          new NewClass();
      }
  }
  //输出结果：
  NewClass init ...
  ```
  2. 读取类的静态成员变量(getstatic)
  ```
  package com.dhb.classload;
  
  public class StaticAttributeClass {
  
      public static int value = 10;
  
      public static void staticMethod() {
  
      }
  
      static {
          System.out.println("StaticAttributeClass init ...");
      }
  }
  
  class Init2{
      public static void main(String[] args) {
          //1.读取静态变量
          int value = StaticAttributeClass.value;
      }
  }
  //输出结果
  StaticAttributeClass init ...
  ```
  3. 设置类的静态成员变量(setstatic)
  ```
  class Init2{
      public static void main(String[] args) {
          StaticAttributeClass.value = 5
      }
  }
  //输出结果
  StaticAttributeClass init ...
  ```
  4. 调用静态方法(invokestatic)
  ```
  class Init2{
      public static void main(String[] args) {
          StaticAttributeClass.staticMethod();
      }
  }
  //输出结果
  StaticAttributeClass init ...
  ```
  
  #### 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
  ```
  package com.dhb.classload;
  
  public class ReflectClass {
  
      static {
          System.out.println("ReflectClass init ...");
      }
  }
  class Init3{
      public static void main(String[] args) {
          try {
              Class clazz = Class.forName("com.dhb.classload.ReflectClass");
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  //输出结果
  ReflectClass init ..
  ```
  
  #### 当初始化一个类的时候，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。
  ```
  package com.dhb.classload;
  
  public class SuperClass {
      static {
          System.out.println("SuperClass init ...");
      }
      public static int value = 10;
  }
  
  class SubClass extends SuperClass {
      static {
          System.out.println("SubClass init ...");
      }
  }
  
  class Init4 {
      public static void main(String[] args) {
          new SubClass();
      }
  }
  //输出结果
  SuperClass init ...
  SubClass init ...
  ```
  #### 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
  ```
  package com.dhb.classload;
  
  public class MainClass {
  
      static {
          System.out.println("MainClass init ...");
      }
  
      public static void main(String[] args) {
          System.out.println("main begin ...");
      }
  }
  //输出结果
  MainClass init ...
  main begin ...
  ```
  
  ### 被动引用
  #### 通过子类引用父类的静态字段，不会导致子类初始化
  ```
  package com.dhb.classload;
  
  public class SuperClass {
      static {
          System.out.println("SuperClass init ...");
      }
      public static int value = 10;
  }
  
  class SubClass extends SuperClass {
      static {
          System.out.println("SubClass init ...");
      }
  
  }
  
  class Init4 {
      public static void main(String[] args) {
          int value = SubClass.value;
      }
  }
  //输出结果
  SuperClass init ...
  ```
  
  #### 通过数组定义来引用，不会触发此类的初始化
  ```
  package com.dhb.classload;
  
  public class ArrayClass {
  
      static {
          System.out.println("ArrayClass init ...");
      }
  }
  class Init5{
      public static void main(String[] args) {
          ArrayClass[] arrays = new  ArrayClass[10];
      }
  }
  //输出结果为空
  ```
  
  #### 常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量初始化
  ```
  package com.dhb.classload;
  
  public class ConstClass {
      static {
          System.out.println("ConstClass init ...");
      }
  
      public static final int value = 10;
  }
  class Init6{
      public static void main(String[] args) {
          int value = ConstClass.value;
      }
  }
  //输出结果为空
  ```
  
  
  
  ### java对象引用
  [Java中四种引用 - 张界 - 博客园](https://www.cnblogs.com/pascall/p/10281775.html)
  #### 强引用
  如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
  ```
  String str = "hello";    // 强引用
  str = null;              // 取消强引用
  ```
  #### 软引用
  在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。
  ```
  SoftReference<String> softName = new  SoftReference<>("张三");
  ```
  #### 弱引用
  具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。
  ```
  WeakReference<String> weakName = new WeakReference<String>("hello");
  ```
  #### 虚引用
  如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
  虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
  ```
  ReferenceQueue<String> queue = new ReferenceQueue<String>();
  PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
  ```
  
  ## 反射与注解3
  ### 简述反射的基本概念，优缺点和使用场景
  1.在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制。
  2.优点是运行时动态获取类的全部信息，缺点是破坏了类的封装性，泛型的约束性。
  3.是框架的核心灵魂，动态代理设计模式采用了反射机制，还有 Spring、Hibernate 等框架也大量使用到了反射机制。
  
  ### 获取Class对象有哪几种方式？能通过Class对象获取类的哪些信息？
  1.通过类名.class
  2.通过对象.getClass()
  3.通过Class.forName(类的全限名);
  4.可以通过Class对象获取类的成员变量，方法或构造器。带declared的可以获取到类的private修饰的一个或全部成员变量，方法，构造器，不带declared的方法只能获取到类的public修饰的成员变量、方法或构造器，包括父类public修饰的成员变量、方法或构造器。
  
  ## Stream流
  
  ### 简单说说File对象表示的是什么？File类有哪些常用的方法？
  1.File对象表示的是操作系统上的文件或目录。
  2.获取：getAbsolutePath() 获取绝对路径；getPath() 获取文件定义时使用的路径；getName() 获取文件名，带后缀；length() 返回文件长度，单位是字节。
  3.判断：exists() 判断File对象表示的文件或目录是否存在；isDirectory() 判断是否是目录； isFile() 判断是否是文件。
  4.创建和删除：createNewFile() 不存在时创建新文件；delete() 删除文件，目录（非空目录不能删除）；mkdir() 创建一级目录；mkdirs() 创建多级目录，推荐使用；5.遍历：list 获取当前目录下所有一级文件名称到一个字符串数组并返回；listFiles 获取当前目录下所有一级File对象到File数组返回。
  
  ### 英文，数字和中文字符在文件中分别占多大的空间？
  1.英文和数字在任何编码中都占用1个字节
  2.中文字符在GBK编码下占2个字节，在UTF-8编码下占3个字节
  
  ### 简述传统Stream有哪些分类？
  1.按流的方向
    1）输出流：把内存中的数据写出到磁盘文件或者网络介质中
    2）输入流：把磁盘文件或网络介质中的数据读取到内存汇总。
  
  2.按流的内容
    1）字节流：流中的数据的最小单位是字节
    2）字符流：流中数据的最小单位是字符
    顶层的抽象类包括InputStream、OutPutStream、Reader、Writer、它们都实现了Closeable接口
  
  3.缓冲流（BufferedInputStream/BufferedOutputStream/BufferedReader/BufferedWriter）:自带一个8KB大小的缓冲池，可以将字节/字符流为缓冲字节/缓冲字符流，
  4.字符转换流（InputStreamReader/OutPutStreamWriter）:可以将对应的字节流转换为字符流，
  5.打印流（PrintStream）：方便快速打印数据，参数是什么就打印什么。
  
  ### 简述BIO,NIO,AIO的区别和原理
  1. BIO是同步阻塞的，数据的读写会阻塞在一个线程中，适用于连接数目比较小且固定的架构，对服务器资源要求高，JDK1.4前的唯一选择。
  2. NIO是同步非阻塞的，通过Selector监听Channel上事件的变化，在Channel上有数据变化时通知该线程进行读写操作。适用于连接数目比较多且连接比较短的架构，如聊天服务器，从 JDK1.4开始支持.
  3. AIO是异步非阻塞的，异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情。适用于连接数目比较多且连接比较长的架构，从JDK1.7开始支持。
  
  ### 序列化和反序列化是什么,有什么要求？
  1.Java在JVM运行时被创建、更新和消耗，当JVM退出时，对象也会随之销毁。可以通过Java序列化实现持久化存储，保存对象及其状态信息到字节数组中。
  2.反序列化就是再将字节数组中存储的信息转换回Java对象。
  3.要求类必须实现序列化接口，并且序列化和反序列化必须保持序列化的ID一致。
  4.静态变量和被transient修饰的变量不会被序列化。
  (transient:将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。)
  
  
  ## 设计模式
  ### 设计模式是什么？
  设计模式是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结。正确使用设计模式能提高代码的可读性、可重用性和可靠性，编写符合设计模式规范的代码不但有利于自身系统的稳定、可靠，还有利于外部系统的对接。在使用了良好设计模式的系统工程中，无论是对满足当前的需求还是对适应未来的需求，无论是对自身系统间模块的对接还是对外部系统的对接，都有很大帮助。
  
  ### 设计模式有哪些原则？
  1.单一职责原则：单一职责原则又称单一功能原则，它规定一个类只有一个职责。如果有多个职责（功能）设计在一个类中，这个类就违反了单一职责原则。
  [设计模式六大原则：单一职责原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11462818.html)
  
  2.开闭原则：开闭原则规定软件中的对象（类、模块、函数等）对扩展开放，对修改封闭，这意味着一个实体允许在不改变其源代码的前提下改变其行为，该特性在产品化的环境下是特别有价值的，在这种环境下，改变源代码需要经过代码审查，单元测试等过程以确保产品的使用质量。遵循这个原则的代码在扩展时并不发生改变，因此不需要经历上述过程。[设计模式六大原则：开闭原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11489712.html)
  
  3.里氏代换原则：里氏代换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，子类都一定可以出现。实现开闭原则的关键就是抽象化，父类与子类的继承关系就是抽象化的具体表现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
  [设计模式六大原则：里氏替换原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11462828.html)
  
  4.依赖倒转原则：依赖倒转原则指程序要依赖于抽象（Java中的抽象类和接口），而不依赖于具体的实现（Java中的实现类）。简单地说，就是要求对抽象进行编程，不要求对实现进行编程，这就降低了用户与实现模块之间的耦合度。
  [设计模式六大原则：依赖倒置原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11462878.html)
  
  5.接口隔离原则：接口隔离原则是指通过将不同的功能定义在不同的接口中来实现接口的隔离，这样就避免了其他类在依赖该接口（接口上定义的功能）时依赖其不需要的接口，可减少接口之间依赖的冗余性和复杂性。
  [设计模式六大原则：接口隔离原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11481076.html)
  
  6.迪米特法则：迪米特法则指一个对象尽可能少地与其他对象发生相互作用，即一个对象对其他对象应该有尽可能少的了解或依赖。其核心思想在于降低模块之间的耦合度，提高模块的内聚性。迪米特法则规定每个模块对其它模块都要有尽可能少的了解和依赖，因此很容易使系统模块之间的功能独立，这使得各个模块的独立运行变得更加简单，同时使得各个模块之间的组合变得更加容易。
  [设计模式六大原则：迪米特法则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11489748.html)
  
  ### 设计模式分类？
  1.创建者模式:提供了多种优雅创建对象的方法
  工厂模式，抽象工厂模式，单例模式，建造者模式，原型模式
  
  2.结构型模式:通过类和接口之间的继承和引用实现创建复杂结构对象的功能
  适配器模式，桥接模式，组合模式，装饰器模式，外观模式，享元模式，代理模式
  
  3.行为型模式:
  行为型模式：通过类之间不同的通信方式实现不同的行为方式，
  责任链模式，命令模式，解释器模式，迭代器模式，中介老模式，备忘录模式，观察者模式，状态模式，策略模式，模板模式，访问者模式。
  
  ### 简述工厂模式
  1.工厂模式属于创建型模式，提供了一种简单，快速，高效而安全地创建对象的方式。
  2.工厂模式在接口中定义了创建对象的方法，而将具体的创建对象的过程在子类中实现，用户只需通过接口创建需要的对象即可，不用关注对象的具体创建过程。同时，不同的子类可根据需求灵活实现创建对象的不同方法。
  3.工厂模式的本质就是用工厂方法代替new操作创建一种实例化对象的方式。
  [工厂模式 \\| 菜鸟教程](https://www.runoob.com/design-pattern/factory-pattern.html)
  
  ### 简述抽象工厂模式
  1.抽象工厂模式在工厂模式上添加了一个创建不同工厂的抽象接口（抽象类或接口实现），该接口可叫做超级工厂。在使用过程中，我们首先通过抽象接口创建出不同的工厂对象，然后根据不同的工厂对象创建不同的对象。
  2.在同一个厂商有多个维度的产品时，如果使用工厂模式，则势必会存在多个独立的工厂，这样的话设计和物理世界是不对应的。
  [抽象工厂模式 \\| 菜鸟教程](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)
  
  ### 单例模式
  1.单例模式是保证系统实例唯一性的重要手段。单例模式首先通过将类的实例化方法私有化来防止程序通过其他方式创建该类的实例，然后通过提供一个全局唯一获取该类实例的方法帮助用户获取类的实例，用户只需也只能通过调用该方法获取类的实例。
  2.单例模式的设计保证了一个类在整个系统中同一时刻只有一个实例存在，主要被用于一个全局类的对象在多个地方被使用并且对象的状态是全局变化的场景下。同时单例模式为系统资源的优化提供了很好的思路，频繁创建或销毁对象都会增加系统的资源消耗，而单例模式保障了整个系统只有一个对象能被使用，很好地节约了资源。
  3.单例模式的实现很简单，每次在获取对象前都判断系统是否已经有这个单例对象，有则返回，无则创建。需要注意的是，单例模型的类构造器是私有的，只能由自身创建和销毁对象，不允许除了该类的其他程序使用new关键字创建对象及破坏单例模式。
  
  #### 单例模式-懒汉模式(线程不安全)实现
  最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。···
  ```
  public class Singleton {  
      private static Singleton instance;  
      private Singleton (){}  
    
      public static Singleton getInstance() {  
      if (instance == null) {  
          instance = new Singleton();  
      }  
      return instance;  
      }  
  }
  ```
  
  
  #### 单例模式-懒汉模式(线程安全)实现
  描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
  优点：第一次调用才初始化，避免内存浪费。
  缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
  ```
  public class Singleton {  
      private static Singleton instance;  
      private Singleton (){}  
      public static synchronized Singleton getInstance() {  
      if (instance == null) {  
          instance = new Singleton();  
      }  
      return instance;  
      }  
  }
  ```
  
  #### 单例模式-饿汉模式实现
  描述：这种方式比较常用，但容易产生垃圾对象。
  优点：没有加锁，执行效率会提高。
  缺点：类加载时就初始化，浪费内存。
  它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。
  ```
  public class Singleton {  
      private volatile static Singleton singleton;  
      private Singleton (){}  
      public static Singleton getSingleton() {  
      if (singleton == null) {  
          synchronized (Singleton.class) {  
          if (singleton == null) {  
              singleton = new Singleton();  
          }  
          }  
      }  
      return singleton;  
      }  
  }
  ```
  #### 单例模式-双重检查加锁方式实现
  ```
  public class SingleTon3 {
  
           private SingleTon3(){};             //私有化构造方法
  
           private static volatile SingleTon3 singleTon=null;
  
           public static SingleTon3 getInstance(){
  
                    //第一次校验
                   if(singleTon==null){     
  
                  synchronized(SingleTon3.class){
  
                             //第二次校验
  
                          if(singleTon==null){     
                           singleTon=new SingleTon3();
                           }
                  }
       }
       return singleTon;
  }
  
  ```
  为什么需要两次校验 if(singleTon==null)
  第一次
  由于单例模式只需要创建一次实例，如果后面再次调用getinstance方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。
  第二次
  如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。
  #### **需要注意**
  private static volatile SingleTon3 singleTon=null;需要加volatile关键字，否则会出现错误。问题的原因在于JVM指令重排优化的存在。在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将对象的字段设置为默认值。此时就可以将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，取到的就是状态不正确的对象，程序就会出错。
  
  #### 单例模式-登记式/静态内部类方式实现
  描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
  这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。
  
  ```
  public class Singleton {  
      private static class SingletonHolder {  
      private static final Singleton INSTANCE = new Singleton();  
      }  
      private Singleton (){}  
      public static final Singleton getInstance() {  
      return SingletonHolder.INSTANCE;  
      }  
  }
  
  ```
  
  #### 单例模式-枚举方式实现
  描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
  这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
  不能通过 reflection attack 来调用私有构造方法。
  ```
  public enum Singleton {  
      INSTANCE;  
      public void whateverMethod() {  
      }  
  }
  ```
  
  ### 浅复制和深复制的区别？
  [Java 浅拷贝和深拷贝 - 简书](https://www.jianshu.com/p/94dbef2de298)
  
  1.浅复制：Java中的浅复制是通过实现Cloneable接口并重写clone方法实现。在浅复制的过程中，对象的基本数据类型的变量值会重新被复制和创建，而引用数据类型仍指向原对象的引用，也就是说浅复制不复制对象的引用数据类型。
  
  2.深复制：在深复制的过程中，不论是基本数据类型还是引用数据类型，都会被重新复制和创建。简而言之，深复制彻底复制了对象的数据，浅复制的复制不彻底（忽略了引用数据类型）。
  
  ### 讲一讲观察者模式
  1.观察者模式指在被观察者的状态发生变化时，系统基于事件驱动理论将其状态通知到订阅其状态的观察者对象中，以完成状态的修改和事件传播。观察者模式是一种对象行为模式，观察者和被观察者之间的关系属于抽象耦合关系，主要优点是观察者与被观察者之间建立了一套事件触发机制，以降低二者之间的耦合度。
  2.观察者模式的主要角色如下：抽象主题Subject：持有订阅了该主题的观察者对象的集合，同时提供了增加删除观察者对象的方法和主题状态变化后的通知方法。具体主题Concrete Subject：实现了抽象主题的通知方法，在主题内部状态发生变化时，调用该方法通知订阅了主题状态的观察者对象。抽象观察者Observer：观察者的抽象类或接口，定义了主题状态变化时需要调用的方法。具体观察者 Concrete Observer：抽象观察者的实现类，在收到主题状态变化的信息后执行具体触发机制。
  
  
  ## 计算机网络
  ![45fdeaf2.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\45fdeaf2.png)
  
  ### 说一说OSI网络模型
  网络的七层架构从下到上主要包括物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。
  1. 物理层：物理层主要定义物理设备标准，主要作用是传输比特流，具体做法是在发送端将1、0转化为电流强弱来进行传输，在到达目的地之后再将电流强弱转化为1、0，也就是我们常说的模数转换与数模转换，这一层的数据叫做比特。
  2. 数据链路层：数据链路层主要用于对数据包中的MAC地址进行解析和封装。这一层的数据叫做帧，在这一层工作的设备是网卡、网桥、交换机。
  3. 网络层：网络层主要用于对数据包中的IP地址进行封装和解析，这一层的数据叫做数据包。在这一层工作的设备有路由器、交换机、防火墙等。
  4. 传输层：传输层定义了传输数据的协议和端口号，主要用于数据的分段、传输和重组。在这一层工作的协议有TCP和UDP等。TCP是传输控制协议，传输效率低，可靠性强，用于传输对可靠性要求高，数据量大的数据，比如支付宝转账业务；UDP是用户数据报协议，用于传输可靠性要求不高，数据量小的数据，例如抖音等视频服务。
  5. 会话层：会话层在传输层的基础上建立连接和管理会话，具体包括登陆验证、断点续传、数据粘包与分包等。在设备之间需要互相识别的可以是IP，也可以是MAC或者主机名。
  6. 表示层：表示层主要对接收的数据进行解释、加密、解密、压缩、解压缩等，即把计算机能够识别的内容转换成人能够识别的内容（图片、声音、文字等）。
  7. 应用层：基于网络构建具体应用，例如FTP上传文件下载服务、Telnet服务、HTTP服务、DNS服务、SNMP邮件服务等。
  
  ### 说一说TCP/IP的网络模型
  TCP/IP不是指TCP和IP这两个协议的合称，而是指因特网的整个TCP/IP协议簇。从协议分层模型方面来讲，TCP/IP由4个层次组成：网络接口层、网络层、传输层和应用层。
  1. 网络接口层：定义了主机间网络连通的协议，具体包括Echernet、FDDI、ATM等通信协议。
  2. 网络层：主要用于数据的传输、路由及地址的解析，以保障主机可以把数据发送给任何网络上的目标。数据经过网络传输，发送的顺序和到达的顺序可能发生变化。在网络层使用IP协议和ARP地址解析协议。
  3. 传输层：使源端和目的端的机器上的对等实体可以基于会话相互通信。在这一层定义了两个端到端的协议TCP和UDP。TCP是面向连接的协议，提供可靠的报文传输和对上层应用的连接服务，除了基本的数据传输，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。
  4. 应用层：负责具体应用层协议的定义，包括Telnet虚拟终端协议、FTP文件传输协议、SMTP简单电子邮件传输协议、DNS域名解析服务、NNTP网上新闻传输协议和HTTP超文本传输协议等。
  
  ### 简述TCP的三次握手过程，为什么不是两次或四次？
  1. 服务端创建传输控制块TCB，进入LISTEN状态，准备接收客户端的请求。客户端同样先创建TCB，然后当准备建立连接时向服务端发送连接请求报文（SYN=1，seq=x），然后进入SYN-SENT状态。
  2. 服务端收到后向客户端发送确认报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN-RCVD状态。
  3. 客户端接收到确认后，再向服务端发送一个确认报文（ACK=1，ack=y+1，seq=x+1），然后进入ESTABLISHED状态，服务端接收后也进入ESTABLISHED状态。
  4. 不是两次的原因是为了避免无效的连接请求突然发送到服务端，而此时客户端已关闭，服务端误以为客户端将要发送数据会白白浪费资源。⑤不是四次的原因是将服务端的SYN和ACK报文拆分成两次发送和一次的效果是相同的，没有意义。
  
  ### 简述TCP的四次挥手过程，为什么不是三次？
  1. 当客户端准备关闭连接时，向服务端发送连接终止报文（FIN=1，seq=u），进入FIN-WAIT-1状态。
  2. 服务端接收后向客户端发送确认报文（ACK=1，ack=u+1，seq=v），进入CLOSE-WAIT状态，客户端收到后进入FIN-WAIT-2状态，此时TCP连接处于半关闭状态。
  3. 当服务端也发送完全部数据准备断开连接时，向客户发送连接终止报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST-ACK状态。
  4. 客户端接收到该报文后，发送一个确认报文（ACK=w+1，ack=1，seq=u+1），进入TIME-WAIT状态，然后等待2MSL时间后关闭。服务端收到后关闭，时间将略早于客户端。
  5. 不是三次的原因第一是为了保证客户端发送的最后一个报文可以到达服务端，如果该报文丢失那么服务端会超时重传之前的FIN+ACK报文，客户端可以在2MSL内收到，第二是防止已失效的报文发送到客户端，在2MSL后客户端在本连接时间内发出的所有报文都将从网络中消失。
  
  ### 简述HTTP的传输流程
  1. 地址解析：地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址。例如客户端的浏览器请求'http://localhost:8080/index.html' ，则可分析出：协议名HTTP、主机名localhost、端口8080、对象路径/index.html。
  2. 封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包。
  3. 封装TCP包：将HTTP请求数据包进一步封装成TCP数据包。
  4. 建立TCP连接：基于TCP的三次握手机制建立TCP连接。
  5. 客户端发送请求：在建立连接后，客户端发送一个请求给服务器。
  6. 服务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等内容。
  7. 服务器关闭TCP连接：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务器在消息头加入了Connection:keep-alive，则TCP连接在请求响应数据后仍然保持连接状态，在下一次请求中浏览器可以继续使用相同的连接发送请求。采用keep-alive不但减少了请求响应的时间，还节约了网络带宽和系统资源。
  
  ### HTTPS是什么？
  HTTPS是以安全为目标的HTTP通道，它在HTTP中加入SSL层以提高数据传输的安全性。HTTP被用于在Web浏览器和网站服务器之间传递信息，但以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP不适合传输一些敏感信息，比如身份证号码、密码等。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并对浏览器和服务器之间的通信进行数据加密，以保障数据传输的安全性，其端口一般是443。
  
  ### 简述HTTPS的加密流程
  1. 发起请求：客户端在通过TCP和服务器建立连接之后（443端口），发出一个请求证书的消息给服务器，在该请求消息里包含自己可实现的算法列表和其他需要的消息。
  2. 证书返回：服务端在收到消息后回应客户端并返回证书，在证书中包含服务器信息、域名、申请证书的公司、公钥、数据加密算法等。
  3. 证书验证：客户端在收到证书后，判断证书签发机构是否正确，并使用该签发机构的公钥确认签名是否有效，客户端还会确认在证书中列出的域名就是它正在连接的域名。如果客户端确认证书有效，则生成对称密钥，并使用公钥将对称密钥加密。
  4. 密钥交换：客户端将加密后的对称密钥发送给服务器，服务器在接收到对称密钥后使用私钥解密。
  5. 数据传输：经过上述步骤，客户端和服务器就完成了密钥对的交换，在之后的数据传输过程中，客户端和服务端就可以基于对称加密（加密和解密使用相同密钥的加密算法）对数据加密后在网络上传输，保证了网络数据传输的安全性。
  
  ### 进程和线程有什么区别？
  1. 进程是一个具有独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。
  2. 线程是一种轻量级的进程，是一个基本的CPU执行单元也是程序执行流的最小单元。线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程不拥有系统资源，只拥有一点运行必备的资源，但可与其他同属一个进程的线程共享进程拥有的全部资源。
  3. 引入进程的目的是为了更好地使多道程序并发执行，提高系统资源利用率和吞吐量，增加并发程度。引入线程地目的使为了减小程序在并发执行时的开销，提高系统的并发能力。
  4. 堆是线程共享的，栈是线程私有的。
  
  ### 死锁产生的原因和解决方法？
  1. 死锁是多个进程竞争共享资源而造成互相等待的僵局，若无外力作用这些进程都将无法向前推进。
  2. 死锁产生的原因是非剥夺资源的竞争和进程的不恰当推进顺序。
  3. 预防死锁：破坏互斥条件、破坏不剥夺条件、破坏请求和保持条件、破坏循环等待条件。
  4. 预防死锁：安全状态：能找到一个分配资源的序列让所有进程都顺序完成。银行家算法：采用预分配策略检查分配完成时系统是否处于安全状态。
  5. 检测死锁：利用死锁定理化简资源分配图检测死锁的存在。
  6. 解除死锁：资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便其他线程继续推进。撤销进程法：强制撤销部分、甚至全部进程并抢夺其资源，以便让其他进程继续推进。进程回退法：让一个或多个进程回退到足以避免死锁的地步
  
  ## 文献
  [【7万字干货】2021Java实习必看面试两百题解析_资源分享_牛客网](https://www.nowcoder.com/discuss/395523?type=0&order=0&pos=16&page=0)
  
  [Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/)
  
  [单例模式-双重检查加锁 - Michael2397 - 博客园](https://www.cnblogs.com/Michael2397/p/7599073.html)
  
  [设计模式六大原则：开闭原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11489712.html)
'''
linesHighlighted: [
  174
  470
  899
]
isStarred: false
isTrashed: false
