createdAt: "2019-10-16T02:39:38.018Z"
updatedAt: "2023-04-11T15:30:40.435Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Java"
tags: []
content: '''
  # Java 
  [TOC]
  ## 1、基础语法
  
  ### Byte和位Bit的关系 (★★★★)
  bit:    Binary digit（二进制数位）的缩写,意为“位”或“比特”，是计算机运算的基础； 
  byte:    意为字节"是计算机文件大小的基本计算单位； 
  关系:   1Byte=8bit   (简写:  1B=8b)
  
  ### String,StringBuffer,StringBuilder的区别 (★★★★★)
  ####  运行速度上的区别
  String < StringBuffer < StringBuilder
  String 的操作是一个不断创建新的对象并且将旧的对象通过GC回收的一个过程，所以执行速度很慢。
  StringBuffer与StringBuilder的对象是变量，对变量进行操作就是直接对该对象进行更改，所以速度要比String快很多。
  
  #### 线程安全上的区别
  String 是线程安全的。因为String是final修饰的类，是不可变的。
  StringBuffer是线程安全的，因为使用了Synchronized关键字进行修饰。
  StringBuilder是线程不安全的。
  
  #### 三者的使用总结
  - String：适用于少量的字符串操作的情况；
  - StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；
  - StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。
  
  ### 简述final,finally和finalize区别 (★★)
  1. final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方式不可重写，被final修饰的变量引用不可变，引用的内容可以更改。
  2. finally用于try-catch 代码块中，无论是否发生异常最后都将被执行，作用是释放资源。
  3. finalize 是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。
  
  ### ==和equals有什么区别?equals和hashCode有什么联系(★★★)
  1. 如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。
  2. 如果没有重写的话，equals默认按照==进行比较，如果重写了equals() 方法，则按照对应的规则比较。
  3. 两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。
  
  理解：
  如果是Integer类的hashcode返回的是值比较，对象不一定相同 √
  如果是String类的hashcode 值是算法计算出来的，有可能导致hashcode值相同的情况，两个对象不一定相同 √
  
  ### Array和ArrayList的区别（★★）
  1.Array长度在定义之后就不会改变了，而ArrayList长度可变的，可以自动化扩容。
  2.Array可以存储基本类型和对象类型，ArrayList只能包含对象类型
  
  ### 简述JDK8的新特性
  1.接口中可以添加default修饰的非抽象方法，可以有方法和内容。
  2.可以使用lambda表达式，减少代码冗余
  3.函数式接口，使用@Functionalinterface注解标明，该接口有且仅有一个抽象方法。
  4.方法引用，可以直接引用已有java类或对象的方法或构造器，进一步简化lambda表达式，
  5.stream流，用于解决已有集合/数组类库的弊端，简化其操作，有foreach遍历，filter过滤，map映射，concat合并等功能。
  6.增加日期相关的API
  
  ## 面向对象
  
  ### 什么是面向对象(OOP)
  当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。
  
  ### 什么是面向过程(OOD)
  当解决一个问题的时候，面向过程会把事情拆分成，一个个函数和数据。然后按照一定的顺序执行，等方法执行完了，问题得到解决。
  
  #### 面向过程与面向对象的举例证明
  
  问题： 洗衣机里面放有脏衣服，怎么洗干净？
  
  面向过程：
  1、执行加洗衣粉方法；
  2、执行加水方法；
  3、执行洗衣服方法；
  4、执行清洗方法；
  5、执行烘干方法；
  将解决这个问题的过程拆成一个个方法（是没有对象去调用的），通过一个个方法的执行来解决问题。
  
  面向对象：
  1、我先弄出两个对象：“洗衣机”对象和“人”对象;
  2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法”;
  3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”;
  4、然后执行;
  人.加洗衣粉
  人.加水
  洗衣机.洗衣服
  洗衣机.清洗
  洗衣机.烘干
  面向对象编程就是先抽象出对象，然后用对象执行方法的方式解决问题。
  
  ### 简述面向对象的特性 （★★）
    1) 封装：例如成员变量私有，然后提供公有的get/set方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露。可以提高安全性，实现代码的组件化
    2) 继承：一种子类到父类的关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。
    3) 多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，便于扩展和维护。
  
  ### 列举Object类的方法 （★★★）
     1) equals(Object obj):判断其他对象是否与当前对象相等。
     2) toString():打印当前对象的字符串表示
     3) wait():导致当前线程等待，等待其它线程唤醒，会释放锁。
     4) notify()/notifyAll():随机唤醒一个/全部线程
     5) hashCode():返回当前对象的hashCode值。
     6) finalize():当垃圾回收期要回收对象前调用。
     7) clone:创建并返回对象的一个副本.
  
  ### 接口和抽象类有什么区别(★★★)
  相同点：
  1. 都不能被实例化 
  2. 接口的实现类或抽象类的子类，都只有实现了方法后才能实例化。
  
  不同点：
  1. 实现接口的关键字为implements，继承抽象类的关键字为extends。
  2. 一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  3. 抽象类中可以有非抽象方法，接口中只能有抽象的方法。
  4. 接口中抽象方法前不能加abstract关键字，也不能加final,private,protected关键字来防止抽象方法的继承。只能用public
  5. 抽象类中抽象方法前必须加abstract关键字。
    
  ### 内部类
  #### 内部类的优点：
  内部类方法可以访问该类定义所在作用域中的数据，包括被 private 修饰的私有数据
  内部类可以使用 private 和 protected 来修饰，当使用 private 来修饰内部类的时候这个类就对外隐藏了。
  内部类可以实现java的单继承局限。
  通过匿名内部类来"优化"简单的接口实现，例如(new View.OnClickListener())
  #### 内部类与外部类的关系 (★★)
  对于**普通内部类**，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的。
  **静态内部类**的创建并不依赖于外部类的创建。
  #### 内部类的分类
  内部类分为两大类：静态内部类，非静态内部类。
  非静态内部类分为：成员内部类，方法内部类，匿名内部类。
  
  #### 静态内部类与非静态内部类区别(★★)
  静态内部类可以有静态成员，而非静态内部类则不能有静态成员，但允许有静态常量。
  静态内部类可以访问外部类的静态方法和属性，不可以访问外部类的非静态变量。而非静态内部类的非静态成员可以访问外部类的非静态变量。
  静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建。
  
  #### 局部内部类
  如果一个类定义在方法内部，被称为局部内部类。
  局部内部类不允许使用访问权限，public private protected均不允许。
  局部内部类对外完全隐藏，除了创建这个类的方法可以访问，其它地方不允许访问。
  
  #### 匿名内部类 (★★★)
  匿名内部类是局部内部类的一种简化形式.本质上是一个对象,是实现了该接口或继承了该抽象类的子类对象
  语法格式：new 类名或者接口名(){重写方法;};
  ```
  public class MyTest {
      public static void main(String[] args) {
   
          new Father() {//new了一个父类抽象类的子类对象.匿名的
              @Override
              //重写了父类中的抽象方法
              public void hehe() {
                  System.out.println("呵呵呵呵呵呵");
              }
          };
   
          //创建了父类的子类对象并且调用重写后的方法
          new Father() {
              @Override
              public void hehe() {
                  System.out.println("44444444444444");
              }
          }.hehe();
      }
  }
   
  abstract class Father {
      public abstract void hehe();
  }
  ```
  1. 匿名内部类没有访问修饰符(没有名字)。
  2. 匿名内部类可以在类中被创建，也可以在方法中被创建。
  3. 匿名内部类可以继承一个具体类，或继承一个抽象类，也可以实现一个接口。
  ```
  实现接口
  interface Programmer{
    void develop();
  }
  
  继承抽象类
  public abstract class Programmer{
    public abstract void develop();
  }
  
  继承具体类
  public class Programmer{
    public void develop(){
    }
  }
  ```
  4. 匿名内部类继承了具体类，可以不必重写所有方法，如果继承了接口或抽象类，那么匿名类必须实现所有的抽象方法。
  5. 匿名内部类中不能存在任何静态成员或方法。
  6. 匿名内部类是没有构造方法的，因为它没有类名。
  7. 匿名内部类中可以有被final修饰的静态常量。
  
  
  ### 泛型和泛型擦除
    1.泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制运行程序在编译时检测非法的类型。
    2.在编译阶段采用泛型时带上类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除。因此泛型主要用于编译阶段，在编译后生成的java字节代码文件中不包含泛型中的类型信息。
  
  ### 泛型标记的规范
    1.Element,在集合中使用，表示在集合中存放的元素
    2.指Type,表示java类，包括基本的类以及自定义类
    3.指Key,表示键，例如Map集合中的key.
    4.指value,表示值，例如Map集合中的Value
    5.指Number,表示数值类型.
    6.表示不确定的java类型
  
  ### 泛型限定是什么
    1.类型通配符使用？表示所有具体的参数类型，在使用泛型的时候，如果希望将类的继承关系加入泛型应用中就需要对泛型做限定，具体的泛型限定有对泛型上限的限定以及对泛型下限的限定。
    2.对泛型上限限定使用</?extends T>它表示该通配符所代表的类型是T类的子类型或T接口的子接口。
    3.对泛型下限的限定使用</?super T>它表示该通配符所代表的的类型是T类的父类型或T接口的父接口。
  
  ## 异常
  
  ### java异常类层次结构图
  
  ![Exception.png](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png)
  在java中，所有的异常都有一个共同的祖先java.lang包中的Throwable类。Throwable:有两个重要的子类：Exception(异常)和Error（错误）,二者都是java异常处理的重要子类，各自都包含大量子类。
  
  异常和错误的区别：异常能被程序本身处理，错误是无法处理。
  
  ### 异常有哪些分类？出现的原因是什么？ (★★)
  1.Throwable是所有错误和异常的父类,Throwable分为Error和Exception.
  2.Error指Java程序运行错误。出现Error通常是因为系统的内容部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error, 系统只能记录错误的原因和安全终止。
  3.Exception指java程序运行异常，Exception又分为RuntimeException和IoExcetion,RuntimeException指在Java虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。IoExcetion指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。
  
  ### 有哪些异常处理方式? (★★)
  第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。谁调用我，我就抛给谁。
  第二种方式：使用try…catch语句进行异常的捕捉。
  
  ### Throwable类常用方法
  
  - **public string getMessage()**:返回异常发生时的简要描述
  - **public string toString()**:返回异常发生时的详细信息
  - **public string getLocalizedMessage()**:返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同
  - **public void printStackTrace()**:在控制台上打印Throwable对象封装的异常信息
  
  ### 异常处理总结
  
  - **try 块：** 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
  - **catch 块：** 用于处理try捕获到的异常。
  - **finally 块：** 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return
  语句时，finally语句块将在方法返回之前被执行。
  
  **在以下4种特殊情况下，finally块不会被执行：**
  
  1. 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行
  2. 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行
  3. 程序所在的线程死亡。
  4. 关闭CPU。
  
  下面这部分内容来自issue:<https://github.com/Snailclimb/JavaGuide/issues/190>。
  
  **注意：** 当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下：
  
  ```java
      public static int f(int value) {
          try {
              return value * value;
          } finally {
              if (value == 2) {
                  return 0;
              }
          }
      }
  ```
  如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。
  
  ## 集合
  
  ### 简述一下集合主要有哪些类和接口，各自有什么特点。(★★★)
  ![a0c0e8e1.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\a0c0e8e1.png)
  ![02593bdc.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\02593bdc.png)
  1. 主要有两个接口Collection和Map.
  2. Collection包括List,Set和Queue
  3. Map以key-value键值对的形式存储元素,包括：HashMap、LinkedHashMap和TreeMap。
  
  ### Collection和Collections有什么区别 (★)
  1.Collection是一个集合接口，它包括List有序结合，Set无序集合，Queue队列等。
  2.Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll 可以直接对Collection集合批量的添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或按比较器进行排序。
  
  ### List和Set比较（★★★★）
  List,Set都是继承自Collection接口,两者最重要的区别在于List中允许插入重复元素，Set中不允许插入重复元素。
  List特点：元素有顺序，元素可重复; 
  - ArrayList底层通过数组实现，线程不安全，插入移除元素慢，随机访问快。
  - Vector是线程安全的ArrayList，但效率较低。
  - LinkedList底层通过双向链表实现，插入移除元素快，随机访问慢，顺序访问快。
  - Stack继承自Vector，实现一个后进先出的堆栈。
  
  Set特点：元素无顺序(HashSet)，元素不可重复，重复元素会覆盖掉，
  - HashSet底层其实就是HashMap，利用了key来保证元素唯一性，(无顺序)
  - LinkedHashSet可以按照key的操作顺序排序,即保证元素添加的自然顺序。
  - TreeSet支持按照默认或指定的排序规则排序,即保证元素的自然顺序。
  
  ### List和Vector比较
  Vector和ArrayList一样，都是通过数组实现的，但是Vector是线程安全的。和ArrayList相比，其中的很多方法都通过同步（synchronized）处理来保证线程安全，但是这样就导致了Vector在效率上无法与ArrayList相比。
  两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同，Vector可以设置增长因子，而ArrayList不可以。
  
  ### List,Set,Map有什么区别？ (★★)
  1.List是有序，可重复，有索引的集合，继承了Collection集合全部功能除了Collection的三种遍历方式外，可用索引遍历。
  2.Set是无序，不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或者自定义的比较规则排序。
  3.Map是无序，以Key-value的键值对形式存储元素的集合。键不可重复，重复的键对应的值会覆盖之前的值。
  [Java中的Set总结 - 简书](https://www.jianshu.com/p/d6cff3517688)
  [Java中的List总结 - 简书](https://www.jianshu.com/p/1149f1bf1736)
  [Java中的Map总结 - 简书](https://www.jianshu.com/p/27577315af0c)
  [java中List 和 Set 的区别 - 晓乎 - 博客园](https://www.cnblogs.com/helloworldcode/p/12122072.html)
  
  ### 理解HashMap
  #### HashMap的特点 (★★★)
  1. HashMap基于Map接口实现，元素以键值对的方式存储，　
  2. HashMap允许空键和空值（但空键只有一个，且放在第一位）
  3. HashMap中key不允许重复。
  4. HashMap是无序的，顺序会不定时改变。
  5. HashMap是线程不安全的。
  6. HashMap的初始容量为16,填充因子默认是0.75。
  #### HashMap的实现方式(★★)
  1. JDK1.8之前，HashMap的底层是数组加链表实现，数组中的每个元素都是一个单链表，链表中每个元素都是Entry的一个实例，其中有四个属性key,value,hash,next,HashMap在查找数据时，根据hash值可以快速定位到数组的小标，然后对链表进行遍历查找。
  2. JDK1.8之后，HashMap底层改为数组+链表+红黑树，当链表长度超过阈值8时，将链表转换为红黑树，使得性能上进一步得到提升。
  
  #### HashMap的哈希冲突(★★★)
  HashMap的实现使用一个数组，每个数组项里面有一个链表的方式来实现，因为HashMap使用key的hashCode来寻找存储位置，不同的key可能具有相同的hashCode.如果在插入时发现存储地址已经被相同的hashCode占用，则导致了哈希冲突。
  
  #### HashMap的哈希冲突解决(★★)
  1.8之前
  HashMap采用链地址法的方式，即，将相同hashcode值的对象组成一个链表，放在数组的某一项中。
  1.8之后
  HashMap同样采用链地址法的方式解决冲突，不同点在于如果链表长度大于8，会将链表转换为红黑树的形式。
  
  #### 负载因子为什么是0.75(★★)
  负载因子代表着HashMap的填充度，负载因子越大，填充的元素就越多，空间利用率就越高。但是发生碰撞冲突的机会就越大，链表的长度越来越长，查找的效率就会降低。负载因子越小，填充的元素就越少，发生碰撞冲突的机会就越少。因此0.75属于时间和空间成本上一种折衷的设定。
  
  #### 什么是resize机制
  HashMap的扩容机制就是重新申请一个容量是当前的2倍的新数组，然后将原先的记录逐个重新映射到新的数组里面，然后将原先的数组逐个置为null使得引用失效。
  
  #### HashMap为什么不安全？(★★)
  
  1. JDK7时多线程下扩容会造成死循环。
  2. 多线程的put可能导致数据丢失。
  3. put和get并发时可能导致get为null，数据被覆盖。
  
  [谈谈HashMap为什么是线程不安全的？_hashmap为什么线程不安全_爪哇酱子的博客-CSDN博客](https://blog.csdn.net/m0_55611144/article/details/126223558)
  
  ### HashTable的特点
  1. HashTable实现了Map接口和Dictionary抽象类。
  2. HashTable的key、value都不可以为null。
  3. Hashtable初始容量为11,填充因子默认是0.75。
  4. Hashtable线程安全。
  
  ### HashSet的特点
  1. 向Hashset中添加元素, 实际上是把这个元素作为键添加到底层的HashMap中.
  2. HashSet实际上就是底层HashMap的键的集合.
  3. HashSet底层是HashMap.
  
  ### ConcurrentHashMap的特点 (★★)
  1. HashMap功能基本一致，主要是为了解决HashMap线程不安全问题；
  2. 不允许空值和空键
  3. jdk1.7之前ConcurrentHashMap通过使用分段锁来实现线程安全，内部细分为很多Segment数据段，每个Segment的数据段单独进行加锁操作，这样多个线程对多个不同的段的操作是不会相互影响的。Segment是数组和链表结构，每个Segment里面都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据，若进行修改必须先获得对应的Segment锁，若发生hash冲突采用链表存储。
  4. 因为在jdk1.7中还是数组加链表的方式，因此在查询的时候，仍然会遍历链表，导致效率很低。因此jdk1.8在遍历上采用红黑树的方式进行了优化。
  5. jdk1.8中的ConcurrentHashMap将Segment块换成了Node，每个Node有自己的锁，每个Node里面包含一个HashEntry数组。若发生hash冲突，先使用链表存储，后面当链表长度超过8后会转换为红黑树来优化。
  
  ![71728073.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\71728073.png)
  
  ### 迭代器是什么?(★★)
  1.迭代器实现了iterator接口，是用于遍历Collection集合元素的一个指针。
  2.主要有三个方法
    1）通过iterator()获得集合的迭代器
    2）通过hasNext()判断集合当中是否还有元素，如果有返回true,没有则返回false. 初始化迭代器位于第一个元素之前。
    3）通过next()获取集合的下一个元素，并向后移动一个元素的单位。
  
  ### 有哪些线程安全的集合类？(★★)
  1.Vector,是线程安全的ArrayList,底层用数组实现，通过synchronized修饰方法保证线程安全。
  2.HashTable是线程安全的HashMap,继承自Dictionary,通过synchronized修饰方法保证线程安全。性能较差
  3.ConcurentHashMap,线程安全的HashMap,通过分段锁实现线程安全，性能较好。
  
  ## 多线程
  ### 创建线程有哪几种实现方式？分别有什么优缺点？（★★★）
  1.继承Thread 类，重写run()方法
    优点：编码简单，
    缺点：不能继承其它类
  2.实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。
    优点：可以继承其它类，避免了单继承的局限性；适合多个相同程序代码的线程共享一个资源，实现解耦操作，代码和线程独立。
    缺点：实现相对复杂
  3.实现Callable接口，重写Call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。
    优点:是相比方式二可以获取返回值。
    缺点：实现复杂。
  ```
  import java.util.concurrent.Callable;
  import java.util.concurrent.ExecutionException;
  import java.util.concurrent.FutureTask;
  class CallableThread implements Callable<String> {
      @Override
      public String call() throws Exception {
          for (int i = 0; i < 10; i++) {
              System.out.println("线程执行 x = "+i);
          }
          return "xbhog";
      }
  }
  
  public class Callable接口实现多线程 {
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          //将Callable实例化包装在FutureTask类中，这样就可以与Runnable接口关联
          FutureTask<String> task = new FutureTask<String>(new CallableThread());
          //线程启动
          new Thread(task).start();
          //获取call()的返回值
          System.out.println("【线程返回数据】："+task.get());
      }
  }
  ```
  4.通过线程池创建。
  ### 线程有哪些状态 （★★）
  1.New:用new操作创建一个新线程，此时程序还未开始运行线程中的代码
  2.Runnable: 调用start()方法后进入可运行状态。
  3.Blocked:阻塞状态，内部锁获取失败时进入阻塞状态。
  4.Waiting:等待其他线程唤醒时进入等待状态。
  5.Timed Waiting:计时等待，带超时参数的方法，例如Sleep(Long time)
  6.Terminated:终止状态，线程正常运行完毕或未捕获异常终止。
    
  ### 什么是线程安全问题，如何解决？（★★）
  线程安全问题：当多个线程共享一个全局变量，对其做写操作时，可能会受到其他线程的干扰，从而引发线程安全问题，表现形式为数据的缺失，数据 不一致等。
  
  线程安全问题的解决思路：
  
  1. 尽量不使用共享变量，将不必要的共享变量变成局部变量来使用。
  2. 使用synchronized关键字同步代码块，或者使用jdk包中提供的Lock为操作进行加锁。
  3. 使用ThreadLocal为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响。
  
  [Java并发编程：synchronized - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3923737.html)
  [Java并发编程：Lock - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3923167.html)
  [什么是线程安全问题？如何解决？_吴师兄学算法](https://www.cxyxiaowu.com/19700.html)
  
  ### 说一说volatile关键字的作用 
  #### 使用volatile的背景（★★）
  volatile主要是为了解决JMM中工作内存与主内存同步延迟现象导致的可见性问题，以及指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。
  
  #### volatile的特性 （★）
  1. 保证此变量对所有的线程的可见性。
  保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总数可以被其他线程立即得知，**但是对于volatile变量运算操作在多线程环境并不保证安全性。**
  
  2. 禁止指令重排序优化。
  volatile关键字通过内存屏障的方式实现禁止指令重拍优化，内存屏障是一个CPU的指令，他有两个作用，第一种保证特定操作的执行顺序，第二种保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。
  
  3. 保证特定操作的执行顺序：
  由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条内存屏障则会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。
  
  4. 保证某些变量的内存可见性：
  强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。
  
  5. 轻量级sychronized
  在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。
  
  ### 说一说synchronized关键字的作用 （★★★）
  原子性：被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。
  可见性：synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。
  有序性：synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。
  
  总结：能够保证同一时刻最多只有一个线程执行该段代码,以保证并发安全的效果
  
  ### volatile和synchronized的区别？（★★★）
  1.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
  2.volatile仅能实现变量的修改可见性，并不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
  3.volatile是一种轻量级的同步机制，在访问volatile修饰的变量时并不会执行加锁操作，线程不会阻塞，使用synchronized加锁会阻塞线程。
  
  ### 讲一讲ReentrantLock
  1.ReentrantLock是Lock接口的实现类，是一个可重入锁，通过AQS实现。
  2.支持公平锁与非公平锁，还提供了可响应中断锁（线程在等待锁的过程中可以根据需要取消对锁的请求，通过interrupt方法中断）、可轮询锁（通过tryLock获取锁，如果有可用锁返回true否则立即返回false）、定时锁（通过带long时间参数的tryLock方法获取锁，如果在给定时间内获取到可用锁且当前线程未被中断返回true，如果超过指定时间则返回false，如果获取锁时被终断则抛出异常并清除已终止状态）等避免死锁的方法。
  3.通过lock和unlock方法显式地加锁和释放锁。
  
  ### synchronized和ReentrantLock有哪些区别？
  1.synchronized是隐式锁，ReentrantLock是显式锁，使用时必须在finally代码块中进行释放锁的操作。
  2.synchronized是非公平锁，ReentrantLock可以实现公平锁。
  3.ReentrantLock可响应中断，可轮回，为处理锁提高了更多灵活性。
  4.synchronized是一个关键字，是JVM级别，ReentrantLock是一个接口，是API级别。
  5.synchronized采用悲观并发策略，ReentrantLock采用的是乐观并发策略，会先尝试以CAS方式获取锁。
  
  ### Lock接口有哪些方法？（★）
  1.lock()：给对象加锁。
  2.tryLock()/tryLock(long time,TimeUnit unit)：尝试给对象加锁，成功返回true，可以无参也可以指定等待时间。
  3.unlock()：释放锁，锁只能由持有者释放否则抛出异常。
  4.newCondition()：创建条件对象，使用条件对象管理那些已经获得锁但不满足有效条件的线程，调用await()方法把线程进入等待集，调用sign()/signAll()解除阻塞。5.lockInterruptibly()：如果当前线程未被中断则获取该锁。
  
  ### synchronized和Lock有哪些区别？ (★★)
  1.synchronized是关键字，是JVM层面的，而Lock是一个接口，是JDK层面的.
  2.synchronized会自动释放锁，而Lock必须手动释放锁。
  3.synchronized是不可中断的，Lock可以中断也可以不中断。
  4.synchronized能锁住方法和代码块，而Lock只能锁住代码块。
  5.Lock可以使用读锁提高多线程读效率。
  
  ### Java中的锁有什么作用？有哪些分类？
  1.Java中的锁主要用于保障多并发情况下数据的一致性，线程必须先获取锁才能进行操作，可以保证数据的安全。
  2.从乐观和悲观的角度可以分为乐观锁和悲观锁。
  3.从获取资源的公平性可以分为公平锁和非公平锁。
  4.从是否共享资源的角度可以分为共享锁和排它锁。
  5.从锁的状态角度可分为偏向锁、轻量级锁和重量级锁。同时在JVM中还设计了自旋锁以更快地使用CPU资源。
  
  ### 讲一讲乐观锁和悲观锁
  1.乐观锁:采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁。但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法，具体过程为：比较当前版本号与上一次的版本号，如果一致则更新，否则重复进行读、比较、写操作。Java中的乐观锁是基于CAS操作实现的，CAS是一种原子性操作，在对数据更新之前先比较当前值和传入的值是否一样，一样则更新否则直接返回失败状态。
  2.悲观锁:采用悲观的思想处理数据，每次读取数据时都认为别人会修改数据，所以每次都会上锁，其他线程将被阻塞。Java中的悲观锁基于AQS实现，该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到则会转为悲观锁。
  
  ### 讲一讲自旋锁
  1.自旋锁认为如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等待小段时间，在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致锁时间消耗。
  2.优点：减少CPU的上下文切换，对于占用锁时间非常短或锁竞争不激烈的代码块来说性能很高。
  3.缺点：在持有锁的线程长时间占用锁或竞争过于激烈时，线程会长时间自旋浪费CPU资源，有复杂锁依赖的情况不适合使用自旋锁。
  
  ### 讲一讲公平锁与非公平锁
  1.公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给排队时间最长的线程。
  2.非公平锁指在分配锁时不考虑线程排队等待的情况，直接尝试获取锁，获取不到锁就在排到队尾等待。
  3.因为公平锁需要在多核情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁，ReentrantLock默认的lock方法也是非公平锁。
  
  ### 讲一讲读写锁
  1.Lock接口提供的锁是普通锁，为了提高性能Java提供了读写锁，读写锁分为读锁和写锁，读锁之间不互斥，读锁与写锁，写锁之间都互斥。
  2.如果系统要求共享数据可以同时支持很多线程并发读，但不能支持很多线程并发写，那么读锁能大大提高效率。如果系统要求共享数据在同一时刻只能有一个线程在写，且写的过程中不能读，则需要使用写锁。
  3.提高juc的locks包中ReadWriteLock的实现类ReentrantReadWriteLock的readLock()和writeLock()来分别获取读锁和写锁。
  
  ### 讲一讲共享锁与排它锁
  1.共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。
  2.排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。
  3.排它锁是一种悲观的加锁策略，同一时刻只允许一个线程读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。
  
  ### 锁有哪些状态？
  1. 无锁，偏向锁，轻量级锁和重量级锁。
  2. 重量级锁是基于操作系统互斥量实现的，会导致进程在用户态和内核态之间来回切换，开销较大，synchronized内部基于监视器实现，监视器基于底层操作系统实现，因此属于重量级锁，运行效率不高。JDK1.6后为了减少获取锁和释放锁带来的性能消耗提高性能，引入了轻量级锁和偏向锁。
  3. 轻量级锁是相对于重量级锁而言的，核心设计实在没有多线程竞争的前提下，减少重量级锁的使用来提高性能。适用于线程交替执行同步代码块的情况，如果同一时刻有多线程访问同一个锁，会导致轻量级锁膨胀成重量级锁。
  4. 偏向锁用于在某个线程获取某个锁后，消除这个线程锁重入的开销，看起来似乎是这个线程得到了锁的偏袒。偏向锁的主要目的是在同一个线程多次获取某个所的情况下尽量减少轻量级锁的执行路径，因为轻量级锁需要多次CAS操作，而偏向锁只需要切换ThreadID时执行一次CAS操作，提高效率。出现多线程竞争锁时，JVM会自动撤销偏向锁。偏向锁是进一步提高轻量级锁性能的。
  5. 随着锁竞争越来越严重，锁可能从偏向锁升级到轻量级锁再到重量级锁，但在Java中只会单向升级不会降级。
  
  ### 如何进行锁优化？
  1.减少锁持有的时间：只在有线程安全要求的程序上加锁来尽量减少同步代码块对锁的持有时间。
  2.减小锁粒度：将单个耗时较多的锁操作拆分为多个耗时较少的锁操作来增加锁的并行度，减少同一个锁上的竞争。在减少锁的竞争后，偏向锁、轻量级锁的使用率才会提高，例如ConcurrentHashMap中的分段锁。
  3.读分离：指根据不同的应用场景将锁的功能进行分离以应对不同的变化，最常见的锁分离思想就是读写锁，这样既保证了线程安全又提高了性能。
  4.锁粗化：指为了保障性能，会要求尽可能将锁的操作细化以减少线程持有锁的时间，但如果锁分的太细反而会影响性能提升，这种情况下建议将关联性强的锁操作集中处理。
  5.锁消除：注意代码规范，消除不必要的锁来提高性能。
  
  ## 线程池
  
  ### 线程池是什么? (★)
  线程池是一块缓存了一定线程数量的区域，用于复用线程和管理线程
  ### 为什么需要线程池? (★)
  线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销。
  当请求到达时不会出现等待线程而延迟任务的执行，提高了响应性。
  通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。
  
  ### 核心参数
  | 参数            | 意义                            | 说明                                                                                                                   |
  | --------------- | ------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
  | corePoolSize    | 核心线程数                      | 即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。                             |
  | maximumPoolSize | 线程池所能容纳的最大线程数      | 当活动线程数到达该数值后，后续的新任务将会阻塞，表示在线程池中最多能创建多少个线程；                                                                         |
  | keepAliveTime   | 非核心线程闲置超时时长          | 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize |
  | unit            | 指定keepAliveTime参数的时间单位 | 可选的参数为TimeUnit枚举中的几个静态变量： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。                          |
  | workQueue       | 任务队列                        | 通过线程池的execute()方法提交的Runnable对象，将存储在该参数中                                                          |
  | thread factory  | 线程工厂                        | 为线程池创建新线程，                                                                                                   |
  | handler         | 所用的拒绝执行处理策略          | ThreadPoolExecutor 类有4 种默认的拒绝策略 AbortPolicy，DiscardPolicy，DiscardOldestPolicy，CallerRunsPolicy            |
  
  ### 线程池的拒绝策略
  当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize时，如果还有任务到来就会采取任务拒绝策略。
  通常有以下四种策略：
  1. ThreadPoolExecutor.AbortPolicy
  这种拒绝策略在拒绝任务时，会直接抛出一个类型为 RejectedExecutionException 的 RuntimeException，让你感知到任务被拒绝了，于是你便可以根据业务逻辑选择重试或者放弃提交等策略。
  
  2. ThreadPoolExecutor.DiscardPolicy
  当有新任务被提交后直接被丢弃掉，也不会给你任何的通知，相对而言存在一定的风险，因为我们提交的时候根本不知道这个任务会被丢弃，可能造成数据丢失。
  
  3. ThreadPoolExecutor.DiscardOldestPolicy
  丢弃任务队列中的头结点，通常是存活时间最长的任务，它也存在一定的数据丢失风险。
  
  4. ThreadPoolExecutor.CallerRunsPolicy
  当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。
  
  ### 自定义拒绝策略
  实现 RejectedExecutionHandler 接口来实现自己的拒绝策略，如代码所示：
  ```
  private static class CustomRejectionHandler implements RejectedExecutionHandler{
    @Override
    public void rejectedExecution(Runnable r,ThreadPoolExecutor executor){
    }
  }
  ```
  
  ### 线程池使用流程
  ```
  // 1. 创建线程池
     // 创建时，通过配置线程池的参数，从而实现自己所需的线程池
     Executor threadPool = new ThreadPoolExecutor(
                                                CORE_POOL_SIZE,
                                                MAXIMUM_POOL_SIZE,
                                                KEEP_ALIVE,
                                                TimeUnit.SECONDS,
                                                sPoolWorkQueue,
                                                sThreadFactory
                                                );
  // 2. 向线程池提交任务：execute（）
      // 说明：传入 Runnable对象
         threadPool.execute(new Runnable() {
              @Override
              public void run() {
                  ... // 线程执行任务
              }
          });
  
  // 3. 关闭线程池shutdown() 
    threadPool.shutdown();
    
    // 关闭线程的原理
    // a. 遍历线程池中的所有工作线程
    // b. 逐个调用线程的interrupt（）中断线程（注：无法响应中断的任务可能永远无法终止）
  
    // 也可调用shutdownNow（）关闭线程：threadPool.shutdownNow（）
    // 二者区别：
    // shutdown：设置 线程池的状态 为 SHUTDOWN，然后中断所有没有正在执行任务的线程
    // shutdownNow：设置 线程池的状态 为 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表
    // 使用建议：一般调用shutdown（）关闭线程池；若任务不一定要执行完，则调用shutdownNow（）
  ```
  
  ### 创建线程池的方法有哪些？(★★★)
  可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。
  1.newFixedThreadPool:
  作用：**创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。**
  
  特征： 
  （1）线程池中的线程处于一定的量，可以很好的控制线程的并发量 
  （2）线程可以重复被使用，在显示关闭之前，都将一直存在 
  （3）超出一定量的线程被提交时候需在队列中等待
  
  创建方式： 
  （1）Executors.newFixedThreadPool(int nThreads)；//nThreads为线程的数量 
  （2）Executors.newFixedThreadPool(int nThreads，ThreadFactory threadFactory)；//nThreads为线程的数量，threadFactory创建线程的工厂方式'
  
  2.newCachedThreadPool:
  作用：**创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。**
  
  特征： 
  （1）线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE） 
  （2）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟） 
  （3）当线程池中，没有可用线程，会重新创建一个线程
  
  创建方式： Executors.newCachedThreadPool();
  
  3.newSingleThreadExecutor:
  作用：**创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。**
  
  特征： 
  （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行
  
  创建方式： 
  （1）Executors.newSingleThreadExecutor() ； 
  （2）Executors.newSingleThreadExecutor(ThreadFactory threadFactory)；// threadFactory创建线程的工厂方式
  
  4.newScheduledThreadPool:
  作用：**创建一个定长线程池，支持定时及周期性任务执行。**
  
  特征： 
  （1）线程池中具有指定数量的线程，即便是空线程也将保留 
  （2）可定时或者延迟执行线程活动
  
  创建方式： 
  （1）Executors.newScheduledThreadPool(int corePoolSize)；// corePoolSize线程的个数 
  （2）newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)；// corePoolSize线程的个数，threadFactory创建线程的工厂
  
  5.newSingleThreadScheduledExecutor
  作用：**创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。**
  
  特征： 
  （1）线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行 
  （2）可定时或者延迟执行线程活动
  
  创建方式： 
  （1）Executors.newSingleThreadScheduledExecutor() ； 
  （2）Executors.newSingleThreadScheduledExecutor(ThreadFactory threadFactory) ；//threadFactory创建线程的工厂
  
  
  ### 线程池的工作原理？
  [Java并发编程：线程池的使用 - Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/p/3932921.html)
  
  ### Executor 与Executors的区别
  1.Executor 接口对象能执行我们的线程任务；
  2.Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。
  ExecutorService 接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能够获得任务执行的状态并且可以获取任务的返回值。
  
  ### 简述ExecutorService的生命周期
  1.ExecutorService的生命周期有3种状态：运行、关闭和已终止。
  2.ExecutorService在初始创建时处于运行状态。
  3.shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。在ExecutorService关闭后提交的任务将有“拒绝执行处理器REH”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。
  4.等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已终止。通常在调用awaitTermination后会理解调用shutdown，从而产生同步地关闭ExecutorService的效果。
  
  ### CAS的概念 (★)
  CAS指Compare And Swap，比较并交换,
  - 解决多线程并行情况下使用锁造成性能损耗的一种机制
  - CAS 是一条 CPU 的原子指令
  - 需要底层硬件支持
  
  CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。
  在 Java 中，Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的，直到后来JNI的出现，使得Java通过C++方法实现CAS。
  
  #### 为什么使用CAS (★)
  
  独占锁是一种悲观锁，synchronized 就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。
  而另一个更加有效的锁就是乐观锁， CAS 就是一种乐观锁，所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果冲突就重试，直到成功为止。
  
  #### CAS有什么问题？(★)
  1.CAS算法地实现有一个重要前提：需要取出内存中某时刻的数据，然后在下一刻进行比较、替换，但在这个时间差内数据可能已经发生了变化，导致ABA问题。
  2.由于CAS操作的原子性来源于硬件的支撑，而硬件只支持单个变量的原子操作，因此CAS只能针对单个变量原子进行操作。
  
  ### 什么是ABA? (★)
  线程1准备利用CAS修改变量值A，但是在修改之前，其他线程已经将A变成了B，然后又变成A，即A->B->A,线程1执行CAS的时候发现仍然为A，所以CAS会操作成功，但是其实目前这个A已经是其他线程修改的了，但是线程1并不知道，最终内存值变成了B，这就导致了ABA问题。
  
  #### 如何解决ABA问题。(★)
  1. 在变量前面追加版本号：每次变量更新就把版本号加1，则A-B-A就变成1A-2B-3A。
  2. atomic包下的AtomicStampedReference类：其compareAndSet方法首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用的该标志的值设置为给定的更新值。
  
  [沉淀再出发：java中的CAS和ABA问题整理 - 精心出精品 - 博客园](https://www.cnblogs.com/zyrblog/p/9864932.html)
  
  ### 讲一讲wait、sleep、yield、join方法的区别 （★★★）
  1.wait是Object类的方法，调用wait方法的线程会进入等待(WAITING)状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法释放锁资源。
  2.sleep是Thread类的方法，调用sleep方法导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是计时等待(TIMED-WAITING)状态。
  3.yiled是Thread类的方法，yiled方法使当前线程让出CPU时间片给优先级相同或更高的线程，回到就绪状态(Runnable)与其他线程一起重新竞争CPU时间片。
  4.join是Thread类的方法，join方法使当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就就绪状态(Runnable)。
  ### wait，sleep的区别 (★★★★)
  #### wait, sleep的相同点
  wait和sleep均能使线程处于等待状态
  #### 定义上区别
  wait方法定义在Object里面，基于对象锁，所有的对象都能使用。
  sleep方法定义在Thread里面，是基于当前线程。
  #### 条件区别
  wait必须在同步环境（synchronized方法）下使用，否则会报IllegalMonitorStateException异常。
  sleep方法可在任意条件下使用。
  #### 功能区别
  wait/notify一起使用，用于线程间的通信，wait用于让线程进入等待状态，notify则唤醒正在等待的线程。
  sleep用于暂停当前线程的执行，它会在一定时间内释放CPU资源给其他线程执行，超过睡眠时间则会正常唤醒。
  #### 锁的持有区别
  在同步环境中调用wait方法会释放当前持有的锁
  调用sleep则不会释放锁，一直持有锁（直到睡眠结束）
  
  
  ### 什么是守护线程？
  1.守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。守护线程不依赖于终端，但是依赖于JVM，当JVM中仅剩下守护线程时，JVM就会退出。
  2.通过setDaemon方法定义一个守护线程，守护线程的优先级较低，将一个用户线程设置为守护线程必须要在启动守护线程之前。
  
  ### start和run方法的区别？
  1.start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。
  2.run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。
  
  ### 进程和线程有什么区别？(★)
  - 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
  - 一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
  - 每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
  - 一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。
  
  ### 死锁产生的原因和解决方法？
  1. 死锁是多个进程竞争共享资源而造成互相等待的僵局，若无外力作用这些进程都将无法向前推进。
  2. 死锁产生的原因是非剥夺资源的竞争和进程的不恰当推进顺序。
  3. 预防死锁：破坏互斥条件、破坏不剥夺条件、破坏请求和保持条件、破坏循环等待条件。
  4. 预防死锁：安全状态：能找到一个分配资源的序列让所有进程都顺序完成。银行家算法：采用预分配策略检查分配完成时系统是否处于安全状态。
  5. 检测死锁：利用死锁定理化简资源分配图检测死锁的存在。
  6. 解除死锁：资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便其他线程继续推进。撤销进程法：强制撤销部分、甚至全部进程并抢夺其资源，以便让其他进程继续推进。进程回退法：让一个或多个进程回退到足以避免死锁的地步
  
  ## Java内存模式(JMM) 
  
  ### Java 内存区域 (★★★)
  Java 内存区域和内存模型是不一样的东西，内存区域是指 Jvm 运行时将数据分区域存储，强调对内存空间的划分。
  ![77755c6c.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\77755c6c.png)
  Java虚拟机(JVM)在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有的用途以及创建销毁的时机，其中蓝色部分代表的是所有线程共享的数据区域，而绿色部分代表的是每个线程的私有数据区域。
  
  - 方法区:
  方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。
  
  - JVM堆:
  Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC 堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。
  
  - 程序计数器:
  属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
  
  - 虚拟机栈:
  属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程，如下（图有误，应该为栈桢）：
  
  - 本地方法栈:
  本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。
   
  ### Java内存模型(JMM)(★★★)
  **本身是一种抽象的概念，并不真实存在，它描述的是一种规则，通过规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式**
  
  ![c6369818.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\c6369818.png)
  
  #### 主内存
  主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。
  
  #### 工作内存
  主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。
  
  #### 主内存与工作内存的操作方式
  在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。
  ![198ec54c.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\198ec54c.png)
  
  ### JMM存在的必要性 (★★★)
  
  由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，用于存储线程私有数据，线程与主内存中主要过程是将变量从主内存拷贝到每个线程各自的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，**如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。**
  
  ![f4ac75d9.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\f4ac75d9.png)
  主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在不一致问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x=2。
  
  **为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入，然后何时对另一个线程可见，这组规则也称为Java内存模型（即JMM）** 
  
  ### JMM的三个特征 (★★)
  
  #### 原子性
  
  **原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响**,JMM中提供以下方式来保证原子性:
  - 自带原子性保证：在java中，对基本数据类型的变量的读取和赋值操作是原子性操作。
  - synchronized：synchronized可以防止多个线程并发的执行同一段代码，从结果上保证原子性。
  - Lock锁：Lock锁保证原子性。
  
  #### 可见性
  
  **可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值**,JMM中提供以下方式来保证可见性:
  - volatile：使用volatile关键字修饰一个变量可以保证变量的可见性。
  - synchronized：使用synchronized可以保证共享变量的可见性。
  - Lock锁：使用Lock可以保证共享变量的可见性。
  
  #### 有序性
  **程序执行的顺序按照代码的先后顺序执行**，JMM中提供以下方式来保证有序性:
  - happens-before原则是java内存模型中定义的两项操作之间的偏序关系。
  - synchronized可以保证同一时间只有一个线程访问代码块。
  - volatile可以保证变量不会被编译器重排序。
  
  ## JVM
  ### 类加载器的原理
  程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。
  
  ### JVM中类加载的过程
  虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型
  [深入浅出Java类加载过程 - 神仙果 - 博客园](https://www.cnblogs.com/luohanguo/p/9469851.html)
  ![14265221-905453ee556fc809.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bf372989.png)
  #### 加载 （★★）
  1.JVM将.class文件读入内存，并为创建一个class对象。
  2.任何类被使用时系统都会为其创建一个且仅有一个class对象。
  3.这个class对象描述了这个类创建出来的对象的所有信息，比如构造方法，成员方法，成员变量等。
  ![3caf24a0.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\3caf24a0.png)
  
  #### 链接 （★★）
  将java类的二进制代码合并到JVM的运行状态之中。
  
  验证:验证class文件的字节流是否符合jvm规。
  
  准备:正式为类变量（static变量）分配内存并设置类变量初始值。
  
  解析:虚拟机常量池内的符号引用替换为直接引用的过程。
  
  #### 初始化（★★）
  
  **初始化顺序**
  1、父类的静态变量
  2、父类的静态代码块
  3、子类的静态变量
  4、子类的静态代码块
  5、父类的非静态变量
  6、父类的非静态代码块
  7、父类的构造方法
  8、子类的非静态变量
  9、子类的非静态代码块
  10、子类的构造方法
  
  ### 类加载器的分类（★）
  ![14265221-549d6e3ca7ab0b5a.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bb6f8847.png)
  #### 引导类加载器(bootstrap class loader)
  （1）它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自java.lang.ClassLoader。
  （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。
  
  #### 扩展类加载器(extensions class loader)
  （1）用来加载 Java 的扩展库(JAVA_HOME/jre/ext/* .jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
  （2）由sun.misc.Launcher$ExtClassLoader实现。
  
  #### 应用程序类加载器(application class loader)
  （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
  （2）由sun.misc.Launcher$AppClassLoader实现。
  
  #### 自定义类加载器
  （1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。
  
  ### 类加载器的代理模式-双亲委托机制（★）
  
  某个特定的类加载器接收到类加载的请求时，会将加载任务委托给自己的父类，直到最高级父类引导类加载器（bootstrap class loader），如果父类能够加载就加载，不能加载则返回到子类进行加载。如果都不能加载则报错。ClassNotFoundException
  ![2019062814264974.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\90ad5fee.png)
  
  ### 为什么使用双亲委托模型（★）
  使得java类随着它的类加载器一起具有一种带有优先级的层级关系，从而使得基础类得到统一。
  例如：例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。
  
  ### 简述JVM的内存区域
  JVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存。
  1.程序计数器是一块很小的内存空间，用于存储当前线程执行字节码文件的行号指示器。
  2.虚拟机栈是描述Java方法执行过程的内存模型，帧栈中存储了局部变量表，操作数栈，动态链接，方法出口等信息。
  3.本地方法区，和虚拟机栈作用类似，区别是虚拟机栈为Java方法服务，本地方法栈为Native方法服务。
  4.JVM运行过程中创建的对象和生成的数据都存储在堆中，堆是被线程共享的内存区域，也是垃圾回收最主要的内存区域。
  5.方法区用来存储常量，静态变量、类信息、即时编译器编译后的机器码、运行时常量池等数据。
  
  ### 谈一谈JVM的运行时内存
  JVM的运行时内存也叫做JVM堆，从GC角度更将其分为新生代，老年代和永久代。
  其中新生代默认占1/3堆空间，老年代默认占2/3堆空间，永久代占非常少的堆空间。
  新生代又分为Eden区、ServivorFrom区和ServivorTo区，Eden区默认占8/10新生代空间，ServivorFrom区和ServivorTo区默认分别占1/10新生代空间。
  
  ### 谈谈新生代的垃圾回收机制
  新生代的GC过程叫做MinorGC，采用复制算法实现，具体过程如下：
  1.把在Eden区和ServivorFrom区中存活的对象复制到ServivorTo区，如果某对象的年龄达到老年代的标准，则将其复制到老年代，同时把这些对象的年龄加1。如果ServivorTo区的内存空间不够，则也直接将其复制到老年代。如果对象属于大对象，则也直接复制到老年代。
  2.清空Eden区和ServivorFrom区中的对象。
  3.将ServivorFrom区和ServivorTo区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。
  
  ### 谈谈老年代的垃圾回收机制
  1.老年代主要存放有长生命周期的对象和大对象，老年代的GC叫MajorGC。
  2.在老年代，对象比较稳定，MajorGC不会频繁触发。在进行MajorGC前，JVM会进行一次MinorGC，过后仍然出现老年代空间不足或无法找到足够大的连续内存空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。
  3.MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。因为要先扫描老年代的所有对象再回收，所以MajorGC的时间较长。容易产生内存碎片，在老年代没有内存空间可分配时，会出现内存溢出异常。
  
  ### 谈一谈永久代
  1.永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在类加载时被放入永久代。
  2.永久代和老年代、新生代不同，GC不会在程序运行期间对永久代的内存进行清理，这也导致了永久代的内存会随着加载的Class文件的增加而增加，在加载的Class文件过多时会出现内存溢出异常，比如Tomcat引用jar文件过多导致JVM内存不足而无法启动。
  3.在JDK1.8中，永久代已经被元数据区取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此元空间的大小不受JVM内存的限制，只和操作系统的内存有关。
  4.在JDK1.8中，JVM将类的元数据放入本地内存中，将常量池和类的静态常量放入Java堆中，这样JVM能够加载多少元数据信息就不再由JVM的最大可用内存空间决定，而由操作系统的实际可用内存空间决定。
  
  
  ### 如何确定对象是否是垃圾
  1.Java采用引用计数法和可达性分析来确定对象是否应该被回收。引用计数法容易产生循环引用的问题，可达性分析通过根搜索算法实现。根搜索算法以一系列GC Roots的点作为起点向下搜索，在一个对象到任何GC Roots都没有引用链相连时，说明其已经死亡。根搜索算法主要针对栈中的引用、方法区的静态引用和JNI中的引用展开分析。
  2.引用计数法：在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引用计数减1；如果一个对象的引用计数为0，则表示此刻该对象没有被引用，可以被回收。引用计数法容易产生循环引用问题，循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收。
  3.可达性分析：为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以被回收。具体做法是首先定义一些GC Roots对象，然后以这些GC Roots对象作为起点向下搜索，如果在GC Roots和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象要经过至少两次标记才能判断其是否可被回收，如果两次标记后该对象仍然不可达，则将被垃圾回收器回收。
  
  ### 有哪些GC算法？分别有什么特点？
  #### 标记清除算法
  标记出所有需要回收的对象，然后清除可回收的对象。效率较低，并且因为在清除后没有重新整理可用的内存空间，如果内存中可被回收的小对象居多，会引起内存碎片化问题。
  
  #### 复制回收算法
  将可用内存分为区域1和区域2，将新生成的对象放在区域1，在区域1满后对区域1进行一次标记，将标记后仍然存活的对象复制到区域2，然后清除区域1。效率较高并且易于实现，解决了内存碎片化的问题，缺点是浪费了大量内存，同时在系统中存在长生命周期对象时会在两区域间来回复制影响系统效率。
  
  #### 标记整理算法
  结合了标记清除算法和复制算法的优点，标记过程和标记清除算法一样，标记后将存活的对象移动到一端，清理另一端。
  
  #### 分带收集算法
  根据对象不同类型把内存划分为不同区域，把堆划分为新生代和老年代。由于新生代的对象生命周期较短，主要采用复制算法。将新生代划分为一块较大的Eden区和两块较小的Survivor区，Servivor区又分为ServivorTo和ServivorFrom区。JVM在运行过程中主要使用Eden和SurvivorFrom区，进行垃圾回收时将这个两个区域存活的对象复制到SurvivorTo区并清除这两个区域。老年代主要存储长生命周期的大对象，因此采用标记清除或标记整理算法。
  
  ### java类的引用
  [JAVA类加载过程&主动引用和被动引用](https://www.baidu.com/link?url=ZaJO63OX4cc1VaIpQzrwvVJeltj2MMT179nj_yaFwtEF7-7K8IIrPTqjXY7PlHYR&wd=&eqid=b9cda6fb0010d68b000000045da6939f)
  #### 主动引用
  碰到如下四种情况才会触发主动引用：
  1. 使用new关键字实例化对象(new)
  ```
  package com.dhb.classload;
  
  public class NewClass {
  
      static {
          System.out.println("NewClass init ...");
      }
  
  }
   class Init1{
      public static void main(String[] args) {
          new NewClass();
      }
  }
  //输出结果：
  NewClass init ...
  ```
  2. 读取类的静态成员变量(getstatic)
  ```
  package com.dhb.classload;
  
  public class StaticAttributeClass {
  
      public static int value = 10;
  
      public static void staticMethod() {
  
      }
  
      static {
          System.out.println("StaticAttributeClass init ...");
      }
  }
  
  class Init2{
      public static void main(String[] args) {
          //1.读取静态变量
          int value = StaticAttributeClass.value;
      }
  }
  //输出结果
  StaticAttributeClass init ...
  ```
  3. 设置类的静态成员变量(setstatic)
  ```
  class Init2{
      public static void main(String[] args) {
          StaticAttributeClass.value = 5
      }
  }
  //输出结果
  StaticAttributeClass init ...
  ```
  4. 调用静态方法(invokestatic)
  ```
  class Init2{
      public static void main(String[] args) {
          StaticAttributeClass.staticMethod();
      }
  }
  //输出结果
  StaticAttributeClass init ...
  ```
  
  #### 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
  ```
  package com.dhb.classload;
  
  public class ReflectClass {
  
      static {
          System.out.println("ReflectClass init ...");
      }
  }
  class Init3{
      public static void main(String[] args) {
          try {
              Class clazz = Class.forName("com.dhb.classload.ReflectClass");
          } catch (ClassNotFoundException e) {
              e.printStackTrace();
          }
      }
  }
  //输出结果
  ReflectClass init ..
  ```
  
  #### 当初始化一个类的时候，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。
  ```
  package com.dhb.classload;
  
  public class SuperClass {
      static {
          System.out.println("SuperClass init ...");
      }
      public static int value = 10;
  }
  
  class SubClass extends SuperClass {
      static {
          System.out.println("SubClass init ...");
      }
  }
  
  class Init4 {
      public static void main(String[] args) {
          new SubClass();
      }
  }
  //输出结果
  SuperClass init ...
  SubClass init ...
  ```
  #### 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
  ```
  package com.dhb.classload;
  
  public class MainClass {
  
      static {
          System.out.println("MainClass init ...");
      }
  
      public static void main(String[] args) {
          System.out.println("main begin ...");
      }
  }
  //输出结果
  MainClass init ...
  main begin ...
  ```
  
  ### 被动引用
  #### 通过子类引用父类的静态字段，不会导致子类初始化
  ```
  package com.dhb.classload;
  
  public class SuperClass {
      static {
          System.out.println("SuperClass init ...");
      }
      public static int value = 10;
  }
  
  class SubClass extends SuperClass {
      static {
          System.out.println("SubClass init ...");
      }
  
  }
  
  class Init4 {
      public static void main(String[] args) {
          int value = SubClass.value;
      }
  }
  //输出结果
  SuperClass init ...
  ```
  
  #### 通过数组定义来引用，不会触发此类的初始化
  ```
  package com.dhb.classload;
  
  public class ArrayClass {
  
      static {
          System.out.println("ArrayClass init ...");
      }
  }
  class Init5{
      public static void main(String[] args) {
          ArrayClass[] arrays = new  ArrayClass[10];
      }
  }
  //输出结果为空
  ```
  
  #### 常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量初始化
  ```
  package com.dhb.classload;
  
  public class ConstClass {
      static {
          System.out.println("ConstClass init ...");
      }
  
      public static final int value = 10;
  }
  class Init6{
      public static void main(String[] args) {
          int value = ConstClass.value;
      }
  }
  //输出结果为空
  ```
  
  
  
  ### java对象引用
  [Java中四种引用 - 张界 - 博客园](https://www.cnblogs.com/pascall/p/10281775.html)
  #### 强引用
  如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
  ```
  String str = "hello";    // 强引用
  str = null;              // 取消强引用
  ```
  #### 软引用
  在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。
  ```
  SoftReference<String> softName = new  SoftReference<>("张三");
  ```
  #### 弱引用
  具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。
  ```
  WeakReference<String> weakName = new WeakReference<String>("hello");
  ```
  #### 虚引用
  如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
  虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
  ```
  ReferenceQueue<String> queue = new ReferenceQueue<String>();
  PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
  ```
  
  #### 浅拷贝和深拷贝的区别（★）
  [Java 浅拷贝和深拷贝 - 简书](https://www.jianshu.com/p/94dbef2de298)
  
  - 浅拷贝
  1. 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。
  2. 对于数据类型是引用数据类型的成员变量，如成员变量是某个数组、某个类的对象等，浅拷贝会进行引用传递，只将该成员变量的引用值（内存地址）复制一份给新对象。而实际上两个对象该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响另一个对象的成员变量值。
  
  - 深拷贝
  深拷贝是整个独立的对象拷贝，会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
  1. 对于数据类型是基本数据类型的成员变量，由于基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。
  2. 对于数据类型是引用数据类型的成员变量，如成员变量是某个数组、某个类的对象等，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。
  
  ## JAVA反射（★★）
  ### 概述 
  JAVA反射机制是在运行状态中，
  
  对于任意一个类，都能够知道这个类的所有属性和方法；
  
  对于任意一个对象，都能够调用它的任意一个属性和方法；
  
  这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制。
  
  ### 反射原理
  
  Java反射机制的原理主要是通过Class类来实现的。Class类是Java中反射机制的核心类，它可以在运行时动态地获取一个类的信息。Class类的实例对象可以通过三种方式获取：
  
  1. 使用Class.forName()方法获取Class对象。
  2. 使用类名.class获取Class对象。
  3. 使用对象.getClass()方法获取Class对象。
  
  获取到Class对象之后，就可以通过该对象来获取类的属性和方法，创建实例对象等。
  
  ### 关键类
  
  #### Constructor
  通过java.lang.reflect.Constructor来操作类的构造方法
  | 方法                                   | 含义                       |
  | -------------------------------------- | -------------------------- |
  | getConstructors()                      | 获得类的所有public构造方法 |
  | getDeclaredConstructors()              | 获得类的所有构造方法       |
  | getConstructor(Class[] parameterTypes) | 获得类的特定public构造方法 |
  | getDeclaredConstructor(Class[] params) | 获取类的特定构造方法       |
  
  #### Field
  通过java.lang.reflect.Field来获取和修改成员属性，其中getField和getDeclaredField的核心区别就是是否指定类型为public.
  | 方法                                   | 含义                       |
  | -------------------------------------- | -------------------------- |
  | getFields()                            | 获得类的所有public属性     |
  | getDeclaredFields()                    | 获得类的所有属性           |
  | getField(String name)                  | 获得类的特定public属性     |
  | getDeclaredField(String name)          | 获取类的特定属性           |
  
  #### Method
  通过java.lang.reflect.Method来执行成员方法
  | 方法                                                   | 含义                       |
  | ------------------------------------------------------ | -------------------------- |
  | getMethods()                                           | 获得类的所有public成员方法 |
  | getDeclaredMethods()                                   | 获得类的所有成员方法       |
  | getMethod(String name, Class[] parameterTypes)         | 获得类的特定public成员方法 |
  | getDeclaredMethod(String name, Class[] parameterTypes) | 获取类的特定成员方法       |
  
  #### Class类的原理
  Java程序在编译完成后，会把所有class文件中所包含的类的基本元信息装载到JVM内存中，以Class类的形式保存，每一个Class类对象代表一个具体类的基本元信息。我们的反射就是在Class类的基础上进行的，Class类对象存储着类的所有相关信息，就像镜子，故称“反射”。。
  
  [理解Java反射机制 - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2015/07/18/java-reflection/)
  [Java-反射机制（超详解）_java反射机制原理详解__GGBond_的博客-CSDN博客](https://blog.csdn.net/weixin_52533007/article/details/123312217)
  [面试官你要这么问我Java反射原理，我就笑了 - 知乎](https://zhuanlan.zhihu.com/p/142593317)
  [java反射机制原理详解_java的反射机制是怎么实现的_哥哥笑哈哈的博客-CSDN博客](https://blog.csdn.net/m0_56863607/article/details/129275027)
  
  ## Stream流
  
  ### 简单说说File对象表示的是什么？File类有哪些常用的方法？
  1.File对象表示的是操作系统上的文件或目录。
  2.获取：getAbsolutePath() 获取绝对路径；getPath() 获取文件定义时使用的路径；getName() 获取文件名，带后缀；length() 返回文件长度，单位是字节。
  3.判断：exists() 判断File对象表示的文件或目录是否存在；isDirectory() 判断是否是目录； isFile() 判断是否是文件。
  4.创建和删除：createNewFile() 不存在时创建新文件；delete() 删除文件，目录（非空目录不能删除）；mkdir() 创建一级目录；mkdirs() 创建多级目录，推荐使用；5.遍历：list 获取当前目录下所有一级文件名称到一个字符串数组并返回；listFiles 获取当前目录下所有一级File对象到File数组返回。
  
  ### 英文，数字和中文字符在文件中分别占多大的空间？
  1.英文和数字在任何编码中都占用1个字节
  2.中文字符在GBK编码下占2个字节，在UTF-8编码下占3个字节
  
  ### 简述传统Stream有哪些分类？
  1.按流的方向
    1）输出流：把内存中的数据写出到磁盘文件或者网络介质中
    2）输入流：把磁盘文件或网络介质中的数据读取到内存汇总。
  
  2.按流的内容
    1）字节流：流中的数据的最小单位是字节
    2）字符流：流中数据的最小单位是字符
    顶层的抽象类包括InputStream、OutPutStream、Reader、Writer、它们都实现了Closeable接口
  
  3.缓冲流（BufferedInputStream/BufferedOutputStream/BufferedReader/BufferedWriter）:自带一个8KB大小的缓冲池，可以将字节/字符流为缓冲字节/缓冲字符流，
  4.字符转换流（InputStreamReader/OutPutStreamWriter）:可以将对应的字节流转换为字符流，
  5.打印流（PrintStream）：方便快速打印数据，参数是什么就打印什么。
  
  ### 简述BIO,NIO,AIO的区别和原理
  1. BIO是同步阻塞的，数据的读写会阻塞在一个线程中，适用于连接数目比较小且固定的架构，对服务器资源要求高，JDK1.4前的唯一选择。
  2. NIO是同步非阻塞的，通过Selector监听Channel上事件的变化，在Channel上有数据变化时通知该线程进行读写操作。适用于连接数目比较多且连接比较短的架构，如聊天服务器，从 JDK1.4开始支持.
  3. AIO是异步非阻塞的，异步是指服务端线程接收到客户端管道后就交给底层处理IO通信，自己可以做其他事情。适用于连接数目比较多且连接比较长的架构，从JDK1.7开始支持。
  
  ### 序列化和反序列化是什么,有什么要求？
  1.Java在JVM运行时被创建、更新和消耗，当JVM退出时，对象也会随之销毁。可以通过Java序列化实现持久化存储，保存对象及其状态信息到字节数组中。
  2.反序列化就是再将字节数组中存储的信息转换回Java对象。
  3.要求类必须实现序列化接口，并且序列化和反序列化必须保持序列化的ID一致。
  4.静态变量和被transient修饰的变量不会被序列化。
  (transient:将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。)
  
  ## 文献
  [【7万字干货】2021Java实习必看面试两百题解析_资源分享_牛客网](https://www.nowcoder.com/discuss/395523?type=0&order=0&pos=16&page=0)
  
  [Matrix海子 - 博客园](https://www.cnblogs.com/dolphin0520/)
  
  [单例模式-双重检查加锁 - Michael2397 - 博客园](https://www.cnblogs.com/Michael2397/p/7599073.html)
  
  [设计模式六大原则：开闭原则 - 酷学大叔 - 博客园](https://www.cnblogs.com/az4215/p/11489712.html)
  
  [全面理解Java内存模型(JMM)及volatile关键字_zejian的博客-CSDN博客](https://blog.csdn.net/javazejian/article/details/72772461)
  
  
  
  
  
  
  
  
  
  
'''
linesHighlighted: [
  1361
  1420
  1376
  1419
]
isStarred: false
isTrashed: false
