createdAt: "2019-10-16T02:39:38.018Z"
updatedAt: "2020-04-15T05:44:13.653Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Java面试题"
tags: []
content: '''
  # Java面试题
  [TOC]
  ## 1、基础语法
  ### 字符串拼接的方式以及效率
  1. 使用+直接拼接，String 是final对象，不会被修改，每次使用+进行拼接都会创建新的对象，而不是改变原来的对象，效率低，是线程安全的。
  2. 使用StringBuffer可变字符串，是线程安装的（StringBuffer的方式使用了Synchronized关键字进行修饰）。
  3. 使用StringBuilder可变字符串，效率最高，但是线程不安全。
  
  ### 简述final,finally和finalize区别
  1. final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方式不可重写，被final修饰的变量引用不可变，引用的内容可以更改。
  2. finally用于try-catch 代码块中，无论是否发生异常最后都将被执行，作用是释放资源。
  3. finalize 是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。
  
  ### ==和equals有什么区别?equals和hashCode有什么联系
  1. 如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。
  2. 如果没有重写的话，equals默认按照==进行比较，如果重写了equals() 方法，则按照对应的比较规则比较。
  3. 两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。
  理解：
  如果是Integer类的hashcode返回的是值比较，对象不一定相同 √
  如果是String类的hashcode 值是算法计算出来的，有可能导致hashcode值相同的情况，两个对象不一定相同 √
  
  ### Array和ArrayList的区别
  1.Array长度在定义之后就不运行改变了，而ArrayList是长度可变的，可以自动化扩容。
  2.Array只能存储相同类型的数据，ArrayList可以存储不同类型的数据。
  3.ArrayList提供了更多操作数据的方法。
  
  ### 简述JDK8的新特性
  1.接口中可以添加default修饰的非抽象方法，可以有方法和内容。
  2.可以使用lambda表达式，减少代码冗余
  3.函数式接口，使用@Functionalinterface注解标明，该接口有且仅有一个抽象方法。
  4.方法引用，可以直接引用已有java类或对象的方法或构造器，进一步简化lambda表达式，
  5.stream流，用于解决已有集合/数组类库的弊端，简化其操作，有foreach遍历，filter过滤，map映射，concat合并等功能。
  6.增加日期相关的API
  
  ### Stream流
  1.Stream流是JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。
  2.Stream流的获取
    1）集合：直接调用Stream()方法获取
    2）数组：使用静态方法Stream.of()/Arrays.stream()获取
  3.常用方法
    1)forEach()遍历
    2)count()统计个数
    3)filter()按条件过滤
    4)limit()取前面n个元素
    5)skip()跳过前面n个元素
    6)map()映射加工
    7)concat()合并stream流
  4.终结方法
    foreach/count调用终结方法后流不能继续使用
  5.非终结方法
    每次调用完返回一个新的Stream对象，可以继续使用。
  6.收集Stream流
    1）把流转为Set集合 collect(Collections.toSet())
    2) 把流转为List集合 collect(Collections.toList())
    3) 把流转为Collection集合 collect(Collections.toCollection())
    4) 把流转为数组toArray()
  7.简述面向对象的特性
    1）封装：建议成员变量私有，然后提供公有的getter/setter方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露。可以提高安全性，实现代码的组件化
    2）继承：一种子类到父类的关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。
    3) 多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，右边对象可以实现组件化切换，业务功能随之改变，便于扩展和维护。
  8. 列举Object类的方法
     1）equals(Object obj):判断其他对象是否与当前对象相等。
     2）toString():打印当前对象的字符串表示
     3) wait():导致当前线程等待，等待其它线程唤醒，会释放锁。
     4) notify()/notifyAll():随机唤醒一个/全部线程
     5) hashCode():返回当前对象的hashCode值。
     6) finalize():当垃圾回收期要回收对象前调用。
     7) clone:创建并返回对象的一个副本.
  9.接口和抽象类有什么区别
    1）接口中只能定义public static final 修饰的常量，抽象类中可以定义普通变量。
    2）接口和抽象类都不能实例化，但接口没有构造器，抽象类有构造器。
    3）接口可以多实现，抽象类只能单集成。
    4）接口在JDK1.8之前只能定义public abstract修饰的方法，JDK1.8开始可以定义默认方法和静态方法，JDK1.9开始可以定义私有方法，抽象类中的方法没有限制。
    
  10.什么时候应该使用接口，什么时候应该使用抽象类
    1）如果知道某个类应该成为基类，那么第一选择应该是让它成为一个接口，只有在必须要有方法定义和成员变量的时候，才应该选择抽象类。
    2）在接口和抽象类的选择上，必须遵守：行为模型应该总是通过接口而不是抽象类定义。又由于java不允许多继承，最好是选择接口去实现。
    
  11.内部类有什么作用？有哪些分类？
    Q1.内部类有更好的封装性，有更多的权限修饰符，封装性可以得到更多的控制。
    Q2.内部类的分类
        1）静态内部类：由于static修饰，属于类本身，只加载一次。类可以定义的成分，静态内部类都可以定义。可以访问外部类的静态变量和方法，
        通过new外部类，静态内部类构造器，来创建对象。
        2）成员内部类：属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过new 外部类构造器.静态内部类构造器来创建对象。
        3）局部内部类：定义在方法、构造器、代码块、循环中。只能定义实例成员变量和实例方法，作用范围仅在局部代码块中。
        4）匿名内部类：没有名字局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，对象类型相当于当前new的子类类型。
  
  12. 泛型和泛型擦除
    1.泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制运行程序在编译时检测非法的类型。
    2.在编译阶段采用泛型时带上类型参数，会被编译器在编译时去掉，这个过程就被称为类型擦除。因此泛型主要用于编译阶段，在编译后生成的java字节代码文件中不包含泛型中的类型信息。
  
  ## 2、java的类加载过程
  [深入浅出Java类加载过程 - 神仙果 - 博客园](https://www.cnblogs.com/luohanguo/p/9469851.html)
  
  主要分为三部分:加载，链接（验证，准备，解析），初始化
  ![14265221-905453ee556fc809.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\bf372989.png)
  ### 加载
  将class 字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量，静态代码块，常量池等），在堆中生成一个Class类对象代表这个类,作为方法区类数据的访问入口。
  ![14265221-cbbff216aa0bb3c6.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\3003b95b.png)
  
  ### 链接
  将java类的二进制代码合并到JVM的运行状态之中。
  
  验证:验证class文件的字节流是否符合jvm规范,确保加载的类信息符合jvm规范，没有安全方面的
  
  准备:正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。而此时的设置初始值为默认值，具体赋值在初始化阶段完成。
  
  解析:虚拟机常量池内的符号引用替换为直接引用的过程。
  
  ### 初始化
  主要对类变量进行初始化，执行类构造器的过程，仅仅对static修饰的变量或者语句进行初始化。
  例Person person=new Person();
  1. 找到class文件，将它加载到内存
  2. 在堆内存中分配内存地址
  3. 初始化
  4. 将堆内存地址指给栈内存中的p变量
  
  **初始化顺序**
  1、父类的静态变量
  2、父类的静态代码块
  3、子类的静态变量
  4、子类的静态代码块
  5、父类的非静态变量
  6、父类的非静态代码块
  7、父类的构造方法
  8、子类的非静态变量
  9、子类的非静态代码块
  10、子类的构造方法
  
  ## 3、java类的引用于对象引用
  [JAVA类加载过程&主动引用和被动引用](https://www.baidu.com/link?url=ZaJO63OX4cc1VaIpQzrwvVJeltj2MMT179nj_yaFwtEF7-7K8IIrPTqjXY7PlHYR&wd=&eqid=b9cda6fb0010d68b000000045da6939f)
  ### 主动引用
  #### 碰到如下四种情况才会触发主动引用：
  1. 使用new关键字实例化对象(new)
  2. 读取类的静态成员变量(getstatic)
  3. 设置类的静态成员变量(setstatic)
  4. 调用静态方法(invokestatic)
  #### 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
  通过调用java.lang.Class.forName(String className) 
  #### 当初始化一个类的时候，如果发现其父类还没进行过初始化，则需要先触发其父类的初始化。
  #### 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类
  
  ### 被动引用
  #### 通过子类引用父类的静态字段，不会导致子类初始化
  #### 通过数组定义来引用，不会触发此类的初始化
  #### 常量在编译阶段会存入调用类的常量池中，本质没有直接引用到定义的常量类中，因此不会触发定义的常量初始化
  
  ### java对象引用
  [Java中四种引用 - 张界 - 博客园](https://www.cnblogs.com/pascall/p/10281775.html)
  #### 强引用
  如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
  ```
  String str = "hello";    // 强引用
  str = null;              // 取消强引用
  ```
  #### 软引用
  在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收；只有在内存空间不足时，软引用才会被垃圾回收器回收。
  ```
  SoftReference<String> softName = new  SoftReference<>("张三");
  ```
  #### 弱引用
  具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。
  ```
  WeakReference<String> weakName = new WeakReference<String>("hello");
  ```
  #### 虚引用
  如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。
  虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
  ```
  ReferenceQueue<String> queue = new ReferenceQueue<String>();
  PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
  ```
  ### 类加载器的原理
  程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。
  ### 类加载器的分类
  ![14265221-549d6e3ca7ab0b5a.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\4834df19.png)
  #### 引导类加载器(bootstrap class loader)
  （1）它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自java.lang.ClassLoader。
  （2）加载扩展类和应用程序类加载器。并指定他们的父类加载器。
  
  #### 扩展类加载器(extensions class loader)
  （1）用来加载 Java 的扩展库(JAVA_HOME/jre/ext/* .jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。
  （2）由sun.misc.Launcher$ExtClassLoader实现。
  
  #### 应用程序类加载器(application class loader)
  （1）它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。
  （2）由sun.misc.Launcher$AppClassLoader实现。
  
  #### 自定义类加载器
  （1）开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。
  
  ### java.class.ClassLoader类
  #### 作用
  1. java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。
  
  2. ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。
  
  #### 常用方法
  1. getParent()返回该类加载器的父类加载器
  2. loadClass(String name) 加载名称为 name的类，返回的结果是java.lang.Class类的实例。此方法负责加载指定名字的类，首先会从已加载的类中去寻找，如果没有找到；从parent ClassLoader[ExtClassLoader]中加载；如果没有加载到，则从Bootstrap ClassLoader中尝试加载(findBootstrapClassOrNull方法), 如果还是加载失败，则自己加载。如果还不能加载，则抛出异常ClassNotFoundException。
  3. findClass(String name) 查找名称为 name的类，返回的结果是java.lang.Class类的实例。
  4. findLoadedClass(String name) 查找名称为 name的已经被加载过的类，返回的结果是 java.lang.Class类的实例。
  5. defineClass(String name, byte[] b, int off, int len) 把字节数组 b中的内容转换成 Java 类，返回的结果是java.lang.Class类的实例。这个方法被声明为 final的。
  
  ### 类加载器的代理模式
  代理模式即是将指定类的加载交给其他的类加载器。常用双亲委托机制。
  #### 双亲委托机制
  某个特定的类加载器接收到类加载的请求时，会将加载任务委托给自己的父类，直到最高级父类引导类加载器（bootstrap class loader），如果父类能够加载就加载，不能加载则返回到子类进行加载。如果都不能加载则报错。ClassNotFoundException
  ![14265221-3d7d7649e882f1c2.png](:storage\\e9cc09e0-9ce3-4da2-b240-076242f280d6\\2a94f087.png)
  
  #### 为什么使用双亲委托模型
  双亲委托机制是为了保证 Java 核心库的类型安全。这种机制保证不会出现用户自己能定义java.lang.Object类等的情况。例如，用户定义了java.lang.String，那么加载这个类时最高级父类会首先加载，发现核心类中也有这个类，那么就加载了核心类库，而自定义的永远都不会加载。
  
  ## 4、GC机制
  ### GC概括
  Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。
  
  ### 检测出垃圾方法
  #### 引用计数法
  给每个对象添加引用计数器，每个地方引用它，计数器就+1，失效时-1。如果两个对象互相引用时，就导致无法回收。 
  #### 可达性分析算法
  以根集对象为起始点进行搜索，如果对象不可达的话就是垃圾对象。根集（Java栈中引用的对象、方法区中常量池中引用的对象、本地方法中引用的对象等。JVM在垃圾回收的时候，会检查堆中所有对象是否被这些根集对象引用，不能够被引用的对象就会被垃圾回收器回收。）
  ### 垃圾回收算法
  #### 标记-清楚
  标记：首先标记所有需要回收的对象，在标记完成之后统计回收所有被标记的对象，它的标记过程即为上面的可达性分析算法。 清除：清除所有被标记的对象 缺点： 效率不足，标记和清除效率都不高 空间问题，标记清除之后会产生大量不连续的内存碎片，导致大对象分配无法找到足够的空间，提前进行垃圾回收。
  #### 复制回收算法
  将可用的内存按容量划分为大小相等的2块，每次只用一块，当这一块的内存用完了，就将存活的对象复制到另外一块上面，然后把已使用过的内存空间一次清理掉。
  #### 标记-整理
  在老年代的对象大都是存活对象，复制算法在对象存活率教高的时候，效率就会变得比较低。根据老年代的特点，有人提出了“标记-压缩算法(Mark-Compact)”
  标记过程与标记-清除的标记一样，但后续不是对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。
  这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。
  #### 分带收集算法
  根据对象存活的周期不同将内存划分为几块，一般是把Java堆分为老年代和新生代，这样根据各个年代的特点采用适当的收集算法。
  
  新生代每次收集都有大量对象死去，只有少量存活，那就选用复制算法，复制的对象数较少就可完成收集。 老年代对象存活率高，使用标记-压缩算法，以提高垃圾回收效率。
  
  ## 5、集合（补充）
  Java集合类主要由两个接口派生出：Collection和Map，这两个接口是Java集合的根接口。
  
  Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是却让其被继承产生了两个接口，就是 Set和List。Set中不能包含重复的元素。List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式。
  
  Map是Java.util包中的另一个接口，它和Collection接口没有关系，是相互独立的，但是都属于集合类的一部分。Map包含了key-value对。Map不能包含重复的key，但是可以包含相同的value。
  
  ### List和Set比较
  List,Set都是继承自Collection接口，Map则不是; List特点：元素有放入顺序，元素可重复; Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法; 
  
  ### List和Vector比较
  Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；
  两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同，Vector可以设置增长因子，而ArrayList不可以。
  
  ## 6、常量池
  ### 6.1 Integer中的128(-128~127)
  当数值范围为-128~127时：如果两个new出来Integer对象，即使值相同，通过“==”比较结果为false，但两个对象直接赋值，则通过“==”比较结果为“true，这一点与String非常相似。 
  当数值不在-128~127时:无论通过哪种方式，即使两个对象的值相等，通过“==”比较，其结果为false； 当一个Integer对象直接与一个int基本数据类型通过“==”比较，其结果与第一点相同；
  ### 6.2 为什么是-128~127
  在Integer类中有一个静态内部类IntegerCache，在IntegerCache类中有一个Integer数组，用以缓存当数值范围为-128~127时的Integer对象。
  
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
