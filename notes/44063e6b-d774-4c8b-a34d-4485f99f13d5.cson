createdAt: "2019-10-18T08:29:58.944Z"
updatedAt: "2020-04-20T05:32:48.165Z"
type: "MARKDOWN_NOTE"
folder: "91596d517848033ae924"
title: "基础知识"
tags: []
content: '''
  # 基础知识
  [toc]
  
  ## 面向对象和面向过程的区别
  
  - **面向过程：面向过程性能比面向对象高。**因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量音素的时候，比如单片机，嵌入式开发，Linux/Unix等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展.**
  - **面向对象：面向对象易维护、易复用、易扩展**。因为面向对象有封装、继承、多态性的特性、所以可以设计出低耦合的系统,使系统更加灵活，更加易于维护。但是，面向对象性能比面向过程低。
  
  ## java语言有哪些特点
  1. 简单易学
  2. 面向对象（封装，集成，多态）
  3. 平台无关性（java 虚拟机实现平台无关性）
  4. 可靠性
  5. 安全性
  6. 支持多线程(C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而java语言却提供了多线程支持)
  7. 支持网络编程并且很便宜（java语言诞生本身就是为简化网络编程设计的，因此java语言不仅支持网络编程而且很方便）
  8. 编译与解释并存;
  
  ## JDK 和JRE最详细通俗的解答
  JDK是Java Development Kit,它是功能齐全的java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具(如javadoc和jdb)。它能够创建和编译程序。
  
  JRE是java运行时环境。它是运行已编译Java 程序所需的所有内容的集合，包括Java虚拟机(JVM),java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。
  
  如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。
  
  ## java和C++的区别
  - 都是面向对象的语言，都是支持封装，集成和多态
  - java不提供指针来直接访问内存，程序内存更加安全
  - java的类是单集成的，c++支持多重继承；虽然java的类不可以多继承，但是接口可以多继承
  - java有自动内存管理机制，不需要程序员手动释放无用内存
  
  ## 字符型常量和字符串常量的区别
  1. 形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符。
  2. 含以上：字符常量相当于一个整型值（ASCII值）,可以参加表达式运算，字符串常量代表一个地址值。
  3. 占内存大小字符常量只占2个字节;字符串常量占若干个字节（至少一个字符结束标志）
  
  ## 构造器Constructor 是否可被override
  父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。
  
  ## 重载与重写的区别
  - **重载：**发生在同一个类中，方法名必须相同，参数类型不同、个数不同，方法返回值和访问修饰符可以不同，发生在编译时。
  - **重写：**发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为Private则子类就不能重写该方法。
  
  ## Java现象对象编程三大特性：封装 继承 多态
  ### 封装
  封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
  ### 继承
  继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
  **关于继承如下3点**
  1.子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**
  2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
  3.子类可以用自己的方法实现父类的方法。
  ### 多态
  所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
  
  在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。
  
  ## String,StringBuffer和StringBuilder的区别是什么？
  ### 可变性
  String 类中使用final关键字修饰符数组来保存字符串，private final char value[], 所以String对象是不可变的。
  StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[]value但是没有用final关键字修饰，所以这两种对象都是可变的。
  
  ### 线程安全性
  String 中的对象是不可变的，也就可以理解为常量，线程安全。
  AbstractStringBuilder是StringBilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf、等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方进行加同步锁，所以是非线程安全的。
  
  ### 性能
  每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。
  
  ### 总结
  1. 操作少量的数据：适用String
  2. 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder
  3. 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer
  
  ## 自动装箱和拆箱
  - 装箱：将基本类型用他们对应的引用类型包装起来。
  - 拆箱：将包装类型转换为基本数据类型。
  
  ## 在一个静态方法内调用一个非静态成员为什么是非法的
  由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。
  
  ## 在java中定义一个不做事且没有参数的构造方法的作用
  Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 　
  
  ## 接口的抽象类的区别是什么？
  1. 接口的方法默认是public,所有方法在接口中不能有实现，而抽象类可以有非抽象的方法。
  2. 接口中除了static,final变量，不能有其他变量，而抽象类中则不一定。
  3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
  4. 接口方法默认修饰符是public,抽象方法可以有public,protected和default这些修饰符(抽象方法就是为了被重写所以不能使用private关键字修饰!)。
  5. 冲设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。
  
  ## 成员变量与局部变量的区别有哪些？
  1.从语法形式上看：成员变量是属于类的，而局部变量实在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。
  2.从变量在内存中的存储方式来看，如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
  3.从变量在内存中的生存时间上看；成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
  4.成员变量如果没有被赋初值；则会自动以类型的默认值而赋值（一种情况例外；被final修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。
  
  ## 创建一个对象用什么运算符？对象实体与对象引用有何不同？
  new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中），一个对象引用可以指向0或1个对象(一根绳子可以不系气球，也可以系一个气球)；一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）；
  
  ## 什么是方法的返回值?返回值在类的方法里的作用是什么？
  方法的返回值是指我们获取到的某个方法体重的代码执行后产生的结果！。  返回值的作用:接收出结果，使得它可以用于其他的操作
  
  ## 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？
  主要作用是完成对类对象的初始化工作。可以执行，因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
  
  ## 构造方法有哪些特性？
  1. 名字与类名相同
  2. 没有返回值，但不能用void声明构造函数
  3. 生成类的对象时自动执行，无需调用
  
  ## 静态方法和实例方法有何不同
  1. 在外部调用静态方法时，可以使用"类名，方法名"的方式，也可以使用"对象名，方法名" 的方式。而实例方法只有后面这种方法。也就是说，调用静态方法可以无需创建对象。
  2. 静态方法在访问本类的成员时，只允许访问静态成员，而不允许访问实例成员变量和实例方法；实例方法则无此限制。
  
  ## 对象的相等于指向他们的引用相等，两者有什么不同？
  对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。
  
  ## ==与equals
  **==:** 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型==比较式的值，引用数据类型==比较的是内存地址）
  **equals():** 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
  - 情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。
  - 情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来比较两个对象的内容是否相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。
  
  **说明:**
  - String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。
  - 当创建String类型的对象时，虚拟机会在常量池中查号有没有已经存在的值和要创建的值相同的对象，如果有救把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。
  
  ## hashCode与equals(重要)
  hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode（）定义在JDK的Object.java中，这就意味着java中的任何类都包含有hashCode（）函数
  
  散列表存储的是键值对（key-value）,它的特点是：能根据"键"快速的检索出对应的“值”。这其中就利用了散列吗！（可以快速找到所需要的对象）
  
  ### 为什么要有hashCode
  **我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：** 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。
  
  通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。**hashCode() 在散列表中才有用，在其它情况下没用。**在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。
  
  ### hashCode()与equals()相关规定
  1.如果两个对象相等，则hascode一定也是相同的
  2.两个对象相等，对两个对象分别调用equals方法都返回true
  3.两个对象有相同的hashcode值，它们也不一定是相等的。
  4.因此，equals方法被覆盖过，则hashCode方法也必须被覆盖
  5.hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode(), 则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
  
  ## 简述线程，程序，进程的基本概念。以及他们之间关系是什么？
  ### 线程
  线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
  ### 程序
  程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
  ### 进程
  进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。
  ## final,static,this,super关键字总结
  
  ### 关于final关键字的一些总结
  final关键字主要的三个地方：变量，方法，类
  1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
  2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。
  3. 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。
  
  ### static 关键字
  static关键字主要有以下四种使用场景：
  1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()
  
  如果变量或者方法被private则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。
  测试方法：
  ```
  public class StaticBean {
  
      String name;
      静态变量
      static int age;
  
      public StaticBean(String name) {
          this.name = name;
      }
      静态方法
      static void SayHello() {
          System.out.println(Hello i am java);
      }
      @Override
      public String toString() {
          return StaticBean{ +
                  name=' + name + \''' + age + age +
                  '}';
      }
  }
  ```
  
  ```
  public class StaticDemo {
  
      public static void main(String[] args) {
          StaticBean staticBean = new StaticBean(1);
          StaticBean staticBean2 = new StaticBean(2);
          StaticBean staticBean3 = new StaticBean(3);
          StaticBean staticBean4 = new StaticBean(4);
          StaticBean.age = 33;
          StaticBean{name='1'age33} StaticBean{name='2'age33} StaticBean{name='3'age33} StaticBean{name='4'age33}
          System.out.println(staticBean+ +staticBean2+ +staticBean3+ +staticBean4);
          StaticBean.SayHello();Hello i am java
      }
  
  }
  
  ```
  2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
  静态代码块的格式是
  ```
  static{
  语句体
  }
  ```
  一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。
  
  3. **静态内部类（static修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。
  
  ```
  public class Singleton {
      
      声明为 private 避免调用默认构造方法创建对象
      private Singleton() {
      }
      
      声明为 private 表明静态内部该类只能在该 Singleton 类中被访问
      private static class SingletonHolder {
          private static final Singleton INSTANCE = new Singleton();
      }
  
      public static Singleton getUniqueInstance() {
          return SingletonHolder.INSTANCE;
      }
  }
  ```
  当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。
  这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。
  
  4. **静态导包(用来导入类中的静态资源，1.5之后的新特性):** 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。
  
  
  ### this关键字
  this关键字用于引用类的当前实例。例如:
  ```
  class Manager {
      Employees[] employees;
       
      void manageEmployees() {
          int totalEmp = this.employees.length;
          System.out.println("Total employees: " + totalEmp);
          this.report();
      }
       
      void report() { }
  }
  ```
  在上面的示例中，this关键字用于两个地方：
  - this.employees.length:访问类Manager的当前实例的变量
  - this.report():调用类Manager的当前实例的方法。
  
  此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。但是，使用此关键字可能会使代码更易读或易懂。
  
  ### Super关键字
  super关键字用于从子类访问父类的变量和方法。例如：
  ```
  public class Super {
      protected int number;
       
      protected showNumber() {
          System.out.println("number = " + number);
      }
  }
   
  public class Sub extends Super {
      void bar() {
          super.number = 10;
          super.showNumber();
      }
  }
  ```
  在上面的例子中，Sub类访问父类成员变量number并调用其父类Super的shownumber()方法。
  
  **使用this和super要注意的问题：**
  
  - 在构造器中使用 super（） 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
  - this、super不能用在static方法中。
  
  简单解释一下：
  被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， **this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。**
  
  
  ## 获取用键盘输入常用的两种方法
  方法1：通过Scanner
  ```
  Scanner input =new Scanner(System.in)
  String s=input.nextLine();
  input.close();
  ```
  方法2：通过BufferedReader
  ```
  BufferedReader input =new BufferedReader(new InputStreamReader(System.in));
  String s=input.readLine();
  ```
  
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
