createdAt: "2021-11-12T06:44:41.788Z"
updatedAt: "2022-01-20T02:36:24.677Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "IOS 开发基础教程"
tags: []
content: '''
  # IOS 开发基础教程
  [TOC]
  
  # 1.苹果开发人员计划
  1. ios开发的App如果需要发布到App Store上进行销售，需要申请开发人员账户。
  2. 个人开发者账户：个人开发者只能通过App Store进行发布。
  3. 企业开发者账户：可以开发私有App,但不能通过App Store分发。
  
  # 2.第一个iOS应用
  ## 2.1 项目结构
  AppDelegate:是应用程序代理类，用来处理应用程序生命周期的各个事件响应。
  ViewController:是主界面的视图控制器。
  Main.storyboard:主界面可视化界面。
  LaunchScreen.storyboard:启动界面的可视化界面。
  Asset.xcasset：是用来存放图片的地方，可以把App的图标和启动画面根据一定的规格集中在这里指定和存放。
  info.plist：是一个键值对文件，指定该App的很多属性。
  
  # 3. Cocoa Touch 框架的运行机制和开发流程
  ## 3.1 用户操作，硬件中断与消息处理
  用户操作时，硬件会产生一个中断，此时操作系统将陷入中断处理状态，此时会调用应用程序注册好的回调响应方法来响应该中断。
  App通过向操作系统注册回调方法，就能轻松实现某输入事件发生后自己定义的回调方法按预期被调用。
  ## 3.2 iOS的消息处理机制
  视图控制器UIViewController管理着视图的生命周期，事件如下：
  1）视图加载完毕；2）视图将显示；3）视图已显示；4）视图将消失；5）视图已消失
  每一个事件都对应一个事件响应方法，开发要做的事就是覆盖默认的响应方法，视图本身也可以响应事件处理。
  ### 3.2.1 协议与代理
  协议与代理是Objective C语言的概念。
  协议可以看作Java等语言中的接口，或者抽象类，即只有方法定义，却不实现方法。
  代理是实现了协议的对象，可以看作Java等语言中实现了某接口或抽象类的对象。
  ### 3.2.2 target与selector
  target用来指定事件由哪个对象来处理。
  selector即指定某方法来具体执行响应事件。
  ### 3.2.3 消息中心NSNotification
  有一些事件，不是由硬件中断产生。比如键盘收起事件，输入框文字改变事件等。这些事件一般通过Cocoa的通知中心机制来广播。
  可以通过NSNotification类获得默认的通知中心，从中注册感兴趣的消息以及指定响应的对象及方法，当某对象不再需要响应某消息时，
  必须要从通知中心注销，注销后通知中心将不会再发送给该对象该消息。
  ## 3.3 iOS程序开发流程简介
  开发者所要做的是编写界面以及编写事件响应方法而已。
  ### 3.3.1 创建窗口和控件
  苹果提供了UIViewController类，该类定义了一个页面，做好了所有的基础框架工作。开发所要做的，只需编写UIViewController的子类来实现某个界面及其事件响应方法，在其中的viewDidLoad方法中创建视图、控件，以及指定响应方法。除了UIViewController类，还有一些特殊用途的基础控制器类，比如UITable,ViewController,UIActivityViewController等。
  ### 3.3.2 视图与控件事件绑定
  视图的基础类为UIView，该类没有事件绑定，但是可以定义手势对象加在其上，令其能够响应手势操作。
  一般的收拾有捏拉缩放，轻拍，连拍，滑动，轻扫。
  控件的基础类为UIControl(该类也是UIView的子类)，是能够操作的视图类，比如开关控制，按钮控制等。同时提供了一个方法addTarget:action:forControlEvents:,可方便地为某个事件添加相应的响应方法。
  
  # 4 iOS开发命名习惯与约定
  ## 4.1命名方式
  变量或方法命名，第一个字母小写，而后每一个单词的首字母大写。如：textLabel,datailLabel.
  类和枚举的命名，加上大写前缀，而后的每个单词都首字母大写。如：UIView,UIScrollView,UITableView.
  
  # 5 iOS用户界面元素之UIView与控件
  ## 5.1 UIView家族
  UIView是所有视图类的根类，由其衍生出来众多的子类以及控件类。值得注意的是，UIView的父类是UIResponder,
  凡是继承于UIResponder类的对象，都能收到用户触摸的事件以及消息。
  ![60131160.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\60131160.png)
  
  ### 5.1.2 UIView基本属性
  frame:用来规定视图大小。
  bounds:用来规定视图位置。
  center:定义视图中心点在父视图的坐标，CGPoint类型。
  transform:定义视图的变幻。
  subviews:子视图集合。
  superview:父视图。
  window:视图所属的窗口，UIWindows类型；
  alpha:视图透明度,0到1;
  backgroundColor:视图背景色，UIColor类型；
  clipsToBounds:子视图超过视图边界的部分，是否剪切掉，BOOL类型。
  hidden:是否隐藏视图，BOOL类型。
  tintColor:影响默认的一些颜色。
  layer:视图真正的显示层。CALayer类型，常用来定义视图的边框和圆角。
  tag:视图的额外编号，整数类型，用的不多，定义了tag，便可使用整个tag从其父视图搜索到这个视图。
  ### 5.1.3 视图层次体系
  ![67f02917.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\67f02917.png)
  
  ![93524e3b.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\93524e3b.png)
  每个View在其父view中的位置以及大小，主要由3个相关的属性来定义或改变，分别为frame、bounds,以及center,其中center表示view的中心点坐标。frame与bounds都是CGRect类型的结构体，包含2个结构体，分别是CGPoint和CGSize类型。CGPoint结构体表述左上角坐标，CGSize描述宽与高。可用CGRectMake方法来构造一个CGRect结构体。
  ![c5e13ff6.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\c5e13ff6.png)
  bounds属性表示的视图左上角的坐标永远都是(0,0)。而frame属性表示的属性左上角坐标，则是该视图相对于父view的相对位置的坐标。center则是表示视图的中心点。
  
  ## 5.2 UIControl类
  UIControl类默认可以接受触摸事件，并且对接受的触摸事件做了很详细的区分，可以很方便地定制需要响应的事件。
  UIControl类是所有控件类的父类，所谓控件，就是能够接受用户的触摸操作，并对其做出响应的UI组件。
  ```
  UIControl *c = [UIControl new];
  [c addTarget:<#(nullable id)#> action:(nonnull SEL) forControlEvents:<#(UIControlEvents)#>]
  ```
  ## 5.3 UILabel类
  ```
  UILabel *detailLabel = [UILabel new];
  detailLabel.frame = CGRectMake(200, 0, 200, 0);
  detailLabel.textAlignment = NSTextAlignmentRight;
  detailLabel.font = [UIFont fontWithName:detailLabel.font.fontName size:15.0];
  detailLabel.text = @"你好";
  ```
  ## 5.4 UIButton类
  初始化一个UIButton
  ```
  UIButton *btn = [UIButton buttonWithType:UIButtonTypeRounderRect]
  ```
  buttonWithType的类型：
  buttonWithType = 0 表示没有类型
  buttonWithType = UIButtonTypeSystem 表示系统类型
  
  添加点击事件
  ```
  [btn[i] addTarget:self action:@selector(onPress:) forControlEvents:UIControlEventTouchUpInside]; 
  ```
  UIControlEventTouchDown:按下
  UIControlEventTouchUpInside：在按钮内部松开
  UIControlEventTouchUpOutsize：在按钮外部松开
  UIControlEventTouchDragExit：按下不放移动手指知道手指离开按钮边界
  
  事件的创建
  ```
  -(void)onPress:(UIButton *)button
  ```
  需要根据每个button的tag来判定当前点击事件属于哪个button.
  
  ## 5.5 开关控件，滑块控件与分段控件
  CGRectMake 指定长宽和位置
  CGPoint 指定位置
  ### 5.5.1 开关控件
  初始化一个switch，并添加监听事件
  ```
  UISwitch *swi = [[UISwitch alloc]init];
  [swi sizeToFit]; //自动适配最合适大小
  swi.center = CGPointMake(100,200);
  [swi addTarget:self action:@selector(onSwitch:)forControlEvents:UIControlEventValueChanged];[self.view addSubview:swi];
  
  - (void)onSwitch:(UISwitch *)swi{}
  
  ```
  ### 5.5.2 滑块控件
  初始化一个Slider，并添加监听事件
  ```
  UISlider *sli = [[UISlider alloc]initWithFrame:CGRectMake(left, 100, self.view.frame.size.width-left*2,44)];
  [sli addTarget:self action:@selector(onSlider:) forControlEvents:UIControlEventValueChanged];
  [self.view addSubview:sli];
  
  - (void)onSlider:(UISlider *)sli{}
  
  ```
  ### 5.5.3 分段控件
  初始化一个分段控件，并添加监听事件
  ```
  UISegmentedControl *segs = [[UISegmentedControl alloc]initWithItems:@[@"第一段",@"第二段",@"第三段"]];
  segs.frame = CGRectMake(30,25,self.view.frame.size.width-60,34);
  segs.selectedSegmentIndex = 0;
  [segs addTarget:self action:@selector(onSegChange:) forControlEvents:UIControlEventValueChanged];
  [self.view addSubview:segs];
  
  - (void)onSegChange:(id)sender{}
  ```
  
  
  ## 5.6 输入控件
  
  UITextField,UITextView,采用协议的情况下。
  ViewController 需要给控制器增加 <UITextViewDelegate,UITextFieldDelegate>协议
  并在delegate属性中指定为self
  
  ### 5.6.1 UITextField
  初始化一个TextField
  ```
  UITextField tf = [[UITextField alloc]initWithFrame:CGRectMake(rightLeft, top+5, rightWidth, 34)];
  tf.text = @"站位文字";
  tf.borderStyle = UITextBorderStyleRoundedRect;
  
  ```
  控制其输入过程中的事件.
  ```
  是否允许开始编辑
  - (BOOL)textFieldShouldBeginEditing:(UITextField *)textField{
    return YES;
  }
  开始编辑时调用(弹出键盘)became first responder
  - (void)textFieldDidBeginEditing:(UITextField *)textField{
      NSLog(@"弹出键盘"); 
  }
  是否允许结束编辑.
  - (BOOL)textFieldShouldEndEditing:(UITextField *)textField{
      return YES;
   }
  结束编辑时调用.
  - (void)textFieldDidEndEditing:(UITextField *)textField{
      NSLog(@"结束编辑时调用.");
   }
  是否允许文字改变.拦截用户输入.
  - (BOOL)textField:(UITextField *)textFieldshouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string{
      return NO;
   }
  ```
  
  ### 5.6.2 UITextView
  初始化一个TextView
  ```
  UITextView tv = [[UITextView alloc] initWithFrame:CGRectMake(rightLeft, top+5, rightWidth, 44 * 3)];
  tv.delegate = self;
  tv.font = tf.font;
  tv.layer.borderWidth = 0.5;
  tv.layer.borderColor = [UIColor colorWithWhite:0.8 alpha:1.0].CGColor;
  tv.layer.cornerRadius = 4;
  ```
  控制其输入过程中的事件.
  ```
  //将要进入编辑模式
  - (BOOL)textViewShouldBeginEditing:(UITextView *)textView {return YES;}
  //已经进入编辑模式
  - (void)textViewDidBeginEditing:(UITextView *)textView {}
  //将要结束/退出编辑模式
  - (BOOL)textViewShouldEndEditing:(UITextView *)textView {return YES;}
  //已经结束/退出编辑模式
  - (void)textViewDidEndEditing:(UITextView *)textView {}
  //当textView的内容发生改变的时候调用
  - (void)textViewDidChange:(UITextView *)textView {}
  //选中textView 或者输入内容的时候调用
  - (void)textViewDidChangeSelection:(UITextView *)textView {}
  //从键盘上将要输入到textView 的时候调用
  //rangge  光标的位置
  //text  将要输入的内容
  //返回YES 可以输入到textView中  NO不能
  - (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text {return YES;}
  ```
  ## 5.7 日期选择器
  初始化日期选择器,并将值赋给UITextField
  ```
  UIDatePicker *datePicker = [[UIDatePicker alloc]initWithFrame:CGRectZero];
  [datePicker sizeToFit];
  datePicker.datePickerMode = UIDatePickerModeDate;
  [datePicker addTarget:self action:@selector(dataChange:) forControlEvents:UIControlEventValueChanged];
  
  UITextField *tf = [[UITextField alloc]initWithFrame:CGRectMake(20, 150, self.view.frame.size.width-40,44 )];
  tf.layer.borderWidth = 0.5;
  tf.layer.cornerRadius = 4;
  tf.inputView = datePicker;
  [self.view addSubview:tf];
  
  ```
  设置dataChange的监听事件,需要对日期格式化。
  ```
  -(void)dataChange:(UIDatePicker *)datePicker{ 
      NSDate *date = datePicker.date;
      NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];
      [dateFormatter setDateFormat:@"yyyy年MM月dd日"];
      NSString *string = [[NSString alloc]init];
      string = [dateFormatter stringFromDate:date];
      tf.text = string;  
  }
  ```
  ## 5.8 自定义选择器UIPickerView
  UIPickerView的代理有2个，分别为dataSource与delegate,其对应的协议分别为
  UIPickerViewDataSource与UIPickerViewDelegate协议。
  UIPickerViewDataSource用以提供显示的内容。
  UIPickerViewDelegate用以处理选择器的事件。
  初始化一个UIPickerView,以及用以显示的UITextField
  ```
  UIPickerView *pickerView = [[UIPickerView alloc]initWithFrame:CGRectZero];
  [pickerView sizeToFit];
  pickerView.dataSource = self;
  pickerView.delegate = self;
      
  UITextField *tf = [[UITextField alloc] initWithFrame:CGRectMake(20, 202, self.view.frame.size.width-40, 44)];
  tf.text = @"点击选择省份地址等";
  tf.layer.borderWidth = 0.5;
  tf.layer.cornerRadius = 4;
  tf.inputView = pickerView;
  [self.view addSubview:tf];
  ```
  选择器内容实现
  ```
  provinces = @[@"湖南", @"广东"];
      cities = @[
                 @[@"长沙",@"株洲",@"湘潭"],
                 @[@"广州",@"韶关",@"深圳"],
                 ];
      areas = @[
                @[
                    @[@"开福区",@"岳麓区"],
                    @[@"天元区",@"石峰区"],
                    @[@"雨花区",@"河西区"]
                    ],
                @[
                    @[@"天河区",@"某某区"],
                    @[@"某1区",@"某2区"],
                    @[@"龙岗区",@"高新区"]
                    ]
                ];
  }
  //用以知道需要显示多少列 -UIPickerViewDataSource
  -(NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView{
      return 3;
  }
  
  //用以知道第某列需要显示多少行 -UIPickerViewDelegate
  - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component
  {
      if (component == 0) {
          return provinces.count;
      }else if (component == 1){
          return [cities[curProvince] count];
      }else{
          return [areas[curProvince][curCity] count];
      }
  }
  
  //显示每一项的文字 - UIPickerView Delegate
  - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component
  {
      if (component == 0) {
          return provinces[row];
      }else if (component == 1){
          return cities[curProvince][row];
      }else{
          return areas[curProvince][curCity][row];
      }
  }
  
  //当选中某一项时的事件处理方法。-UIPickerView Delegate
  -(void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component{
      if(component == 0){
          curProvince = row;
      }else if(component == 1){
          curCity = row;
      }else {
          curArea = row;
      }
      [pickerView reloadAllComponents];
  }
  ```
  ## 5.9 键盘开启与关闭
  键盘开启
  ```
  [tf becomeFirstResponder];
  ```
  键盘关闭
  ```
  [tf resignFirstResponder];
  ``` 
  ## 5.10 网页控件WKWebView(IOS9已弃用UIWebView)
  WKWebView有两个代理,<WKUIDelegate,WKNavigationDelegate>
  WKNavigationDelegate主要处理一些跳转、加载处理操作，
  WKUIDelegate主要处理JS脚本，确认框，警告框等。因此WKNavigationDelegate更加常用。
  初始化WKWebView
  ```
  需要引入头文件 webKit/WebKit.h
  
  WKWebView web = [[WKWebView alloc] initWithFrame:rect];
  web.UIDelegate = self;
  web.navigationDelegate = self;
  [self.view addSubview:web];
  ```
  WKNavigationDelegate 代理
  ```
  // 页面开始加载时调用
  - (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation{
  
  }
  // 当内容开始返回时调用
  - (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation{
  
  }
  // 页面加载完成之后调用
  - (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation{
  
  }
  // 页面加载失败时调用
  - (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation{
  
  }
  // 接收到服务器跳转请求之后调用
  - (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation{
  
  }
  // 在收到响应后，决定是否跳转
  - (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler{
  
      NSLog(@"%@",navigationResponse.response.URL.absoluteString);
      //允许跳转
      decisionHandler(WKNavigationResponsePolicyAllow);
      //不允许跳转
      //decisionHandler(WKNavigationResponsePolicyCancel);
  }
  // 在发送请求之前，决定是否跳转
  - (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler{
  
       NSLog(@"%@",navigationAction.request.URL.absoluteString);
      //允许跳转
      decisionHandler(WKNavigationActionPolicyAllow);
      //不允许跳转
      //decisionHandler(WKNavigationActionPolicyCancel);
  }
  ```
  WKUIDelegate 代理
  ```
  // 创建一个新的WebView
  - (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures{
      return [[WKWebView alloc]init];
  }
  // 输入框
  - (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler{
      completionHandler(@"http");
  }
  // 确认框
  - (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler{
      completionHandler(YES);
  }
  // 警告框
  - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler{
      NSLog(@"%@",message);
      completionHandler();
  }
  ```
  
  ## 5.11 工具栏与导航栏
  工具栏初始化
  ```
  UIToolbar toolBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, self.view.frame.size.height-44,self.view.frame.size.width ,44)];
      
  UIBarButtonItem *item1 = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:@selector(onClick:)];
      
  UIBarButtonItem *item2 = [[UIBarButtonItem alloc] initWithTitle:@"示范" style:UIBarButtonItemStylePlain target:self	 action:@selector(onClick:)];
      
  UIBarButtonItem *item3 = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:@selector(onClick:)];
      
  UIBarButtonItem *space = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
  
  toolBar.items = @[item1,space,item2,space,item3];
  ```
  导航栏的初始化
  导航栏用UINavigationController控制。
  在AppDelegate.m文件，将原本ViewController对象作为自己的根对象。
  然后将UINavigationController对象作为_window的根控制器。
  ```
  ViewController *con = [[ViewController alloc]init];
  UINavigationController *nav = [[UINavigationController alloc]initWithRootViewController:con];
  _window.rootViewController = nav;
  ```
  界面中使用
  ```
  self.title = @"导航栏与工具栏示例";
  self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:@selector(onClick:)];
  ```
  ## 5.12 UIView动画
  平移动画：
  ```
  [UIView animateWithDuration:0.3 animations:^{
  if(view.frame.origin.x<160){
  view.frame = CGRectMake(240, 100, 60, 60);}
  else{
  view.frame = CGRectMake(16, 100, 60, 60);
  }
  }];
  ```
  透明度动画：
  ```
  [UIView animateWithDuration:0.3 animations:^{
  if(view.alpha <0.5){
  view.alpha = 1;
  }else{
  view.alpha = 0.1;
  }
  }];
  ```
  旋转动画：
  ```
  CGAffineTransform transform = CGAffineTransformRotate(view.transform, M_PI);
  [UIView animateWithDuration:0.3 animations:^{
  view.transform = transform;}completion:^(BOOL finished) {
  [UIView animateWithDuration:0.3 animations:^{
  view.transform = CGAffineTransformIdentity;
  }];
  }];
  ```
  ## 5.13 自定义UIControl
  继承 UIControl 类,有一个属性checked
  ```
  #import <UIKit/UIKit.h>
  @interface CheckedButton : UIControl
  @property (assign,nonatomic)BOOL checked;
  @end
  ```
  给UIControl的子类添加响应事件,然后重写checked属性的setter方法
  ```
   [self addTarget:self action:@selector(onClick:) forControlEvents:UIControlEventTouchUpInside];
   
  -(void)onClick:(id)sender{
      NSLog(@"run click,check:%d",self.checked);
      self.checked = !_checked;
  }
  
  -(void)setChecked:(BOOL)checked{
      NSLog(@"run setChecked ,check:%d",checked);
      _checked = checked;
      imgV.image = checked ? checkedImg :nil;
      self.layer.borderColor = checked?checkedBorderColor.CGColor :unCheckedBorderColor.CGColor;
      [self setNeedsLayout];
  }
  ```
  # 6 导航控制器
  ## 6.1 导航器控制器概述
  导航控制分为两种，一个在顶部，一个在底部。
  顶部为UINavigationController.
  底部为UITabBarController.(与UIToolBar类似)
  
  ### 6.1.2 设计思路
  首先把 Navigation View 加到 TabBarView 的内容上去，TabBarView再加到 Window 上去。
  然后Window套 UITabBarController，UITabBarController套UINavigationController, UINavigationController套UIViewController。
  最后当跳转到详情页面的时候，如果 UITabBar 仍然存在的话就会造成逻辑混乱，用户体验也会下降，因此需要将UITabBar隐藏
  
  
  ## 6.2 导航控制器UINavigationController
  UINavigationController：同级页面之间的跳转，界面典型的特点就是页面上部有一UINavigationBar导航条，导航条可以设置标题、左上角的按钮（一般用于返回），右上角的按钮，也可以自定义这些元素。
  
  ## 6.3 标签页控制器UITabBarController
  UITabBarController：父子页面之间的嵌套关系，界面典型的特点是耍耍下部有一UITabBar选项组，通过点击Tab，可切换上面的视图的变换。
  
  # 8 提醒用户
  ## 8.1 警告框AlertView
  初始化一个alertView,并添加确定和取消监听事件
  
  ```
  UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"温馨提示" message:[NSString stringWithFormat:@"您点击了第%ld段",(long)seg.selectedSegmentIndex + 1] preferredStyle:UIAlertControllerStyleAlert];
  [alert addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {
     确定点击事件
  }]];
  [alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {
     取消点击事件        
  }]];
  [self presentViewController:alert animated:true completion:nil];
  ```
  ## 8.2 操作表AlertSheet
  初始化一个sheetAlert,并添加确定和取消监听事件
  ```
  - (IBAction)onActionSheet:(id)sender {
      UIAlertController *alert = [UIAlertController alertControllerWithTitle:@"温馨提示" message:@"操作表" preferredStyle:UIAlertControllerStyleActionSheet];
      [alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil]];
      [alert addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleDestructive handler:nil]];
      [self presentViewController:alert animated:YES completion:nil];
  }
  ```
  ## 8.3 活动指示器IndicatorView
  初始化一个IndicatorView，并添加取消和关闭逻辑
  ```
  @property (weak, nonatomic) IBOutlet UIActivityIndicatorView *av;
  - (IBAction)onIndicatorView:(UIButton *)sender {
      if(_av.isAnimating){
          [_av stopAnimating];
          [sender setTitle:@"活动指示器开始" forState:UIControlStateNormal];
      }else{
          [_av startAnimating];
          [sender setTitle:@"活动指示器停止" forState:UIControlStateNormal];
      }
  }
  ```
  
  ## 8.4 进度条ProgressView
  初始化一个ProgressView,并添加取消和关闭逻辑
  ```
  - (IBAction)onProgress:(id)sender {
      [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(onTimer:) userInfo:nil repeats:YES];
  }
  
  - (void)onTimer:(NSTimer *)sender{
      _progressBar.progress +=0.025;
      if(ABS(_progressBar.progress-1)<0.0001){
          [sender invalidate];
          _progressBar.progress = 0;
      }
  }
  ```
  # 9 表视图UITableView
  ## 9.1 表视图结构
  表视图类即UITableView,iOS有一个专门展示表格视图的视图控制器类：UITableViewController.
  UITableView由很多节(section)构成,每一节section有头有尾，中间由一个一个单元格构成。
  ![1555e57b.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\1555e57b.png)
  ### 9.1.2 相关类
  UITableViewCell类
  该类定义了表格的每一行，因为只有单独一列，于是单元格就是一行。作为构成表格的基本单位，
  UITableViewCell预置有4种样式，如果不够用，还可以自由定制。
  
  UITableViewController类
  和普适性的UIViewController相比，其默认包含了一个全屏显示的UITableView,
  已经默认实现了若干方法，在覆写其方法时。
  
  ### 9.1.3 表视图种类
  依据表格的分节是否紧挨在一起，表视图分为两种样式
  1. 平面表(plain)
  以表一般不分节，分节的话各节也是紧挨着的，比如iOS系统内置的记事本应用、通讯录列表等。
  对应的样式的值是UITableViewStylePlain.
  ![a4614527.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\a4614527.png)
  
  2. 分节表(group)
  此表节之间隔开一定距离。比如iOS系统的设置程序，就是典型的分节的表。
  对应的样式值是UITableViewStyleGroup.
  ![1d4c6a54.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\1d4c6a54.png)
  
  ### 9.1.4 单元格样式
  UITableViewCell系统预定义有4种样式。
  ![b7f9b52b.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\b7f9b52b.png)
  
  ### 9.1.5 表视图协议
  表视图总共有两个协议UITableViewDataSource，UITableViewDelegate.
  UITableViewDataSource：用来控制表视图的显示内容
  UITableViewDelegate：用来控制表视图的显示以及每个cell的高度和每个分区的头尾高度等；
  
  ## 9.4 搜索栏制作
  ### 9.4.1 UISearchBar和UISearchController
  初始化 UISearchBar 和协议
  ```
  @interface ViewController ()<UISearchResultsUpdating>
  {
      UISearchBar *bar;
      UISearchController *searchCon;
  }
  
  - (void)viewDidLoad {
      [super viewDidLoad];
     
      //初始化UISearchController
      searchCon = [[UISearchController alloc]initWithSearchResultsController:nil];
      bar = searchCon.searchBar;
      [bar sizeToFit];
      searchCon.searchResultsUpdater = self; //指定搜索事件代理
      self.tableView.tableHeaderView = bar; //将搜索框作为表格的表头
  
  }
  
  ```
  协议初始化
  ```
  -(void)updateSearchResultsForSearchController:(UISearchController *)searchController
  {
      NSMutableArray *array = [NSMutableArray new];
      for(NSArray *arr in dataBackup){
          for(NSString *name in arr){
              //bar.text为索引
              if([bar.text isEqualToString:@""] || [name containsString:bar.text]){
                  [array addObject:name]; 
              }
          }
      }
      data =array;//将搜索的匹配结果赋值给data
      if(!searchCon.isActive){
          data=dataBackup;
      }
      [self.tableView reloadData]; //刷新表格
  }
  ```
  # 10 IOS常用设计模式
  ## 10.1 单例模式
  ios中单例模式，不通过alloc和init来新建，而是直接通过一个类方法来获取，全局这个类就只有一个对象。
  ```
  //获取AppDelegate单例
  [[UIApplication sharedApplication]delegate];
  //获取剪贴板单例
  UIPasteboard *board = [UIPasteboard generalPasteboard];
  //获取简单数据的存储类
  NSUserDefaults *def = [NSUserDefaults standardUserDefaults];
  //获取消息中心类
  NSNotification *center = [NSNotificationCenter defaultCenter];
  ```
  自己创建单例模式类
  ```
  @interface DataCache : NSObject
  +(instancetype)sharedData;
  @end
  @implementation DataCache
  
  static DataCache *data;
  +(instancetype)sharedData{
      static dispatch_once_t once;
      dispatch_once(&once,^{
          data = [[self alloc]init];
      });
      return data;
  }
  @end
  ```
  ## 10.2 委托模式
  委托模式，本质上是通过接口，将接口的方法定义，和方法的具体实现分离，
  而提高灵活性。委托模式主要用于传递数据，比如常见的登录界面后，如何通知之前的界面登录结果。这时可以考虑用委托模式，建立协议，使用代理。凡是调用登录框的控制器，都需要实现这个协议，这样的话就能很方便地把登录结果数据传递过去。
  
  委托方实现
  ```
  创建协议 、声明协议方法
  @protocol SubViewDelegate <NSObject>
   - (void)backWithStr:(NSString *) str;
  @end
  创建一个代理属性
  @property (nonatomic, weak) id<SubViewDelegate> delegate;
  执行协议方法
  // 判断代理是实现该方法，避免carsh
  if ([self.delegate respondsToSelector:@selector(backWithStr:)]) {
  [self.delegate backWithStr:self.textField.text];
  }
  ```
  代理方实现
  ```
  遵守(继承)协议
  @interface ViewController () <SubViewDelegate>
  将代理设为自己
  subVC.delegate = self;
  实现代理方法
  - (void)backWithStr:(NSString *)str {
  self.label.text = str;
  }
  ```
  ## 10.3 观察者模式
  如果当一件事情发生后，需要通知多个对象执行方法，比如更换账号登录，需要通知多个界面进行更新显示。这时候就需要观察者模式，IOS提供了一个通知中心类。
  NSNotificationCenter.其本身是一个单例对象。对某个通知感兴趣的对象，可以在通知中心注册一下感兴趣的通知。当有这个通知到来时，所有注册了这个通知的对象都会
  收到通知从而响应。
  
  viewWillAppear和viewDidDisAppear 方法是控制器的两个生命周期回调方法。
  分别在视图将要呈现时回调，以及在视图已经消失时候回调。
  
  观察者模式实现
  ```
  向通知中心注册
  -(void)viewWillAppear:(BOOL)animated{
      NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
      指定一个selector作为收到通知时的响应方法。
      [center addObserver:self selector:@selector(onChanged:) name:UITextFieldTextDidChangeNotification object:nil];
  }
  
  向通知中心销毁
  -(void)viewDidDisappear:(BOOL)animated{
      NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
      [center removeObserver:self name:UITextFieldTextDidChangeNotification object:nil];
  }
  
  -(void)onChanged:(NSNotification *)sender{
      self.textLabel.text = self.textField.text;
  }
  ```
  # 11 数据存储
  ## 11.1 文件保存与恢复
  ### 11.1.1 沙盒机制
  什么是沙盒？相当于一个文件系统监狱，App被限制在这个监狱中，对监狱之外的事物一无所知。每个App都是一个隔离的沙盒，彼此之间不能访问，老死不相往来。
  
  沙盒的目录结构如下：
  默认情况下，每个沙盒含有3个文件夹:Documents,Library和tmp.因此应用的沙盒机制，应用只能在几个目录下。
  1. Documents:苹果建议将程序中建立的或在成续重浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录。
  2. Library: 存储程序的默认设置或其他状态信息。
  3. Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出时删除。
  4. tmp:提供一个即时创建临时文件的地方。iTunes在与iPhone同步时，备份所有的Documents和Library文件。
  
  iPhone在重启时，会丢弃所有的tmp文件。
  这些文件夹路径，必须通过专用的方法来获取，获取到的路径字符串，前面有一串随机字符串，每次重启IOS后这一串随机字符串都不相同，因此保存这个路径是没有用的。必须严格按照方法来重新获取路径。
  
  ### 11.1.2 数据类的保存和恢复
  1.从沙盒获取一个保存数据的路径
  2.将数据写入对应的路径。
  
  从沙盒获取路径函数
  ```
  NSString *homedirectory = NSHomeDirectory();
  //返回值是主目录，在IOS中表示打开程序的沙盒主目录
  ```
  获取要保存的数据目录
  ```
  NSArray *document = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask , YES);
  //NSSearchPathDirectory 表示要查找的目录
  //NSSearchPathDomainMask 是一个根目录，用来指定查找范围
  //expandTilde 表示是否展开的波浪号
  ```
  将文件与路径连接
  ```
  NSString *path = [doc stringByAppendingPathComponent:@"array.plist"];
  //用来连接字符串，并且只能作用在文件路径上。
  ```
  写入文件
  ```
  写入NSArry数组
  [array writeToFile:path atomically:YES];
  //writeToFile 表示要写入的路径，路径+文件名
  //atomically 表示数据写入一个备用的文件，意思是保存文件改名了，改成Path路径中的文件名。
  ```
  读文件
  ```
  NSArray *document = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask , YES);
  NSString *doc = document[0];
  NSString *path = [doc stringByAppendingPathComponent:@"array.plist"];
  NSArray *documentResource = [[NSArray alloc]initWithContentsOfFile:path];
  ```
  
  注意
  1:NSArry和NSDictionary保存的文件格式是XML文档，后缀名要用Plist.
  2:写入Plist文件，数据类型有限制：NSInteger,CGFloat,NSString,NSDate,NSDictionary.
  
  ### 11.1.3 文件操作相关类
  文件操作相关类可以通过NSFileManager来操作,NSFileManager运用了单例模式.
  ```
  NSFileManager *fileManager = [NSFileManager defaultManager];
  ```
  
  创建文件夹
  ```
  BOOL ok = [fileManager createDirectoryAtPath:myDirectory withIntermediateDirectories:YES attributes:nil error:nil];
  if(ok){
  NSLog(@"创建成功");
  }else{
  NSLog(@"创建失败");
  }
  ```
  取得一个目录下的所有文件名
  ```
  NSArray *files = [fileManager subpathsOfDirectoryAtPath:myDirectory error:nil];
  ```
  移动文件
  ```
  if([fileManager moveItemAtPath:filePath1 toPath:filePath2 error:nil]!=YES){
  }
  else{
  }
  ```
  删除文件
  ```
  if([fileManager removeItemAtPath:filePath error:nil]!=YES){    
  }
  else{
  }
  ```
  判断是否是文件夹
  ```
  BOOL isDir = NO;
  [fileManager fileExistsAtPath:path isDirectory:(&isDir)];
  ```
  获取文本
  
  ```
  NSFileManager *fileManager = [NSFileManager defaultManager];
  NSData *data = [fileManager contentsAtPath:@"path"];
  NSString *string =[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
  ```
  获取图片
  ```
  NSData *myData = [fileManager contentsAtPath:@"path"];
  UIImage *myImage = [UIImage imageWithDate:myData];
  ```
  ## 11.2 内置数据库sqlite3
  ### 11.2.1 概述
  在iOS中使用SQLite，需要加入libsqlite3.tbd的库，并引入SQLite的头文件。
  ![404fc22c.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\404fc22c.png)
  
  ![45faa0fe.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\45faa0fe.png)
  
  ### 11.2.1 sqlite3 接口函数介绍
  
  打开数据或创建数据库
  ```
  NSArray *document = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask , YES);
  NSString *path = [document[0] stringByAppendingPathComponent:@"demo.db"];
  第一个参数数据库存放路径，如果路径下没有数据库文件则系统会在此路径下创建一个数据库。
  第二个参数则是数据库的句柄引用，但此函数调用成功后此句柄将会保存打开数据库的句柄，此句柄在往后的数据库操作中需要用到。
  if(sqlite3_open([path UTF8String], &dbHandle)==SQLITE_OK){
  NSLog(@"打开数据库成功"); }
  ```
  对数据库进行操作,有两种方式。
  第一种通过sqlite3_exec函数，这种方式一般使用在不返回数据集的情况。
  主要用于创建表结构，更新，插入，删除。
  ```
  char *errorMsg;
  第一个参数打开数据库的句柄
  第二个参数SQL语句
  第三个参数回调方法的函数指针
  第四个参数回调第一个参数引用
  第五个参数是一个指向指针的指针，用来保存方法执行异常时返回的错误描述信息
  if(sqlite3_exec(dbHandle, "create table if not exists persons (id integer primary key autoincrement,name);", NULL, NULL, &errorMsg)!=SQLITE_OK){
  NSLog(@"操作失败!");
  }else{
  NSLog(@"创建数据表成功");
  }
  sqlite3_free(errorMsg);//释放errorMsg，避免内存泄漏
  ```
  第二种通过sqlite3_prepare_v2与sqlite3_step
  ```
  sqlite3_stmt *statement;
  const char *insertSQL = "insert into persons (name) values ('zhouwei')";
  第一个参数打开数据库时的数据库句柄对象
  第二个参数SQL语句
  第三个参数用于指定SQL语句最大的长度
  第四个参数是调用函数后返回的第一个结构体包含相关语句信息。（sqkute3_step）
  第五个参数用于指向前一条语句结束位置
  int insertResult = sqlite3_prepare_v2(dbHandle, insertSQL, -1, &statement, nil);
  if(insertResult !=SQLITE_OK){
  NSLog(@"添加失败,%d",insertResult);
  }else{
  NSLog(@"添加成功");
  sqlite3_step(statement);}
  sqlite3_finalize(statement);
  ```
  ## 11.3 CoreData
  
  ### 11.3.1 建立数据模型
  在创建项目时候选中User Core Data
  ![f0374e34.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\f0374e34.png)
  
  根据Xcode生成的文件，来定义数据表。
  ![6b956759.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\6b956759.png)
  
  ![63d366a1.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\63d366a1.png)
  
  ![0a8353cd.png](:storage\\05d16d8d-e897-4494-83d1-17e51deed363\\0a8353cd.png)
  右侧窗口的Codegen选项，选择Class Definition的话，可以自动生成实体类代码。
  类文件将以类名开头
  ### 11.3.2 使用CoreData
  获取实体类引用
  ```
  NSFetchRequest *req = [NSFetchRequest fetchRequestWithEntityName:@"AddressBook"];
  NSError *err = nil;
  NSArray *data = [self.persistentContainer.viewContext executeFetchRequest:req error:&err];
  ```
  
  增加数据
  ```
  NSArray<NSString *> *names = @[@"张三",@"李四",@"王五"];
  NSArray<NSString *> *phones = @[@"18612345678", @"18687654321", @"18912348765"];
  for(int i = 0; i<names.count;i++){
  AddressBookEntity *entity = 
  [NSEntityDescription 
  insertNewObjectForEntityForName:@"AddressBook" inManagedObjectContext:self.persistentContainer.viewContext];
  
  entity.name = names[i];
  entity.phone = phones[i];
  }
  [self saveContext];
  ```
  查找数据
  ```
  NSArray<AddressBookEntity *> *data;
  NSFetchRequest *req = [NSFetchRequest fetchRequestWithEntityName:@"AddressBook"];
  NSError *err = nil;
  AppDelegate *app = (AppDelegate *)[[UIApplication sharedApplication]delegate];
  NSArray *d = [app.persistentContainer.viewContext executeFetchRequest:req error:&err];
  if(err){
  NSLog(@"%@",err);
  }else{
  data = d;
  }
  AddressBookEntity *entity = data[indexPath.row];
  cell.textLabel.text = entity.name;
  cell.detailTextLabel.text = entity.phone;
  ```
  修改数据
  ```
  // 改变张三的电话为18611111111
  // 1.查找到张三
  // 1.1FectchRequest 抓取请求对象
  NSFetchRequest *request = [NSFetchRequestfetchRequestWithEntityName:@"AddressBook"];
  // 1.2设置过滤条件
  // 查找zhangsan
  NSPredicate *pre = [NSPredicate predicateWithFormat:@"name = %@", @"张三"];
  request.predicate = pre;
  // 1.3执行请求
  AppDelegate *app = (AppDelegate *)[[UIApplication sharedApplication] delegate];
  NSArray *abs = [app.persistentContainer.viewContext executeFetchRequest:request error:nil];
  // 2.更新身高
  for (AddressBookEntity *e in abs) {
  e.name = @"18611111111";}
  // 3.保存
  [app saveContext];
  ```
  删除数据
  ```
  // 删除 李四
  // 1.查找李四
  // 1.1FectchRequest 抓取请求对象
  NSFetchRequest *request = [NSFetchRequest mfetchRequestWithEntityName:@"AddressBook"];
  // 1.2设置过滤条件
  // 查找李四
  NSPredicate *pre = [NSPredicate predicateWithFormat:@"name = %@",@"李四"];
  request.predicate = pre;
  // 1.3执行请求
  AppDelegate *app = (AppDelegate *)[[UIApplication sharedApplication] delegate];
  NSArray *abs = [app.persistentContainer.viewContext executeFetchRequest:request error:nil];
  // 2.删除
  for (AddressBookEntity *e in abs) {
  [app.persistentContainer.viewContext deleteObject:e];
  }
  // 3.保存
  [app saveContext];
  ```
  
  
  ## 参考文献
  [IOS进阶之WKWebView - 简书](https://www.jianshu.com/p/4fa8c4eb1316)
  [教你使用 WKWebView 的正确姿势_一头雾水的Blog-CSDN博客_wkwebview](https://blog.csdn.net/guojin08/article/details/78895695)
  [IOS进阶之WKWebView - 简书](https://www.jianshu.com/p/4fa8c4eb1316)
  [[IOS开发初学者]UINavigationController详解 - 简书](https://www.jianshu.com/p/ef1cd11a4b53)
  [iOS-UINavigationController基本使用 - 简书](https://www.jianshu.com/p/47d2708f95e7)
  [iOS ViewController跳转界面的几种方法简单总结 - 简书](https://www.jianshu.com/p/ceaf978f9dfe)
  [[纯代码]搭建UINavigationController与UITabBarController主流App框架整合 - 简书](https://www.jianshu.com/p/9c12bc9ca414)
'''
linesHighlighted: [
  46
  5
]
isStarred: false
isTrashed: false
