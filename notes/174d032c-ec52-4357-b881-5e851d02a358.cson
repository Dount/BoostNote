createdAt: "2020-09-07T13:12:52.024Z"
updatedAt: "2020-09-14T16:13:44.636Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "C++ 核心编程"
tags: []
content: '''
  # C++ 核心编程
  [TOC]
  
  ## 1.内存模型
  ### 1.1代码区
  - 存放CPU执行的机器指令
  - 代码区是共享的，共享的目的是对于频繁执行的程序，只需要再内存中又一份代码即可。
  - 代码区是只读的，使其只读的原因是防止程序以外地修改了它的指令.
  
  ### 1.2 全局区
  - 全局变量和静态变量存在在此。
  - 全局区还包含了常量去，字符串常量和其他常量也存放在此。
  - 该区域的数据在程序结束后由操作系统释放。
  
  ### 1.3 栈区
  - 由编译器自动分配释放。
  - 局部变量存放在栈区，栈区的数据在函数执行完毕后自动释放。
  
  ### 1.4 堆区
  - 由程序员分配和释放
  - 若程序员不释放由系统回收。
  - 在C++中主要利用new在堆区开辟内存
  - **指针本质也是局部变量，存放在栈上，指针保存的数据是放在堆区**。
  ### 1.5 new操作符
  c++中利用new操作符在堆区开辟数据
  堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete.
  ```
  int *fun(){
      int * a =new int(10);
      return a;
  }
  
  int main(){
  
      int *p =fun();
      cout<< *p<<endl;
      cout<< *p<<endl;
      delete p;
      cout<< *p<<endl;
  
      int *arr=new int[10];
      for(int i=0;i<10;i++){
          arr[i]=i+100;
      }
  
      for(int i=0;i<10;i++){
          cout<<arr[i]<<endl;
      }
      //释放数组
      delete []arr;
  
      system("pause");
      return 0;
  }
  ```
  
  ## 2.引用
  
  ### 2.1 引用的基本语法
  作用：给变量起别名
  语法：数据类型 &别名 =原名
  ```
  int main(){
  
      int a= 10;
      int &b=a;
  
      cout<< "a="<<a<<endl;
      cout<< "b="<<b<<endl;
  
      b=100;
      cout<<"a=" <<a<<endl;
      cout<<"b=" <<b<<endl;
      
      system("pause");
      return 0;
  }
  ```
  ### 2.2 引用注意事项
  - 引用必须初始化 (int &b;错误)
  - 引用在初始化后，不可以改变 
  ```
  int main(){
  
     int a=10;
     //引用必须初始化
     int &b=a;
     //引用初始化后，不可以改变
     int c=20;
     
     b=c; //赋值操作，而不是更改引用
  
     cout<<"a="<<a<<endl;
     cout<<"b="<<b<<endl;
     cout<<"c="<<c<<endl;
     system("pause");
     return 0;
  }
  ```
  
  ### 2.3 引用做函数参数
  函数传参时，利用引用的技术让形参修饰实参，可以简化指针修改实参。
  ```
  int mySwap03(int &a,int &b){
     int temp =a;
     a=b;
     b=temp;
  }
  
  int main(){
     int a=10;
     int b=20;
     mySwap03(a,b);
     cout<<"a="<<a<<endl;  //a=20
     cout<<"b="<<b<<endl;  //b=10
     
     system("pause");
     return 0;
  }
  ```
  
  ### 2.4 引用做函数返回值
  - 不要返回局部变量的引用
  - 函数的调用可以作为左值
  ```
  int& test1(){
     int a=10;
     return a;
  }
  
  int& test2(){
     static int a=20;
     return a;
  }
  
  int main(){
     //不能返回局部变量的引用
     int& ref=test1();
     cout<<"ref="<<ref<<endl;
     cout<<"ref="<<ref<<endl;
  
     //如果函数做左值，那么必须返回引用
     int& ref2=test2();
     cout<<"ref2="<<ref2<<endl;
     cout<<"ref2="<<ref2<<endl;  
     test2() =1000;
  
     cout<<"ref2="<<ref2<<endl;
     cout<<"ref2="<<ref2<<endl;
  
     system("pause");
     return 0;
  }
  ```
  ### 2.5 引用的本质
  **引用的本质在C++内部实现是一个指针常量**
  ```
  //发现是引用，转换为 int*const ref =&a;
  void fun(int& ref){
     ref =100; //ref 是引用，转换为*ref =100
  }
  
  int main(){
     int a=100;
  
     //自动转换为 int* const ref =&a;指针常量时指针指向不可改变。
     int& ref=a;
     ref =20;// 内部发现ref是引用，自动转换为：*ref =20;
     cout<<"a:"<<a<<endl;
     cout<<"ref:"<<ref<<endl;
     fun(a);
     cout<<"ref:"<<ref<<endl;
     system("pause");
     return 0;
  }
  ```
  
  ### 2.6 常量引用
  - 引用主要用来修饰形参，防止误操作。
  - 数形参列表中可以const修饰实参，防止形参改变实参。
  ```
  void fun(const int& ref){
     //ref =100; //不能进行修改.
     cout<<ref<<endl;
  }
  
  int main(){
     const int& ref =10;
     //ref=100; 加入const后不可以修改变量.
     
  
     int a =10;
     fun(a);
     system("pause");
     return 0;
  }
  ```
  
  ## 3 函数提高
  
  ### 3.1 函数的默认参数
  在C++中 函数的形参列表中形参是可以有默认值的。
  语法：返回值类型 函数名 (参数=默认值){}
  - 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
  - 如果函数声明有默认值，函数实现的时候就不能有默认参数
  
  ### 3.2 函数的重载
  函数名可以相同，提高复用性
  
  函数重载满足条件:
  - 同一个作用域下
  - 函数名称相同
  - 函数参数类型不同，或者个数不同或者顺序不同
  ```
  void fun(){
     cout<<"func的调用！"<<endl;
  }
  
  void fun(int a){
     cout<<"a="<<a<<endl;
  }
  
  void fun(int a,int b){
     cout<<"a="<<a<<",b="<<b<<endl;
  }
  
  void fun(int a,double b){
     cout<<"a="<<a<<",b="<<b<<endl;
  }
  
  void fun(double b,int a){
     cout<<"a="<<a<<",b="<<b<<endl;
  }
  
  int main(){
     fun();
     fun(10);
     fun(10,5);
     fun(5,10.5);
     fun(10.5,5);
     system("pause");
     return 0;
  }
  ```
  ### 3.3 函数重载的注意事项
  - 引用作为重载条件
  - 函数重载碰到函数默认参数
  
  ## 4 类和对象
  
  ### 4.1 封装
  #### 4.1.1 封装的意义
  - 将属性和行为作为一个整体，表现生活中的事务.
  - 将属性和行为加以权限控制
  ```
  class Circle{
  public : //访问权限，公共的权限
     int m_r; //属性
     //行为
     double calculateZC(){
        return  2 * PI * m_r;
     }
  };
  
  int main(){
     Circle c1; //创建对象
     c1.m_r=10; //对属性进行赋值
     cout<<"圆的周长为="<<c1.calculateZC()<<endl;
  
     system("pause");
     return 0;
  }
  ```
  #### 4.1.2 封装案例
  ```
  class Student{
     public:
        void setName(string name){
           m_name =name;
        }
        void setID(int id){
           m_id=id;
        }
        void showStudent(){
           cout<<"name:"<<m_name<<"ID:"<< m_id <<endl;
        }
  
     public:
        string m_name;
        int m_id;
  };
  
  int main(){
  
     Student mstudent;
     mstudent.setName("德玛西亚");
     mstudent.setID(250);
     mstudent.showStudent();
  
     system("pause");
     return 0;
  }
  ```
  
  #### 4.1.3 访问权限
  - 公共权限public 成员类内可以访问，类外可以访问
  - 保护权限protected 成员类内可以访问，类外不可以访问 儿子可以访问父亲中的保护内容。
  - 私有权限private 成员类内可以访问，类外不可以访问 儿子不可以访问父亲的私有内容。
  
  #### 4.1.4 struct和class区别
  在C++中struct和class唯一的区别就在于默认的访问权限不同。
  - struct默认权限为公共
  - class默认权限为私有
  
  ```
  class Student{
     int m_A; //默认是私有权限
  };
  
  struct teacher{
     int m_A; //默认是公共权限
  };
  ```
  #### 4.1.5 成员属性设置为私有
  优点1：将所有成员属性设置为私有，可以自己控制读写权限。
  优点2：对于写权限，我们可以检测数据的有效性。
  
  ### 4.2 对象的初始化和清理
  
  #### 4.2.1 构造函数和析构函数
  C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，
  完成对象初始化和清理工作。对象的初始化和清理工作时编译器强制要求我们做的事情，
  **因此如果我们不提供构造和析构，编译器会提供构造函数和析构函数的空实现。**
  - 构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
  - 析构函数：主要作用于对象销毁前系统自动调用，执行一些清理工作。
  
  #### 4.2.2 构造函数语法
  类名(){}
  1. 构造函数，没有返回值也不写void。
  2. 函数名称与类名相同。
  3. 构造函数可以有参数，因此可以发生重载。
  4. 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次。
  
  #### 4.2.3 析构函数
  ~类名(){}
  1. 析构函数，没有返回值也不写void。
  2. 函数名称与类名相同，在名称前加上符号 ~。
  3. 析构函数**不可以有参数**，因此不可以发生重载。
  4. 程序在对象**销毁前会自动调用析构**，无须手动调用，而且只会调用一次。
  
  #### 4.2.4 构造和析构案例
  ```
  class Person{
     public:
     //构造函数
     Person(){
        cout<<"Person的构造函数调用"<<endl;
     }
  
     ~Person(){
        cout<<"Person的析构函数调用"<<endl;
     }
  };
  
  //为了保证析构函数能走到，因此采用局部方法来调用。
  //系统函数在对象销毁的情况下调用。如果在Main函数中不会自动调用析构。
  void test01(){
     Person p;
  }
  
  int main(){
     test01();
     system("pause");
     return 0;
  }
  ```
  
  #### 4.2.5 构造函数的分类和调用
  两种分类方式：
  按参数分为：有参构造和无参构造
  按类型分为：普通构造和拷贝构造
  
  三种调用方式：
  括号法
  显示法
  隐式转换法
  ```
  class Person{
  
  public:
        int age;
  
  public:
        //无惨(默认)构造函数
        Person(){
           cout << "无参构造函数"<<endl;
        }
        //有参构造函数
        Person(int a){
           age =a;
           cout<<"有参构造函数！"<<endl;
        }
        //拷贝构造函数
        Person(const Person& p){
           age=p.age;
           cout<<"拷贝构造函数！"<<endl;
        }
        //析构函数
        ~Person(){
           cout <<"析构函数"<<endl;
        }
  };
  
  //调用无参构造函数
  void test01(){
     Person p;
  }
  
  //调用有参的构造函数
  void test02(){
     //括号法
     Person p1(10);
     //调用拷贝构造方法。
     //Person p2(p1);
  
     //显示法
     Person p2 = Person(10);
     //调用拷贝构造方法。
     Person p3 = Person(p2);
     
     //隐式转换法
     Person p4 =10; //Person p4 =Person(10);
     Person p5 =p4; //Person p5 =Person(p4);
  }
  
  int main(){
     test01();
     test02();
     system("pause");
     return 0;
  }
  ```
  #### 4.2.6 拷贝构造函数调用时机
  C++中拷贝构造函数调用时机通常有三种情况
  - 使用一个已经创建完毕的对象来初始化一个新对象。
  - 值传递的方式给函数参数传值。
  - 以值方式返回局部对象。
  
  #### 4.2.7 构造函数调用规则
  默认情况下，c++编译器至少给一个类添加3个构造函数
  1. 默认构造函数(无参，函数体为空)
  2. 默认析构函数(无参，函数体为空)
  3. 默认拷贝构造函数，对属性进行值拷贝 (值拷贝)
  
  构造函数调用规则如下：
  - 如果用户定义**有参构造函数**，c++不在提供默认无参构造，但是会提供默认拷贝构造。
  - 如果用户自定义拷贝构造函数，c++不会再提供其他构造函数。
  ```
  class Person{
  public:
        Person(){
           cout << "无参构造函数"<<endl;
        }
  
        Person(int a){
           age =a;
           cout<<"有参构造函数！"<<endl;
        }
  
        Person(const Person& p){
           age=p.age;
           cout<<"拷贝构造函数！"<<endl;
        }
        ~Person(){
           cout <<"析构函数"<<endl;
        }
        int age;
  };
  
  //如果有了自定义有参构造函数，不在提供默认构造函数，但会提供拷贝构造函数。
  void test01(){
     //Person(); //会报错
     Person p1(28);
     Person p2(p1);
     cout<<"age="<<p2.age<<endl;
  }
  
  //如果有了自定义拷贝构造行数，不再提供其它的构造函数
  void test02(){
     Person p1(10); //没有其它的构造函数可以传递值。
  }
  
  int main(){
     test01();
     system("pause");
     return 0;
  }
  ```
  #### 4.2.8 深拷贝与浅拷贝 (重点)
  浅拷贝：简单的赋值拷贝操作。**会带来堆区的内存重复释放的问题，需要用深拷贝解决**
  深拷贝：在堆区重新申请空间，进行拷贝操作。
  ```
  class Person{
  public:
        Person(){
           cout << "无参构造函数"<<endl;
        }
  
        Person(int a,int height){
           age =a;
           m_Height=new int(height);
           cout<<"有参构造函数！"<<endl;
        }
  
        Person(const Person& p){
           age=p.age;
           cout<<"拷贝构造函数！"<<endl;
           //m_Height =p.m_Height;//编译器会自己实现这行代码。但为了解决问题，不能让编译器执行。
           //需要在堆上再开辟一个内存。
           m_Height=new int(*p.m_Height);
        }
  
        ~Person(){
           //析构函数中释放掉创建在堆区上的内存。
           if(m_Height!=NULL){
              //会出问题，由于堆区是先进后出的释放对象，P2会提前把m_Height堆上创建的内存释放掉，导致P1再去释放时找不到。
              delete m_Height;
              m_Height =NULL;
           }
           cout <<"析构函数"<<endl;
        }
        int age;
        int *m_Height ;
  };
  
  void test01(){
     Person p1(28,160);
     cout<<"age="<<p1.age<<endl;
     cout<<"height="<<*p1.m_Height<<endl;
  
     Person p2(p1);
     cout<<"age="<<p2.age<<endl;
     cout<<"height="<<*p2.m_Height<<endl;
  }
  
  int main(){
     test01();
     system("pause");
     return 0;
  }
  
  ```
  #### 4.2.9 初始化列表
  语法：构造函数():属性1(值1),属性2(值2)....{}
  ```
  Person(int a,int b, int c):m_A(a),m_B(b),m_C(c)
  {
  
  }
  ```
  
  #### 4.2.10 类对象作为类成员
  **当其他类对象作为本类成员，构造时候先构造类对象，再构造自身，析构的顺序与构造相反。
  ```
  class Phone{
  public:
       Phone(string name){
          m_Phonename=name;
          cout<<"Phone构造函数"<<endl;
       }
       ~Phone(){
          cout<<"Phone析构函数"<<endl;
       }
       string m_Phonename;
     
  };
  
  class Person{
  public:
        Person(string name,string pname):m_name(name),m_phone(pname){
           cout<<"Person构造函数"<<endl;
        }
        ~Person(){
           cout<<"Person析构函数"<<endl;
        }
        void playGame(){
           cout<<"Person:"<<m_name << ",mPhone:"<<m_phone.m_Phonename<<endl;
        }
        string m_name;
        Phone m_phone;
  };
  
  void test01(){
     Person p("zhouwei","iphone");
     p.playGame();
  }
  
  int main(){
     test01();
     system("pause");
     return 0;
  }
  ```
  
  #### 4.2.11 静态成员
  静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员。
  静态成员分为：
  1. 静态成员变量
     1)所有对象共享同一份数据
     2)在编译阶段分配内存
     3)类内声明，类外初始化
  2. 静态成员函数
     1)所有对象共享同一个函数
     2)静态成员函数只能访问静态成员变量，即不可以访问非静态成员变量。
  
  ```
  class Person{
     public:
     //静态成员函数特点:
     //1 程序共享一个函数
     //2 静态成员函数只能访问静态成员变量
     static void func(){
        cout << "func调用" <<endl;
        m_A =100;
        //m_B =100;  不可以访问非静态成员变量
     }  
     static int m_A;//静态成员变量
     int m_B;
     private:
     //静态成员函数也有访问权限
     static void func2(){
        cout << "func2调用" <<endl;
     }
  };
  int Person ::m_A =10; 
  
  int main(){
     //静态成员变量两种访问方式
     //1.通过对象
     Person p1;
     p1.func();
     //2. 通过类名
     Person::func();
     //Person::func2();// 私有权限访问不到
     system("pause");
     return 0;
  }
  ```
  ### 4.3 C++ 对象模型和this指针
  
  #### 4.3.1 成员变量和成员函数分开存储
  在C++中，类内的成员变量和成员函数分开存储
  只有非静态成员变量才属于类的对象上。
  ```
  int m_A //非静态成员变量，属于类的对象上
  static int m_B //非静态成员变量 不属于类的对象上
  void func(){} //非静态成员函数 不属于类对象上
  static void func2(){} //静态成员函数 不属于类的对象上
  ```
  #### 4.3.2 this 指针概念 (重要)
  **this 指针指向被调用的成员函数所属的对象**
  
  this指针是隐含每一个非静态成员函数的一种指针。
  this指针不需要定义，直接使用即可。
  
  this指针的用途:
  - 当形参和成员变量同名时，可用this 指针来区分 (解决名称冲突)
  - 在类的非静态成员函数中返回对象本身，可使用return *this 
  ```
  class Person{
  public:
     Person(int age){
        //当形参和成员变量同名时，可用this指针来区分.
        this->age =age;
     }
  
     //返回值的话就是创建新的对象，返回引用的话就不会创建新对象。
     Person& PersonAddPerson(Person &p){
        this->age +=p.age;
        //返回对象本身
        return *this;
     }
  
     int age;
  };
  
  void test01(){
     Person p1(10);
     cout << "p1.age=" <<p1.age <<endl;
  
     Person p2(10); //链式编程思想
     p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
     cout<< "p2.age=" <<p2.age<<endl; 
  }
  
  int main(){
     test01();
     system("pause");
     return 0;
  }
  ```
'''
linesHighlighted: [
  177
]
isStarred: false
isTrashed: false
