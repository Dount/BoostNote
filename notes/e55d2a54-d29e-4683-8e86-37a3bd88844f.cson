createdAt: "2023-04-02T15:28:31.959Z"
updatedAt: "2023-06-05T08:33:20.468Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "清单"
tags: []
content: '''
  # 清单
  
  ## 自我介绍
  我先自我介绍一下。
  我是19年毕业后参加工作，一直从事Android开发相关工作。目前有4年Android开发经验。
  我有两份工作经历。
  第一份工作经历是在上海商泰汽车，担任Android开发工程师。
  主要围绕IVI娱乐终端系统进行开发。
  首先参与了 SDL,MirroLink,Android Auto框架下 手机与车载机连携的几款应用开发。
  其次参与了 Android Framework 中间件的开发工作。
  最后参与了一些CTS测试相关工作。
  
  第二份工作经历是在苏州科达上海研发中心，担任Android开发工程师。
  主要围绕直播，云视频会议应用以及音视频SDK的开发。
  首先参与了科达天行和摩云致邻这两款App的开发工作。
  其次参与了音视频SDK的开发工作。
  最后参与了一体化终端或轨道交通等定制化开发项目。
  
  回去合肥发展的主要两个原因
  一个原因，去年疫情父亲去世，目前我母亲在合肥生活，回合肥发展方便以后照顾我母亲。
  另一个原因，我未婚妻也在合肥工作，长期异地也不太好，沟通后决定以后回合肥定居。
  
  
  ### TCP 与串口的区别
  串口，只能一对一
  tcp 是以太网可以一对多。
  
  通讯距离
  串口小于20米，
  以太网距离随意。
  
  通讯速度，串口 小于tcp速度。
  
  TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接。
  
  #### TCP 三次握手
  1.客户端先向服务端发起SYN请求
  2.服务端收到SYN请求后，给客户端回复ACK+SYN
  3. 客户端收到后就知道服务端在线了。回复ACK，这样服务端合客户端可以进行通信。
  
  #### TCP 四次挥手
  主动关闭方给被动关闭方发送FIN请求。
  被动关闭方收到后发送ACK回复。
  被动关闭方给主动关闭方发送FIN请求。
  主动关闭方法收到后发送ACK回复。
  
  ## JAVA 
  ### Byte和位Bit的关系
  bit:    Binary digit（二进制数位）的缩写,意为“位”或“比特”，是计算机运算的基础； 
  byte:    意为字节"是计算机文件大小的基本计算单位； 
  关系:   1Byte=8bit   (简写:  1B=8b)
  ### String,StringBuffer,StringBuilder的区别
  运行速度上的区别
  String < StringBuffer < StringBuilder
  String 的操作是一个不断创建新的对象并且将旧的对象通过GC回收的一个过程，所以执行速度很慢。
  StringBuffer与StringBuilder的对象是变量，对变量进行操作就是直接对该对象进行更改，所以速度要比String快很多。
  
  线程安全上的区别
  String 是线程安全的。因为String是final修饰的类，是不可变的。
  StringBuffer是线程安全的，因为使用了Synchronized关键字进行修饰。
  StringBuilder是线程不安全的。
  
  三者的使用总结
  String：适用于少量的字符串操作的情况；
  StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况；
  StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。
  
  ### final,finally和finalize区别 
  1. final可以修饰类，方法和变量，被final修饰的类不可继承，被final修饰的方式不可重写，被final修饰的变量引用不可变，引用的内容可以更改。
  2. finally用于try-catch 代码块中，无论是否发生异常最后都将被执行，作用是释放资源。
  3. finalize 是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。
  
  ### ==和equals有什么区别?equals和hashCode有什么联系
  1. 如果是引用类型，==比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。
  2. 如果没有重写的话，equals默认按照==进行比较，如果重写了equals() 方法，则按照对应的规则比较。
  3. 两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。
  
  ### Array和ArrayList的区别
  1. Array长度在定义之后就不会改变了，而ArrayList长度可变的，可以自动化扩容。
  2. Array可以存储基本类型和对象类型，ArrayList只能包含对象类型
  
  ### 什么是面向对象
  当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。
  
  ### 什么是面向过
  当解决一个问题的时候，面向过程会把事情拆分成，一个个函数和数据。然后按照一定的顺序执行，等方法执行完了，问题得到解决。
  
  ### 简述面向对象的特性
  1) 封装：例如成员变量私有，然后提供公有的get/set方法来获取值/赋值，封装的核心思想是合理隐藏，合理暴露。可以提高安全性，实现代码的组件化
  2) 继承：一种子类到父类的关系，可以提高代码的复用性，相同代码可写到父类，子类的功能更加强大，不仅得到了父类的功能，还有自己的功能。
  3) 多态：同一个类型的对象执行相同的行为，在不同的状态下表现出不同的特征。多态可以降低类之间的耦合度，便于扩展和维护。
  
  ### 多态
  
  #### 多态概念
  就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同 的状态。
  
  #### 多态实现条件
  1. 必须在继承体系下
  2. 子类必须要对父类方法进行重写
  3. 通过父类的引用调用重写方法
  
  #### 多态体现
  重写是父类和子类的一种多态性表现
  重载是一个类的多态性的表现
  
  重写：
  1.父类的成员方法只能被子类重写，父类的构造方法不能被重写
  2.重写的方法的参数列表与被重写方法的参数列表必须完全一致，
  3.重写方法的返回类型可以与被重写方法不相同
  
  重载：
  重载是在一个类里边，方法名相同，参数不同，返回类型可以相同也可以不同。
  
  ### 列举Object类的方法
  1) equals(Object obj):判断其他对象是否与当前对象相等。
  2) toString():打印当前对象的字符串表示
  3) wait():导致当前线程等待，等待其它线程唤醒，会释放锁。
  4) notify()/notifyAll():随机唤醒一个/全部线程
  5) hashCode():返回当前对象的hashCode值。
  6) finalize():当垃圾回收期要回收对象前调用。
  7) clone:创建并返回对象的一个副本.
  
  ### 接口和抽象类有什么区别
  相同点：
  1. 都不能被实例化 
  2. 接口的实现类或抽象类的子类，都只有实现了方法后才能实例化。
  
  不同点：
  1. 实现接口的关键字为implements，继承抽象类的关键字为extends。
  2. 一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  3. 抽象类中可以有非抽象方法，接口中只能有抽象的方法。
  4. 接口中抽象方法前不能加abstract关键字，也不能加final,private,protected关键字来防止抽象方法的继承。只能用public
  5. 抽象类中抽象方法前必须加abstract关键字。
  
  ### 静态内部类与非静态内部类区别
  静态内部类可以有静态成员，而非静态内部类则不能有静态成员，但允许有静态常量。
  静态内部类可以访问外部类的静态方法和属性，不可以访问外部类的非静态变量。而非静态内部类的非静态成员可以访问外部类的非静态变量。
  静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建。
  
  ### 异常有哪些分类？出现的原因是什么？
  1.Throwable是所有错误和异常的父类,Throwable分为Error和Exception.
  2.Error指Java程序运行错误。出现Error通常是因为系统的内容部错误或资源耗尽，Error不能在运行过程中被动态处理，如果程序运行中出现Error, 系统只能记录错误的原因和安全终止。
  3.Exception指java程序运行异常，Exception又分为RuntimeException和IoExcetion,RuntimeException指在Java虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如空指针异常，数组越界等。IoExcetion指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常等。
  
  ### 单例模式
  #### 饿汉模式
  在类加载的时候，静态实例就已创建并初始化好了。
  优点： 1. 单例对象的创建是线程安全的；2. 获取单例对象时不需要加锁。
  #### 懒汉模式
  懒汉式为了支持延时加载，将对象的创建延迟到了获取对象的时候，但为了线程安全，不得不为获取对象的操作加锁
  优点：1. 对象的创建是线程安全的。2. 支持延时加载。
  #### 双重校验锁模式
  将懒汉式中的 synchronized 方法改成了 synchronized 代码块，给成员变成加上 volatile 关键字，从而禁止指令重排序。
  优点：1. 对象的创建是线程安全的。2. 支持延时加载。3. 获取对象时不需要加锁。
  #### 静态内部类
  利用Java 静态内部类的特性：Java 加载外部类的时候，不会创建内部类的实例，只有在外部类使用到内部类的时候才会创建内部类实例。
  优点：1. 对象的创建是线程安全的。2. 支持延时加载。3. 获取对象时不需要加锁。
  #### 枚举
  这种实现方式通过 Java 枚举类型本身的特性
  优点: 不用考虑懒加载和线程安全的问题,防止反序列化和反射破坏。
  
  #### 为什么要double check？去掉第二次check行不行？
  不行，当2个线程同时执行获取单例时，都会执行第一个if判断，由于锁机制的存在，会有一个线程先进入同步语句，而另一个线程等待，当第一个线程执行了new Singleton()之后，就会释放锁，没有第二重if判断，那么第二个线程也会创建一个实例，这就破坏了单例。
  
  #### singleton为什么要加上volatile关键字?
  new 一个对象不是一个原子操作，调用构造方法和初始化成员字段，为单例分配内存空间的过程存在指令重排序的问题，volatile的特性就是禁止指令重排。
  
  ### 简述一下集合主要有哪些类和接口，各自有什么特点
  
  1. 主要有两个接口Collection和Map.
  2. Collection包括List,Set和Queue
  3. Map以key-value键值对的形式存储元素,包括：HashMap、LinkedHashMap和TreeMap。
  
  ### Collection和Collections有什么区别 
  1. Collection是一个集合接口，它包括List有序结合，Set无序集合，Queue队列等。
  2. Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll 可以直接对Collection集合批量的添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或按比较器进行排序。
  
  ### List和Set比较
  List,Set都是继承自Collection接口,两者最重要的区别在于List中允许插入重复元素，Set中不允许插入重复元素。
  List特点：元素有顺序，元素可重复; 
  - ArrayList底层通过数组实现，线程不安全，插入移除元素慢，随机访问快。
  - Vector是线程安全的ArrayList，但效率较低。
  - LinkedList底层通过双向链表实现，插入移除元素快，随机访问慢，顺序访问快。
  - Stack继承自Vector，实现一个后进先出的堆栈。
  
  Set特点：元素无顺序(HashSet)，元素不可重复，重复元素会覆盖掉，
  - HashSet底层其实就是HashMap，利用了key来保证元素唯一性，(无顺序)
  - LinkedHashSet可以按照key的操作顺序排序,即保证元素添加的自然顺序。
  - TreeSet支持按照默认或指定的排序规则排序,即保证元素的自然顺序。
  
  ### List,Set,Map有什么区别？
  1. List是有序，可重复，有索引的集合，继承了Collection集合全部功能除了Collection的三种遍历方式外，可用索引遍历。
  2. Set是无序，不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或者自定义的比较规则排序。
  3. Map是无序，以Key-value的键值对形式存储元素的集合。键不可重复，重复的键对应的值会覆盖之前的值。
  
  ### HashMap的特点
  1. HashMap基于Map接口实现，元素以键值对的方式存储，　
  2. HashMap允许空键和空值（但空键只有一个，且放在第一位）
  3. HashMap中key不允许重复。
  4. HashMap是无序的，顺序会不定时改变。
  5. HashMap是线程不安全的。
  6. HashMap的初始容量为16,填充因子默认是0.75。
  
  ### 创建线程有哪几种实现方式？分别有什么优缺点？
  1.继承Thread 类，重写run()方法
  2.实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。
  3.实现Callable接口，重写Call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。
  4.通过线程池创建。
  
  ### 线程有哪些状态
  1. New:用new操作创建一个新线程，此时程序还未开始运行线程中的代码
  2. Runnable: 调用start()方法后进入可运行状态。
  3. Blocked:阻塞状态，内部锁获取失败时进入阻塞状态。
  4. Waiting:等待其他线程唤醒时进入等待状态。
  5. Timed Waiting:计时等待，带超时参数的方法，例如Sleep(Long time)
  6. Terminated:终止状态，线程正常运行完毕或未捕获异常终止。
  
  ### 什么是线程安全问题，如何解决
  线程安全问题：当多个线程共享一个全局变量，对其做写操作时，可能会受到其他线程的干扰，从而引发线程安全问题，表现形式为数据的缺失，数据 不一致等。
  
  线程安全问题的解决思路：
  
  1. 尽量不使用共享变量，将不必要的共享变量变成局部变量来使用。
  2. 使用synchronized关键字同步代码块，或者使用jdk包中提供的Lock为操作进行加锁。
  3. 使用ThreadLocal为每一个线程建立一个变量的副本，各个线程间独立操作，互不影响。
  
  ### 使用volatile的背景
  volatile主要是为了解决JMM中工作内存与主内存同步延迟现象导致的可见性问题，以及指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化。
  
  ### volatile的特性
  1. 保证此变量对所有的线程的可见性
  2. 禁止指令重排序优化
  3. 保证特定操作的执行顺序
  4. 保证某些变量的内存可见性
  5. 轻量级sychronized
  
  ### 说一说synchronized关键字的作用
  原子性：被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。
  可见性：synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。
  有序性：synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。
  
  总结：能够保证同一时刻最多只有一个线程执行该段代码,以保证并发安全的效果
  
  ### Lock接口有哪些方法
  1.lock()：给对象加锁。
  2.tryLock()/tryLock(long time,TimeUnit unit)：尝试给对象加锁，成功返回true，可以无参也可以指定等待时间。
  3.unlock()：释放锁，锁只能由持有者释放否则抛出异常。
  4.newCondition()：创建条件对象，使用条件对象管理那些已经获得锁但不满足有效条件的线程，调用await()方法把线程进入等待集，调用sign()/signAll()解除阻塞。5.lockInterruptibly()：如果当前线程未被中断则获取该锁。
  
  ### volatile和synchronized的区别？
  1.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
  2.volatile仅能实现变量的修改可见性，并不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
  3.volatile是一种轻量级的同步机制，在访问volatile修饰的变量时并不会执行加锁操作，线程不会阻塞，使用synchronized加锁会阻塞线程。
  
  ### synchronized和Lock有哪些区别？
  1.synchronized是关键字，是JVM层面的，而Lock是一个接口，是JDK层面的.
  2.synchronized会自动释放锁，而Lock必须手动释放锁。
  3.synchronized是不可中断的，Lock可以中断也可以不中断。
  4.synchronized能锁住方法和代码块，而Lock只能锁住代码块。
  5.Lock可以使用读锁提高多线程读效率。
  
  ### 创建线程池的方法有哪些
  可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。
  1.newFixedThreadPool:
  作用：**创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。**
  
  2.newCachedThreadPool:
  作用：**创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。**
  
  3.newSingleThreadExecutor:
  作用：**创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。**
  
  4.newScheduledThreadPool:
  作用：**创建一个定长线程池，支持定时及周期性任务执行。**
  
  5.newSingleThreadScheduledExecutor
  作用：**创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。**
  
  ### 创建线程池的重要参数
  corePoolSize 线程池核心线程大小
  maximumPoolSize 线程池最大线程数量	
  keepAliveTime 空闲线程存活时间
  unit 空闲线程存活时间单位
  workQueue 工作队列
  threadFactory 线程工厂
  handler 拒绝策略
  
  ### 讲一讲wait、sleep、yield、join方法的区别
  1.wait是Object类的方法，调用wait方法的线程会进入等待(WAITING)状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法释放锁资源。
  2.sleep是Thread类的方法，调用sleep方法导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是计时等待(TIMED-WAITING)状态。
  3.yiled是Thread类的方法，yiled方法使当前线程让出CPU时间片给优先级相同或更高的线程，回到就绪状态(Runnable)与其他线程一起重新竞争CPU时间片。
  4.join是Thread类的方法，join方法使当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就就绪状态(Runnable)。
  
  ### wait，sleep的区别
  - wait, sleep的相同点
  wait和sleep均能使线程处于等待状态
  - 定义上区别
  wait方法定义在Object里面，sleep方法定义在Thread里面。
  - 条件区别
  wait必须在同步环境（synchronized方法）下使用，sleep方法可在任意条件下使用。
  - 功能区别
  wait/notify一起使用，用于线程间的通信，wait用于让线程进入等待状态，notify则唤醒正在等待的线程。
  sleep用于暂停当前线程的执行，它会在一定时间内释放CPU资源给其他线程执行，超过睡眠时间则会正常唤醒。
  - 锁的持有区别
  在同步环境中调用wait方法会释放当前持有的锁
  调用sleep则不会释放锁，一直持有锁（直到睡眠结束）
  
  ### 进程和线程有什么区别
  根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
  资源开销：
  - 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；
  - 线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
  包含关系：
  - 如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线(线程)共同完成的。
  - 线程是进程的一部分，所以线程也被称为轻量级进程。
  内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。
  影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
  
  ### 如何避免线程死锁？
  - 破坏互斥条件：这个条件我们没有办法破坏，因为我们的锁本来就是想让他们互斥的（临界资源需要互斥访问）；
  - 破坏请求与保持条件：一次性申请所有的资源；
  - 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，主动释放占有的资源；
  - 破坏循环等待条件：按某一顺序申请资源，释放资源则反序释放。
  
  ### Java内存模型
  **本身是一种抽象的概念，并不真实存在，它描述的是一种规则，通过规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式**
  
  - 主内存
  主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。
  
  - 工作内存
  主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。
  
  - 主内存与工作内存的操作方式
  在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存。
  
  ### JMM存在的必要性
  由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，用于存储线程私有数据，线程与主内存中主要过程是将变量从主内存拷贝到每个线程各自的工作内存，然后对变量进行操作，操作完成后再将变量写回主内存，**如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。**
  
  **为了解决类似上述的问题，JVM定义了一组规则，通过这组规则来决定一个线程对共享变量的写入，然后何时对另一个线程可见，这组规则也称为Java内存模型（即JMM）** 
  
  ### JMM的三个特征
  #### 原子性
  **原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响**,JMM中提供以下方式来保证原子性:
  - 自带原子性保证：在java中，对基本数据类型的变量的读取和赋值操作是原子性操作。
  - synchronized：synchronized可以防止多个线程并发的执行同一段代码，从结果上保证原子性。
  - Lock锁：Lock锁保证原子性。
  
  #### 可见性
  
  **可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值**,JMM中提供以下方式来保证可见性:
  - volatile：使用volatile关键字修饰一个变量可以保证变量的可见性。
  - synchronized：使用synchronized可以保证共享变量的可见性。
  - Lock锁：使用Lock可以保证共享变量的可见性。
  
  #### 有序性
  **程序执行的顺序按照代码的先后顺序执行**，JMM中提供以下方式来保证有序性:
  - happens-before原则是java内存模型中定义的两项操作之间的偏序关系。
  - synchronized可以保证同一时间只有一个线程访问代码块。
  - volatile可以保证变量不会被编译器重排序。
  
  ### JVM中类加载的过程
  类加载的过程
  加载：类加载器通过通过双亲委托机制把描述类的数据从class文件加载到内存。
  连接：验证，准备，解析。
  初始化：类的初始化顺序
  
  #### 加载
  1.JVM将.class文件读入内存，并为创建一个class对象。
  2.任何类被使用时系统都会为其创建一个且仅有一个class对象。
  3.这个class对象描述了这个类创建出来的对象的所有信息，比如构造方法，成员方法，成员变量等。
  
  #### 链接
  将java类的二进制代码合并到JVM的运行状态之中。
  
  验证:验证class文件的字节流是否符合jvm规。
  
  准备:正式为类变量（static变量）分配内存并设置类变量初始值。
  
  解析:虚拟机常量池内的符号引用替换为直接引用的过程。
  
  #### 初始化
  
  **初始化顺序**
  1、父类的静态变量
  2、父类的静态代码块
  3、子类的静态变量
  4、子类的静态代码块
  5、父类的非静态变量
  6、父类的非静态代码块
  7、父类的构造方法
  8、子类的非静态变量
  9、子类的非静态代码块
  10、子类的构造方法
  
  
  ## Android 
  
  ### 比较熟悉常用的框架，每种优势
  1. View框架
  - ButterKnife
  强大的View绑定和Click事件处理功能,简单代码,提高开发效率。
  - DataBinding+ViewModel+LiveData
  目前比较实用的MVVM架构方式的框架，让事件与数据源完全绑定在一起。
  
  3. 事件框架
  - EventBus
  简化组件间的通信,解耦事件发送和接受。应用于Activity,Fragment之间,后台线程之间的通信,避免使用多个Intent传递,handler通信等
  4. 网络框架
  - OkHttp 
  okhttp是一款基于HTTP和HTTP2.0协议的网络框架，比较流行的框架，其衍生框架Retrofit也是基于okHttp.
  5. 图片框架
  Glide 和 Picasso 可以说是目前 Android 上最流行的图片加载库，区别在于
  - Glide比Picasso加载速度快，但Glide比Picasso需要更大的空间来缓存
  - Glide默认的是Bitmap格式是RGB-555，Picasso默认ARGB_8888格式
  - Glide可以加载Gif动图，Picasso不可以加Gif
  - Glide缓存已改变大小的图片，Picasso缓存全尺寸的图片。
  
  6. 数据库框架
  - Room
  jetpack组件之一,它在SQLite的基础上提供了一个抽象层，允许更强大的数据库访问。
  - MMKV
  MMKV腾讯开发的基于mmap内存映射的Key-value组件，底层序列化/反序列化使用protobuf实现，
  性能高，稳定性强，支持多进程。
  7. 其它
  - tinker
  微信开源的 Android 热修复框架
  - leakcanary
  内存检测框架
  
  ### Android 组件化开发概述
  就是将整个庞大的项目以业务逻辑进行拆分成多个模块，并且各个模块之间相互独立，相互解耦，每一个模块可以单独进行开发调试。
  如果出现一些相同业务，如登陆/注册，我们可以单独把公共业务封装成一个独立模块，供其它App使用。
  
  ### Android 组件化开发结构
  1. App壳，包含application,启动页，初始化操作。
  2. module层，具体业务模块
  3. 公共资源库 所有module的依赖的lib库，
  4. 工具层 网络请求框架，图片框架
  
  ### 常用的设计模式
  1. 适配器模式 
  ListView或GridView的Adapter
  2. 建造者模式：AlertDialog.Builder
  3. 命令模式
  Handler.post后Handler.handleMessage
  4. 观察者模式
  事件通知，广播机制
  5. 代理模式
  bind通信
  6. 单例模式
  懒汉，饿汉，双重锁校验，静态内部类，枚举
  
  ### 多线程的通信方式
  - 简单使用:
  继承thread
  实现runnable
  handle
  - 复合使用:
  Asynctask
  handlethread
  intentservice
  - 高级使用:
  线程池
  
  ### Application中五个公开的方法
  ### Android中什么是Context
  Context字面意思是上下文，在Android中一个Activity就是一个Context,一个Service也是一个Context,Context抽象为**场景**，认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。
  
  在应用程序中Context的具体实现子类就是：Activity，Service，Application
  **Context数量=Activity数量+Service数量+1**。
  
  ### Activity与Fragment生命周期
  Activity 	    Fragment
  onCreate ->	  onAttach->onCreate->onCreateView->onActivityCreated
  onStart -> 	  onStart
  onResumed-> 	onResume
  onPaused ->	  onPause
  onStopped -> 	onStop
  onDestroyed-> onDestroyView->onDestroy->onDetach
  
  ### 两个Activity之间切换
  两个Activity之间切换: Activity A 启动另一个Activity B，回调如下:Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop();如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop
  
  ### 保存与恢复 onSaveInstanceState() onRestoreInstanceState()
  ### Activity 启动模式
  #### standard
  标准模式是系统的默认模式（可以不指定），在这样模式下，每启动一个Activity都会重新创建一个Activity的新实例，并且将其加入任务栈中，而且完全不会去考虑这个实例是否已存在。
  
  #### SingleTop
  分两种情况，需要创建的Activity已经处于栈顶时，此时会直接复用栈顶的Activity.
  需要创建的Activity不处于栈顶，此时会创建一个新的Activity入栈。
  场景：APP接收到多条推送消息，点开不同消息，均由同一Acitivity展示，
  
  #### SingleTask
  若需要创建的Activity已经处于栈中，不会创建新的Activity,而是将之前的其他Activity全部销毁。
  使其成为栈顶。
  场景：淘宝的主界面，在淘宝陆续打开商品搜索界面、商品详细界面、订单界面、付款成功界面后，在付款成功界面一键返回主界面
  
  #### SingleInstance
  只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个activity实例，不允许有别的Activity存在。
  场景:  拨打电话、系统通讯录、系统Launcher、锁屏键、来电显示等系统应用
  
  例如，ActivityA->ActivityB(SingleInstance)->ActivityC 点击Back退出顺序：结果为C-》A-》B
  原因：singleInstance模式是存在于另一个任务栈中的。也就是说ActivityA和ActivityC是处于同一个任务栈中的，ActivityB则是存在另个栈中。
  所以当关闭了ActivityC的时候，先去找当前任务栈存在的activity。当前的activity都finish了之后，才会去找另一个任务栈中的activity。
  解决方法是：在ActivityB定义一个全局变量，在onCreate方法将returnActivityB=true;
  然后在ActivityA界面onStart方法里判断returnActivityB是否为true，是的话就跳转到ActivityB，同时将returnActivityB=false。
  
  ### 广播注册
  - 静态注册就是在AndroidManifest文件中注册广播接收器相关信息(BroadcastReceiver和intent-filter)，然后在应用安装的时候通过PKMS(PackageManagerService)进行解析，来完成注册。
  - 动态注册是把BroadcastReceiver包装成一个Binder对象，然后创建一个包含BroadcastReceiver和IntentFilter的BroadcastFilter对象，最后将BroadcastFilter对象加入到AMS中的mReceiverResolver变量中。
  
  ### 广播使用
  1. 创建广播接收器
  直接继承 BroadcastReceiver 创建子类并实现父类的 onReceive() 方法
  2. 静态广播
  在 AndroidMainfest 文件中定义，intent-filter定义action
  3. 动态广播
  registerReceiver 注册广播
  4. 发送广播
  sendBroadcast 发送广播
  5. 注销广播
  unregisterReceiver 注销广播
  
  ### Task任务栈
  - android任务栈又称为Task，它是一个栈结构，具有后进先出的特性，用于存放Activity
  - android系统通过Task有序地管理每个activity，并决定哪个Activity与用户进行交互,只有task栈顶的activity才可以跟用户进行交互。 
  - 一个App中可能不止一个Task，某些特殊情况下，单独一个Actvity可以独享一个Task。
  - 一个Task中的Actvity可以来自不同的App，同一个App的Activity也可能不在一个Task中。
  
  ### Android横竖瓶切换Activity生命周期 
  ### Android - 系统启动过程
  Step1  Bootloader(系统启动加载器),会读取Boot ROM找到操作系统并将 Kernel(Linux内核) 加载到RAM中。
  
  Step2  当Kernel(Linux内核)启动后会初始化各种软硬环境，加载驱动程序，最后Kernel会调用init.cpp中main()方法，初始化Kernel log ,创建一块共享的内存空间，解析init.rc文件。
  
  Step3  init.rc 脚本中配置了一些重要服务，通过创建子进程来启动这些服务,如Zygote进程启动JVM和systemserver,ServiceManage进程启动binder IPC。
  
  Step4  Zygote进程启动中，会执行App_main.cpp文件中的AndroidRuntime::start()方法创建 Java 虚拟机，然后调用ZygoteInit.main(),fork一个进程用来启动system_server进程，最后Zygote进程会进入loop状态等待下次fork进程。
  
  Step5  system_server进程启动后将初始化系统上下文（设置主题），创建系统服务管理 SystemServiceManager，然后会按顺序启动，引导服务，核心服务，其它服务，最后将服务注册到ServiceManager中。
  
  Step6  当Android的80多种服务都启动完毕之后, 会回调AMS中的systemReady方法启动第一个app，AMS通知Zygote进程fork一个新进程作为Launch App进程(ActivityThread).
  
  Step7  App进程，通过Binder向sytem_server进程发起创建Application请求。当System_server准备好后再通过Binder告诉App进程可以调用onCreate方法启动Lacunch App.
  
  ### Android中实现IPC通信的7种方式
  - Bundle
  android中的四大组件可以通过Bundle所支持的数据类型来进行跨进程通信.
  Bundle支持的数据类型包括基本数据类型、Parcelable、 Serializable
  
  - 文件共享
  文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写的问题。
  适用于无并发访问情况，交换简单数据，无法做到进程间即时通信。
  
  - Messenger
  Messenger是一种轻量级的IPC，它的底层实现是AIDL，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就能轻松地实现数据在进程间的传递，适用于低并发一对多即时通信
  
  - AIDL
  适用于高并发一对多即时通信。
  - ContentProvider
  ContentProvider是android专门为不同应用程序提供数据共享的方式，为进程间通信而生。ContentProvider底层由Binder实现，一旦某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过接口来操作接口内的数据，包括增、删、改、查，适用于一对多的进程间的数据共享。
  
  - Socket方法
  通过网络传输字节流，支持一对多并发实时通信，实现麻烦，适用于网络数据交换场景。
  
  - BroadCase
  广播是一种被动跨进程通讯的方式。当某个程序向系统发送广播时，其他的应用程序只能被动地接收广播数据。
  
  ### 序列化与反序列化的知识
  
  ### AIDL概述
  在Android系统中，每个进程都运行在一块独立的内存中，在其中完成自己的各项活动，与其他进程都分隔开来。可是有时候我们又有应用间进行互动的需求，比较传递数据或者任务委托等，AIDL就是为了满足这种需求而诞生的。
  **通过AIDL，可以在一个进程中获取另一个进程的数据和调用其暴露出来的方法，从而满足进程间通信的需求**。
  
  ### 使用AIDL的步骤 
  服务端：
  
  1. 服务端创建.aidl的文件，也就是双方远程通信的接口方法
  2. 定义跟客服端沟通的数据类，比如序列化parcelable类，基础类
  3. build 生成相应的Java文件
  4. 创建继承Service的自定义服务，并在Manifest.xml中注册
  5. 声明.Stub类型变量（Binder类型），并实现接口方法
  6. 重写onBind方法并返回.Stub类型变量(Binder类型)
  
  客服端：
  1. 将服务端定义好的aidl文件和数据类复制到客服端
  2. 声明ServiceConnection类型变量，并完成bindService
  3. 在onServiceConnected中通过.Stub.asInterface,获取到服务端binder实例。
  4. 调用服务端binder实例，实现与服务端的通信。
  
  ### AIDL的工作原理
  **在客户端与服务端通信的过程中，真正协助发挥作用的是通过AIDL编译出来的.java文件。AIDL文件的目的就是为了生成.java文件，AIDL只是为了简化写.java文件**
  
  ### 客户端与服务端使用AIDL进行 IPC 的工作流程
  Stub类充当服务端角色，持有Binder实体（本地对象）。
  
  - 获取客户端传过来的_data数据流。并调用本地方法处理。
  - 将需要传回客户端的数据写入_reply流，通过Binder发送_reply流到客户端。
  
  Proxy代理类充当客户端角色，持有Binder引用（句柄）。
  
  - 生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。
  - 通过 transact() 方法将_data数据流通过Binder传递到服务端，并通过Binder请求服务端调用指定方法。
  - Binder通过回调，唤醒客户端准备接收从服务端传回来 _reply数据流。
  
  ### AIDL与HIDL 区别
  - AIDL 生成java代码，客户端(client)对应Proxy,服务端(server)对应Stub。HIDL生成c++代码，客户端(client)对应BP(Binder Proxy),服务端(Server)对应BN(Binder Native).
  - AIDL 常用于连接APP和Framework,HIDL则是用来连接Framework和HAL.
  - AIDL 使用Binder通信，HIDL使用HwBinder通信，他们都是通过Binder驱动完成通信，只不过两个Binder域不一样。
  
  #### AIDL中的关键字
  in、out、inout表示跨进程通信中数据的流向（基本数据类型默认是in，非基本数据类型可以使用其它数据流向out、inout）。
  
  in 表示数据只能由客户端流向服务端。（表现为服务端修改此参数，不会影响客户端的对象）
  
  out 表示数据只能由服务端流向客户端。（表现为服务端收到的参数是空对象，并且服务端修改对象后客户端会同步变动）
  
  inout 则表示数据可在服务端与客户端之间双向流通。（表现为服务端能接收到客户端传来的完整对象，并且服务端修改对象后客户端会同步变动）
  
  oneway 关键字用于修改远程调用的行为,远程调用不会阻塞,发送事务数据并立即返回回,本地调用不起作用，调用依旧是同步的，主要有两个特性：异步调用和串行化处理。
  
  - 异步调用是指应用向 binder 驱动发送数据后不需要挂起线程等待 binder 驱动的回复，而是直接结束。
  - 串行处理是指对于一个服务端的 AIDL 接口，所有的 oneway方法不会同时执行,binder驱动会将他们串行化处理，排队一个一个调用。
  
  ### Binder概述
  Binder是跨进程通信(IPC)的桥梁
  - 从性能上:
  共享内存方式虽然无需数据拷贝，但控制复杂。
  Socket方式需要2次数据拷贝，传输效率低，开销大
  Binder,需要1次数据拷贝，性能上仅次于共享内存
  - 从稳定性上：
  Binder采用C/S架构，架构比较清晰，控制简单。
  共享内存方式虽然无需拷贝数据，控制比较复杂，难以使用。
  - 从安全性上：
  传统的IPC要发送类似的UID也只能放在数据包里，但也容易被拦截，恶意进攻，
  socket则需要暴露自己的ip和端口，这些恶意程序则可以进行任意接入。
  Binder 为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志，因此安全性较高。
  
  ### 进程隔离的概念
  - 操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据.
  - 但是内核空间却是可共享的。Client进程向Server进程通信恰恰是利用内核空间来完成底层通信工作的。
  
  ### Binder驱动概念
  Android通过LKM（动态内核可加载模块）添加一个内核模块运行在内核空间，使得进程间通过这个模块作为桥梁，就可以完成通信了。
  Android 系统中，这个运行在内核空间的，负责进程间通信的内核模块叫做 Binder 驱动;
  
  ### 一次Binder IPC通信过程
  
  Step1: 首先服务端先向ServiceManager注册服务，
  Step2: 然后ServiceManager,向Kernel(内核)中Binder驱动的全局链表中插入服务端的信息
  Step3: 同时向已注册服务列表中缓存一下注册的服务。
  Step4: 客户端通过ServiceManager向已注册服务列表中查询服务端的代理。
  Step5: 客户端利用获取到的服务端代理，即BinderProxy，将请求发送给ServiceManager.
  Step6: ServiceManager使用内核方法copy_from_user()将参数拷贝到内核空间。
  Step7: 这时候客户端进入等待状态。
  Step8: 然后 Binder 驱动向全局链表队列里面插入一条事务.
  Step9: 执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间
  Step10: 最后唤醒等待的客户端并把结果响应给客户端。
  
  ### Handler 作用
  
  Handler消息机制用于同进程的线程间通信
  可以说只要有异步线程与主线程通信的地方就一定会有 Handler
  
  ### Handler,MessageQueue与Looper关系
  1. Message:
  Handler接收和处理消息的对象。
  
  2. Looper:
  每个线程只能有一个Looper。loop负责读取MessageQueue中的消息，读到消息后把消息发送给Handler进行处理。
  
  3. MessageQueue:
  消息队列，它采用先进先出的方式来管理Message。程序创建Looper对象时，会在它的构造方法中创建MessageQueue对象。
  
  4. Handler:
  Handler作用有两个，1.发送消息到MessageQueue, 2.处理Looper从MessageQueue中获取的消息
  ### Handler工作流程
  - Handler初始化：
  1. 在主线程启动时会自动创建Looper，Looper创建时会同时创建MessageQueue消息队列，创建Looper、MessageQueue完成后，Looper会自动进入消息循环；
  2. 在主线程里手动创建Handler对象，此时Handler对象会自动绑定主线程里的Looper、MessageQueue对象。
  3. 非主线程创建Handler对象，首先创建Looper对象，其次调用Looper.prepare()启用Looper，最后再调用Looper.loop()让looper开始循环。
  - 消息发送:
  工作线程通过sendMessage或post发送消息到MessageQueue消息队列中。
  - 消息循环:
  Looper循环取出MessageQueue中的消息
  - 消息分发:
  从loop中获取的消息，根据target属性，获取到对应的handler对象。
  - 消息处理:
  通过dispatchMessage方法。将消息抛到主线程的handleMessage方法中。
  
  ### OOM内存泄漏 案列分析
  内存泄漏原因：堆上分配的对象已经不会再使用，但此对象有引用，导致GC无法对其回收。
  
  #### 非静态内部类导致内存泄露（Handler泄漏） 发生原因
  当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会**隐式**地持有一个外部类对象（通常是一个Activity）的引用，而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕之后，通过消息机制通知Handler，然后Handler把图片更新到UI界面。然而，如果用户在网络请求过程中关闭了Activity，GC在检查时，由于这时线程尚未执行完，而该线程持有Handler的引用，Handler又持有Activity的引用，就导致该Activity无法被回收，导致内存泄漏。
  #### 非静态内部类导致内存泄露（Handler泄漏） 解决方法
  解决方案：
  1. 通过程序逻辑来进行保护。
  在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 
  如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。
  
  2. 将Handler声明为静态类+WeakReference
  在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。
  静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。
  
  WeakReference：弱引用的对象拥有短暂的生命周期。在垃圾回收器线程扫描时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
  
  #### 单例导致内存泄露 发生原因
  单例的静态特性使得它的生命周期同应用程序的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。
  
  #### 单例导致内存泄露 解决方法
  为了避免这样单例导致内存泄露，可以将context参数改为全局的上下文。
  
  #### Adapter 持有 Activity的对象导致内存泄漏发生原因
  如果建立一个专门存放Adapter类的Package包,首先在初始adapter的时候会传入context,这时adapter就持有了Activity引用，如果我们在adapter中进行耗时操作（比如加载图片之类的），并且finish Activity，虽然此时Activity销毁了，但是GC是无法回收activity的，这样就发生了内存泄漏。
  
  #### Adapter 持有 Activity的对象导致内存泄漏解决方法
  将Adapter写成静态内部类写在Activity里面。
  
  #### 资源未关闭导致的内存泄漏
  在Activity销毁的时候要及时关闭或者注销。
  1. BraodcastReceiver：调用unregisterReceiver()注销；
  2. Cursor，Stream、File：调用close()关闭；
  3. Bitmap：调用recycle()释放内存（2.3版本后无需手动）。
  
  ### 内存泄漏和内存溢出的区别
  内存泄漏和内存溢出是两码事。
  内存溢出：是由于应用所消耗的内存或者应用申请的内存超出了虚拟机分配的内存，也就是内存不够用了
  内存泄漏：是某个不再使用对象由于被其他实例引用，导致不能被GC回收，从而导致的内存不能释放。
  
  内存泄漏可能会引起内存溢出，因为如果内存泄漏严重，导致存在大量GC不能 回收的对象占用内存，内存占用会越来越高，导致其他对象不能被分配到内存，从而导致内存溢出。
  
  ### 发生ANR的具体表现
  Android系统中，ActivityManagerService(简称AMS)和WindowManagerService(简称WMS)会检测App的响应时间，如果App在特定时间无法相应屏幕触摸或键盘输入事件，或在主线程(UI线程)里面做了太多的阻塞耗时操作,系统会向用户显示一个对话框，这个对话框称作“应用程序无响应”（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。
  
  ### 导致ANR的场景
  - InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件
  - BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒。
  - Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。
  - ContentProvider Timeout ：ContentProvider执行超时20秒。
  
  ### ANR日志分析
  针对Android10以下机器，通过ADB将记录ANR的log,traces.txt文档导出，可以查看ANR的原因，进程id，包名，以及具体行数
  ```
  $adb pull data/anr/traces.txt .
  ```
  针对Android 10以上机器，通过adb提供bugreport命令获取压缩包，其中包含anr和tombstones两种文件。
  
  - CPU负载
  主要关注iowait关键字，若iowait占比很高，意为有很大可能是io耗时导致ANR。
  
  - 内存信息
  若Free memory until OOME的值很小，说明处于内存紧张状态，ANR可能由于应用占用过多内存。
  若ANR时间点前后，在LogCat日志中含有onTrimMemory，说明已经处于内存紧张状态。
  
  - 堆栈消息
  main线程处于BLOCK,WAITING,TIMEWAITING状态，可以确定函数阻塞导致ANR.;
  
  ### ANR其它分析方式
  - 通过DDMS Update Thread工具查看
  通过DDMS Update Threads工具查看该进程下的所有线程状态。通过线程状态分析哪个线程阻塞导致的ANR。
  - Traceview
  Traceview是分析工具，用于定位应用代码中的耗时操作。
  
  ### ANR的处理
  1. 开辟单独的子线程来处理耗时阻塞事务，通过继承Thread或实现Runnable接口。
  2. 使用AsyncTask,异步执行事务。继承AsyncTask,在doInBackground中实现耗时操作，然后在onProgressUpdate或onPostExecute回调方法中实现接收结果，最后通过执行execute执行AsyncTask。
  3. 使用Handler,HandlerThread来对UI进行更新。
  4. Activity的onCreate和onResume方法中尽量避免耗时操作。
  5. BoadcastReceiver中onReceive方法中尽量避免耗时操作。
  
  ### dimen 基于dp的适配（smallestWidth适配）
  最小宽度限定符适配。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别结果去寻找对应限定符文件夹下的资源文件。
  
  某手机的屏幕分辨率是 1080 * 1920，屏幕像素密度是 480 dpi，通过计算，
  
  它的最小尺寸的dp值是：1080 / (480 / 160) = 360 dp,根据这个 360 dp 值，系统会去寻找 value-sw360dp 的文件夹以及对应的资源文件并使用它。
  
  如果没有 value-sw360dp 文件夹，系统会向下寻找，比如离 360 dp 最近的只有 value-sw350dp，那么Android就会选择 value-sw350dp 文件夹下面的资源文件。
  
  如下面我这里将会以 360 dp 作为基准.
  
  ### 自定义View的分类
  1. 继承View或者ViewGroup类
  重写onDraw方法，调用invalidate方法重新绘制View
  2. 自定义组合控件
  几种控件组合起来形成一个新的控件，这个新的组合控件就会整合了原来每一个控件的功能
  3. 自定义扩展控件
  也就是继承现有的控件，在该控件的基础之上添加新的功能，如继承Button,tablayout
  
  ### 自定义View的主要方法
  - 构造方法
  一般要写三个甚至四个，这样写的原因，在不同的情况下创建View的方式不同
  1. 如果该控件仅在代码中实例化，那么可以直接复写只有一个参数的构造方法。
  2. 如果控件要应用在布局文件，那么必须要复写只有两个参数的构造方法。
  3. View需要随着主题而改变属性值，那么就必须复写下三个参数和四个参数的构造方法
  
  - onMeasure 用于测量子控件的宽高
  measureSpec: 在很大程度上决定了一个View的尺寸规格，其模式有三种模式。
  exactly(精确模式):父View已经替子View确定了大小，不管子View要多大都不行。(match_parent)
  at_most(最大模式):子View要多大就多大，但是不能超过上限。(wrap_content)
  unspecified(未指定模式):父View对子View没有任何限制，子View的宽高想多大就多大。
  - onSizeChanged 确定View大小
  - onLayout 用于摆放子控件在父控件中的位置
  getMeasureWidth方法: 在measure过程结束后就可以获取到了。
  getWidth方法:要在layout过程结束后才能获取到。
  在ViewGroup中重写onLayout的目的:设置当前View与其所有的子View,在ViewGroup父布局当中的位置。
  - onDraw 用于绘制需要的图形
  绘制：主要通过canvas(画布),paint(画笔),matrix(变换矩阵)去绘制
  - invalidate 触发重新绘制，只能在主线程调用。
  - postInvalidate 直接调用去在子线程更新UI。
  - onAttachedToWindow 当View附加到窗体的时候调用该方法。
  - onDetachedFromWindow 当销毁View的时候调用该方法。
  - onFinishInflate 是当所有的孩子都解析完后的一个调用。
  - requestLayout 会触发measure过程和layout过程。
  
  注意：onMeasure和onLayout最后都要调用requestLayout才能让改变生效，onDraw要调用invalidate才能让在主线程生效。
  postinvalidate在子线程调用才能生效。
  
  自定义View流程
  | 步骤   | 关键字           | 作用                           |
  | ---- | ------------- | ---------------------------- |
  | 1    | 构造函数          | View初始化                      |
  | 2    | onMeasure     | 测量View大小                     |
  | 3    | onSizeChanged | 确定View大小                     |
  | 4    | onLayout      | 确定子View布局(自定义View包含子View时有用) |
  | 5    | onDraw        | 实际绘制内容                       |
  | 6    | 提供接口          | 控制View或监听View某些状态。           |
  
  ### Android 一共有多少种动画
  - 视图动画(View动画)
  可以在一个视图容器里执行一系列简单变换(位置，大小，旋转，透明度)
  1. View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。
  2. View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。
  3. View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。
  - 帧动画(Drawable动画)
  每一帧代表一个画面动作，当速度到达人眼无法分辨每一帧时，就达到了动画的效果。一般用在设备开关机动画
  - 属性动画
  1. 属性动画作用对象不局限在 View 上，而是通过 Getter 和 Setter 方法作用在对象属性上。
  2. 属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。
  3. 属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。
  
  - 触摸反馈动画
  就是一种点击效果，点击View时，点击事件会有涟漪般的反馈效果.
  - 揭露动画
  揭露动画在系统中很常见，就是类似波纹的效果,从某一个点向四周展开或者从四周向某一点聚合起来。
  - 转场动画
  转场效果我们一般用在 Activity 切换时的动画效果上
  - 视图状态动画
  View 在状态改变时执行的动画效果,如通过selector选择器给Button设置不同状态的背景效果一样。
  - 矢量图动画
  矢量图也称为面向对象的图像或绘图图像，是根据几何特性来绘制的图形，首先导入svg格式的图片生成矢量图的代码，其次根据path属性对数据进行绘制。最后通过连续改变path的值产生动画效果。
  
  - 约束布局实现的关键帧动画
  通过 ConstraintLayout 实现的一种关键帧动画
  
  ### MVC,MVP,MVVM的区别
  1. MVC 
  Model（模型）表示应用程序核心(如数据库),是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。
  View（视图）显示效果（HTML页面）。应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
  Controller（控制器）处理输入（业务逻辑）。是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。
  优点：
  - 耦合性低,重用性高,部署快
  缺点：
  - 不适合小型，中等规模的应用程序,增加系统结构和实现的复杂性,视图对模型数据的低效率访问
  
  2. MVP
  Model（模型）表示应用程序核心(如数据库)
  View（视图）显示效果（HTML页面）
  Presenter 处理输入（业务逻辑）
  优点：
  - 模型与视图完全分离，我们可以修改视图而不影响模型
  - 可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑
  缺点：
  - 视图的渲染放在了Presenter中，视图和Presenter的交互会过于频繁耦合性增加。
  
  MVP 是从经典的模式MVC演变而来，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。
  
  3. MVVM 
  MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让视图UI和业务逻辑分开。具体表现为ViewModel可以取出 Model 的数据同时处理View中需要展示内容。
  
  ### MVVM核心构成
  DataBinding:数据和UI双向绑定
  LifeCycle:界面生命周期感知
  ViewModel:业务逻辑
  LiveData:可观察数据项
  
  ### JNI概述
  JNI（Java Native Interface，Java本地接口），用于打通Java层与Native(C/C++)层。这不是Android系统所独有的，而是Java所有。众所周知，Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C/C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。
  
  ### 动态库的加载loadLibrary
  1. System.loadLibrary和System.load都用于加载动态库，loadLibrary可以自动加载依赖库，load可以指定具体路径的动态库。
  2. 无论哪种方式加载最终都会调用到LoadNativeLibrary方法。
  - 通过dlopen打开动态库
  - 通过dlsym获取动态库中JNI_ONLoad函数指针。
  - 调用JNI_Onload方法，开始注册JNI方法
  
  ### 静态注册与动态注册
  JVM查找Native方法有两种方式：
  1、当加载动态库到Jvm后,Native方法第一次执行时根据其方法名去匹配对应C语言实现命名规则，这种方式叫静态注册。
  2、通过JNI_OnLoad调用JNI提供的registerNativeMethods方法函数，将JNINativeMethod结构体中本地函数注册到JVM中，这种方式叫动态注册。
  
  ### JavaVM和JNIEnv
  JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例
  JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例，
  
  ### JNI加载过程
  1. 通过loadLibrary 调用相应库中的JNI_OnLoad()方法。
  2. 在JNI_OnLoad方法中，获取JNINativeMethod结构体中定义的Java函数。
  3. 通过registerNativeMethods方法，将JNINativeMethod结构体中定义的Java函数，注册到JVM中。
  
  ### 稳定——内存优化
  Android中的内存优化总的来说就是开源和节流，开源就是扩大内存，节流就是避免内存泄漏。
  
  #### 扩大内存方式
  1. 清单文件中的Application下添加largeHeap="true"这个属性,让应用能申请使用更多的内存.
  2. 同一个应用下开启多个进程，如,启动一个Service在另个进程，通过AIDL与客户端通信.
  
  #### 内存泄漏检测方式
  
  #### Android Profiler工具
  Android Profiler分为三大模块： cpu、内存 、网络。其中Memory Profiler 是Android Profiler中的一个组件，它可以帮助您识别内存泄漏和内存溢出。
  
  #### LeakCanary + MAT 工具
  LeakCanary专为Android设计的内存泄露检测库，首先将依赖引入项目中。其次运行APP，在遇到内存泄漏后，LeakCanary会有弹框提示，并会将堆内存dump成hprof文件。
  然后将hprof文件导入MAT工具中进行分析。
  
  #### Android Lint工具
  Android Lint是一个静态代码分析工具，它能够检测Android项目中的内存泄漏，还会检测代码是否规范、是否有没用到的导包、可能的bug、安全问题等等。
  
  它有个Lint Tool工具，它会把Android源代码和lint.xml配置文件打包成一个文件之后，输出成lint output，并展现出具体在哪行代码有问题。
  
  ### 流畅——卡顿优化
  UI问题的最大体现则是屏幕卡顿现象。造成卡顿的主要原因有以下两点：
  
  界面绘制：主要原因是界面布局层级深、布局复杂、过度绘制，由于这些原因导致卡顿场景更多出现在UI和启动后的初始界面以及页面绘制上。
  
  数据处理：一般分为三种情况，一是在UI线程中处理数据，二是数据处理占用 CPU 高，导致主线程阻塞，三是内存增加导致GC频繁，从而引起卡顿。
  
  ### 卡顿问题定位工具
  - dumpsys gfxinfo 
  记录动画帧相关性能信息，其帧信息可以对卡顿问题进行分类
  
  - BlockCanary 
  检测主线程上的各种卡顿问题
  
  - Layout Inspector
  Layout Inspector是Android studio自带的视图层次结构分析工具，通过Layout Inspector分析布局的层级结构，减少不必要的层级，避免过度绘制, 达到渲染优化的效果。
  
  - Android Lint工具
  将布局相关的扫描规则勾选上，然后根据Lint给出的结果，针对性的做出一些布局优化处理，达到渲染优化的效果。
  
  - GPU 渲染模式分析工具
  该工具在手机开发者选项中，通过设置打开开发人员选项，选择 GPU渲染模式分析，打开要分析的应用。
  最终结果通过，滚动直方图的形式显示渲染界面窗口帧所花费的时间，若一直超过红线，整个页面就会很卡，那么就需要针对性的做一些优化处理。
  
  - 过渡绘制检测功能
  该功能也同样在开发者选项中，通过设置打开开发人员选项，选择调试 GPU 过度绘制，打开要分析的应用。
  最终结果通过对界面进行彩色编码来告诉我们哪些属于过度绘制，尤其注意红色表示过度绘制4次或者更多。
  
  ### 界面绘制优化
  - 通过减少冗余或者嵌套布局来降低视图层次结构。比如使用约束布局代替线性布局和相对布局。
  - 用 ViewStub 替代在启动过程中不需要显示的 UI 控件。
  - 使用自定义 View 替代复杂的 View 叠加。
  - 减少嵌套层次和控件个数。
  - 减少过度绘制
  
  **ViewStub 是布局优化的方式之一，适用于一些延迟加载的场景，ViewStub本身是一个不可见不占用位置的 View，资源消耗比较小，只有调用了ViewStub.inflate()的时候加载布局，布局才会实例化。**
  
  ### 数据处理优化
  - 主线程中不要直接操作数据库，数据库的操作应该放在子线程中完成。
  - sharepreference 尽量使用 apply，少使用 commit，可以使用 MMKV 框架来代替 sharepreference。
  - 网络请求回来的数据解析尽量放在子线程中。
  - 不要在 activity 的 onResume 和 onCreate 中进行耗时操作。
  
  sharepreference 两种提交方式是commit和apply，区别在于：
  1.commit 返回boolean类型的值，提示是否提交成功，而apply没有返回值；
  2.commit 直接写入磁盘，apply先写入内存，然后异步写入磁盘；
  
  commit是同步提交，返回值告诉我们是否提交成功；apply是异步提交，效率高，无法确定是否提交成功。
  
  ### 安装包——APK瘦身
  从用户层面来说，面对动辄几十兆的APP来说在非WIFI情况下还是会犹豫要不要下载，不下载你就可能因此失去了一个用户。
  从公司层面来讲，流量就是钱，减少APP的大小就显得尤为重要
  
  #### 减少安装包大小
  - 去除无用资源，使用shrinkResources来删除库文件中无用的资源，配合proguard压缩代码资源。
  - 减少第三库的使用，宁愿参照去实现，也不要多引入一个第三方库。
  - 避免使用枚举，一个单独的枚举可以将apk增加1.0 到1.4 KB大小，累积下来可能会增加相当大的APK体积。
  - 使用WebP文件格式，WebP格式提供有损压缩以及透明度，可以提供比JPEG或PNG更好的压缩效果。
  - 精简drawable，只保留一套drawable图片资源，使用多个dimens.xml文件来适配不同的手机尺寸。
  - lib中资源优化，so库尽量兼容v7或V8。
  ### 启动优化 
  
  用户希望应用能够快速打开。启动时间过长的应用可能会令用户失望，最后用户直接卸载应用。
  #### 启动方式
  - 冷启动
  应用从头开始(Zygote>fork>app),
  在冷启动开始时，系统有三个任务，1.加载并启动应用，2.在启动后立即显示应用的空白启动窗口，3.创建应用进程。
  创建了应用程序进程后，应用程序进程就负责接下来的阶段：1.创建应用的实体。2.启动主线程。3.创建主页面。4.绘制页面上的View。5.布局页面。6.执行首次的绘制。
  
  - 温启动
  介于冷启动和热启动中间，应用进程还在，但activity已经从栈中退出销毁，再次启动应用需要通过onCreate（）重新创建 Activity。
  比如按Home键后，又继续使用其他APP，时间久了或者打开的应用多了，之前应用的Activity有可能被回收了，但是进程还在。
  - 热启动
  热启动时，系统将应用从后台拉回前台，应用程序的 Activity 在内存中没有被销毁，那么应用程序可以避免重复对象初始化，UI的布局和渲染。
  
  #### 启动时间测量
  测量启动时间的目的有两个：
  1. 找到需要优化的点，即哪里耗时严重
  2. 启动优化效果验证，是否达到预期时间
  
  #### 时间测量方式
  - 系统日志输出
  在Android 4.4及以上版本，App启动时会在logcat输出一行日志，会打印出名为Displayed的值，此值代表从进程启动到屏幕上完成对应Activity绘制所经过的时间。
  - adb am start 命令启动APP
  
  操作 launch启动App
  操作 点home键推到后台，再运行adb命令：
  操作 点back键推到后台，再运行adb命令：
  
  #### 优化方式
  - Application.onCreate()
  onCreate主要是做SDK初始化和App状态判断，
  
  sdk优化:
  sdk的懒加载，再使用到的时候才去初始化，不全部放到在Application初始化。
  sdk放到子线程中初始化.
  
  业务代码的优化：
  尽量不要在OnCreate中初始化ContentProvider,因为其是在Application.attachBaseContext就会初始化其ContentProvider.onCreate()方法，会加长Application启动时间。
  尽量不要在OnCreate中初始化SharedPreferences,如果涉及IO操作，Applicaion阻塞时间会较长。
  
  - Activity.onCreate()
  需要根据具体情况优化，常见优化有：
  1. setContentVIew()耗时，这时要优化布局，减少布局背景的重复渲染、减少层级、对于不一定显示的布局用ViewStub加载。
  2. initView()初始化View时不要做耗时操作，比如一些IO操作、播放器等采用懒加载，也可以通过多线程提前加载。
  3. 主页面的ViewPager+Fragment可以通过懒加载按需加载Fragment。
  
  ### 崩溃与ANR的区别
  崩溃:崩溃是指在应用内引发了未处理的异常,如Nullpointer异常，非法状态异常等，Android中的崩溃分为两种，Java崩溃和Native崩溃。
  ANR:ANR表示应用程序无响应,如应用程序是否在UI线程上阻塞，导致系统无法处理用户输入事件。
  
  **崩溃不同于ANR，ANR不会在所有情况下都崩溃。**
  
  ### Java 崩溃处理
  1. 自定义异常捕获类，实现UncaughtExceptionHandler接口，实现uncaughtException方法。
  2. 将捕获的异常交给自己处理，或者交给系统自己处理。
  3. 自己处理给将日志保存，或将日志上传
  
  ### Navite 崩溃处理
  当程序中的 native 代码发生崩溃时，系统会在 /data/tombstones/ 目录下保存一份详细的崩溃日志信息
  发生崩溃的具体方法和行数可以用 Android/SDK/NDK 提供的工具 linux-android-addr2line 来进一步定位。
  
  ### Window PhoneWindow DecorView 的关系
  Window是一个抽象类，是所有视图的最顶层容器
  PhoneWindow 作为 Window 的唯一实现类
  DecorView 是 PhoneWindow 的一个内部类，PhoneWindow 将信息通过 DecorView 传递给下面的 View，而下面 View 的信息也通过 DecorView 回传给 PhoneWindow。
  
  ### 事件分发，拦截，消费
  dispatchTouchEvent
  onInterceptTouchEvent
  onTouchEvent
  
  ### View 事件相关的各个方法调用顺序
  onTouchListener > onTouchEvent > onLongClickListener > onClickListener
  
  ### ViewGroup 中子View重叠时如何分配
  当 ChildView 重叠时，**一般会分配给显示在最上面的 ChildView**。  
  如何判断哪个是显示在最上面的呢？后面加载的一般会覆盖掉之前的，所以**显示在最上面的是最后加载的**。
  1. 只有 View1 可点击时，事件将会分配给 View1，即使被 View2 遮挡，这一部分仍是 View1 的可点击区域。
  2. 只有 View2 可点击时，事件将会分配给 View2。
  3. View1 和 View2 均可点击时，事件会分配给后加载的 View2，View2 将事件消费掉，View1接收不到事件。
  
  ### OKHttp
  
  okHttp用到的有build模式，责任链模式，其核心是通过拦截器形成责任链，每个拦截器负责相应的功能，发送的请求通过拦截器由上到下依次执行，响应的数据依次从下往上。而底层连接方式是通过socket进行通信。
   
  重试与重定向拦截器
  桥拦截器
  缓存拦截器
  连接拦截器
  服务器请求拦截器
  
  ## Android Framework
  ### 什么是ActivityManagerService
  ActivityManagerService承担了Android四大组件的启动、切换、调度以及进程的管理工作，是Android中最核心的服务。
  
  ### AMS关联类
  1. AMS由ActivityManagerNative（以后简称AMN）类派生，而AMN由Binder派生，实现了IActivityManager接口。
  2. AMP是AMN的内部类，它们都实现了IActivityManager接口，这样它们就可以实现代理模式。具体来讲是远程代理。
  3. AMP和AMN是运行在两个进程中的，AMP是Client端，AMN则是Server端，而Server端中具体的功能都是由AMN的子类AMS来实现的，因此，AMP就是AMS在Client端的代理类。
  4. AMP和AMS可以通过Binder来进行进程间通信。
  5. 客户端使用ActivityManager类。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。
  
  ### AMS启动过程
  AMS的启动是在SystemServer进程中启动的。即AMS运行在SystemServer进程。
  在SystemServer中需要启动的服务有三种：
  - 引导服务(BootstrapServices),主要开启了ActivityManagerService、PowerManagerService、PackageManagerService等服
  - 核心服务(CoreServices),主要开启了DropBoxManagerService、BatteryService、UsageStatsService和WebViewUpdateService等服务
  - 其他服务(OtherServices),主要启动了CameraService、AlarmManagerService、VrManagerService等服务。
  
  ### zygote，SystemServer，AMS，ActivityThread 的关系
  1. App(ActivityThread进程)和AMS(SystemServer进程)还有zygote进程属于三个独立的进程。
  2. App与AMS通过Binder进行IPC通信，AMS与zygote通过Socket进行IPC通信。
  3. AMS负责所有Activity的生命周期，若想打开一个App的话，需要AMS和ActivityThread相互配合来完成。
  
  ### Activity 启动流程
  一. Launcher通过ActivityManagerProxy,用Binder进程间通信，通知ActivityManagerService,它要启动一个Activity。(1~11)
  
  二. ActivityManagerService调用startActivity,并经过ActivityStack一系列调用处理后，通过Binder通信,通知Launcher让其它Activity进入Paused状态。(12~16)
  
  三. Launcher再通过ActivityManagerProxy,用Binder通信,通知ActivityManagerService，它已经准备进入Paused状态，于是ActivityManagerService就向zygote发送命令用来fork一个子进程，用来启动一个ActivityThread实例，即将要启动的Activity在这个ActivityThread实例中运行。(17~24)
  
  四. ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService,以便ActivityManagerService能够通过这个Binder对象与ActivityThread通信。(25~27)
  
  五. ActivityManagerService通过Binder进程间通信，通知ActivityThread，现在一切准备就绪，可以执行onCreate方法启动Activity了。(28~35)
  
  ### Zygote fork一个Launcher进程的阶段
  1. AMS属于SystemServer进程，AMS通过StartProgressLock向zygote发送一个socket。
  2. 这时Zygote无限循环状态，一直在等待Socket请求，收到发来新的Socket请求后，执行processOneCommend方法开始fork一个新进程。
  3. fork过程中，首先停止Zygote的4个Daemon子进程，等待所有子线程结束，通过JNI开始堆的初始化工作。最终JNI调用系统的fork函数，孵化一个新进程。
  4. fork成功后，设置selinux上下文，设置子进程的signal信号，设置新进程的主线程id等一系列初始化工作，启动Zygote的4个Daemon子进程。
  7. 执行handleChildProc进入子进程处理，执行ZygoteInit方法，初始化运行环境，启动Binder线程池.
  8. 执行applicationInit方法，通过反射获取ActivityThread的main方法，并调用main方法启动ActivityThread.
  
  ### ActivityThread 初始化
  1. ActivityThread的main方法中，初始化Looper主线程，创建ActivityThread对象，调用attach处理，进入Loop循环。
  2. attach方法中,将ApplicationThread对象绑定到ActivityManagerService，用于ActivityThread与ActivityManagerService通信。
  3. 执行attachApplicationLocked方法，首先创建Application，并启动Application.onCreate方法。
  4. 执行performLaunchActivity方法，通过Instrumentation创建Activity实例，回调 attach方法，设置context,title,样式等，最终执行onCreate方法。
  
  ### startService启动过程
  1. Activity中的startService实际由ContextImpI中startService开始发起,利用Binder通信，通过AMP向AMS发起startService请求。
  2. AMS收到请求后，经由ActiveService一系列的处理后，向zygote发送请求fork出子进程ActivityThread。
  3. ActivityThread 利用Binder通信，向AMS发送attachApplication请求。
  4. AMS利用Binder通信，向ActivityThread调用scheduleCreateService请求。
  5. ActivityThread收到请求后，通过handler向主线程发送CREATE_SERVICE消息，创建ContextImpl对象，创建Application对象，并回调Service.onCreate()方法
  
  ### 注册广播流程
  - Activity/Service中调用registerReceiver()方法，最终调用ContextImpl的registerReceiverInternal方法。
  - registerReceiverInternal调用LoadedApk的方法，将广播接收者封装成一个实现了IIntentReceiver接口的Binder对象,即ReceiverDispatcher。
  - 获取AMP代理类对象，通过Binder通信，调用AMS的registerReceiverWithFeature方法将ReceiverDispatcher，传递给ActivityManagerService，用于广播的跨进程通信。
  - registerReceiverWithFeature方法中，将用来描述注册的广播接收者BroadcastFilter 添加到mReceiverResolver中。
  - 当AMS接收到广播时就可以从mReceiverResolver中找到对应的广播接收者了。
  
  ### 广播发送和处理
  1. 广播发送者，Activity或Service，将一个特定类型的广播发送给AMS
  2. AMS接收到一个广播后，首先找到与这个广播对应的广播接收者，其次将它们添加到一个广播调度队列中.最后AMS向所在线程消息队列发送一个BROADCAST_INTENT_MSG消息。
  3. 至此对广播发送者来说，一个广播就发送完了。
  4. 在AMS运行的线程消息队列处理发送的BROADCAST_INTENT_MSG消息时，AMS会从广播调度队列中找到广播接受者。并将广播发送给对应的应用进程。
  5. 当应用程序收到AMS的广播后，首先将广播封装成一个消息，然后发送到主线程消息队列中。当消息被处理时，应用程序才会将被封装的广播发送到广播接受者处理。
  
  ### ANR时系统的处理过程
  - 当 ANR 发生时，系统会调用appNotResponding方法。
  - 将ANR相关信息通过拼接字符串的形式，记录到EventLog中。
  - 获取重要进程（Java进程,Native进程）的trace信息，保存到/data/anr/traces.txt
  - 将ANR reason和CPU使用情况，输出到MainLog
  - 将traces文件和CPU使用情况信息，保存到/data/system/dropbox
  - 如果是后台ANR，直接杀进程,否则弹框告知用户。
  
  ### System Service创建流程
  1. ZygoteInit方法中通过fork，创建SystemService进程。完成后调用handleSystemServerProcess进入子进程，完成system_server进程剩余的工作。
  2. 关闭父进程zygote复制而来的Socket，设置当前进程名为"system_server"，启动新binder线程等一系列初始化操作。
  3. 通过反射获取systemserver的main方法，并执行main方法启动System Service。
  
  ### System Service启动流程
  1. 首先初始化SystemService对象，调用其run方法。
  2. run方法中，启动主线程Looper,加载android_servers.so库，初始化系统上下文，创建系统服务管理者SystemServiceManager.启动引导服务，启动核心服务，启动其他服务。
  3. Looper.loop一直循环。等待所有服务器启动完成后，执行AMS.systemReady()回调方法，开始启动第一个App.
  
  ### UI面是怎么显示到屏幕上的？
  Android视图显示的流程是先通过CPU把UI组件计算成多维图形和纹理坐标，然后通过OPenGL调用GPU进行栅格化，并最终渲染到屏幕上。
  进行以上对AndroidUI的绘制都需要在Surface画布上进行。
  
  ### 什么是Surface
  Surface的本质**是一块或几块GraphicBuffer内存的管理类，并提供对buffer的管理方法**,每个Window都有一个Surface。
  GraphicBuffer由SurfaceFlinger来进行分配。App从SurfaceFlinger中获取一块GraphicBuffer后，通过OpenGL将图形数据绘制到GraphicBuffer上。
  然后SurfaceFlinger会把多个GraphicBuffer数据进行合成，最终OpenGL将合成后的数据通过调用FramebufferNativeWindow类渲染到实际屏幕上去。
  
  android中Surface分为两种：1.Java层surface 2.Native层Surface
  Java层产生Surface的主要有两个地方：ViewRoot和SurfaceView。
  Native层主要由NativeWindow产生。
  
  ### SurfaceFlinger 概述
  SurfaceFinger位于Native层，是一个Binder系统服务, Android设备开机启动时就会带起SurfaceFlinger服务进程并完成一些初始化动作。
  
  ### SurfaceFlinger 的启动
  1. 开机启动时，init进程解析这个surfaceflinger.rc文件
  2. 在main_surfaceflinger.cpp文件中通过main函数首先调用createSurfaceFlinger()以及SurfaceFlinger构造函数，创建SurfaceFlinger对象。
  3. 创建完SurfaceFlinger对象后，首先会立即执行到SurfaceFlinger::onFirstRef方法进行消息队列的初始化工作。其次调用SurfaceFlinger::init()，开始初始化绘图状态，显示设备，启动开机动画等工作。
  4. 将SurfaceFlinger服务注册到Service Manager;
  5. 调用run方法，开启无限循环，等客户端的信息并处理。
  
  ### SurfaceFlinger 消息队列处理机制
  1. 当Surface绘制完成后会发出一个Invalidate的消息给Surfaceflinger的等待线程
  2. 当waitForEvent接收到消息后就会交给onMessageReceivered去处理，
  3. 在onMessageReceivered处理过程中会首先调用handleMessageTransaction处理之前对屏幕和应用程序窗口的改动，重新计算窗口的可见区域。
  4. 其次调用handleMessageInvalidate，会根据图形缓冲区数据内容去更新脏区域。
  5. 最后handleMessageRefresh，合并和渲染输出。
  6. 步骤完成后，进入ThreadLoop,继续等待下一个invalidate消息。
  
  ### 初始化DBMS
  DropBoxManagerService(简称DBMS) 主要用于记录 Android 运行过程中, 内核, 系统进程, 用户进程等出现严重问题时的 log。 Android系统启动过程SystemServer进程时，在startOtherServices()过程会启动DBMS服务
  
  ### DBMS 概述与三个主要方法
  1. 监听存储设备可用空间低的广播
  2. 监听开机完毕的广播
  3. 监听Settings数据库变化广播
  
  开机过程中DBMS的初始化只是做了注册广播而已，当收到广播后才会去处理。
  
  #### init 方法
  该方法主要功能：
  1. 创建目录/data/system/dropbox
  2. 检查dropbox目录下所有文件，获取文件名中的时间戳。
  3. 删除后缀为tmp文件，删除时间戳为0的文件
  
  #### trimToFit 方法
  dropbox对目录中的文件数量以及存储空间大小是有规定的，当超出限制会调用trimToFit方法进行瘦身。
  1. 文件最长保存时长为3天
  2. 最大文件个数为1000
  3. 分配dropbox空间的最大值5M
  
  #### add 方法
  每当系统中有一些事件需要记录时，都会调用AMS.addErrorToDropBox()来触发DBMS工作。
  - crash: AMS.handleApplicationCrashInner过程
  - anr: AMS.appNotResponding()过程；
  - watchdog: Watchdog.run()过程;
  - native_crash: 当调用NativeCrashReporter.run()的过程;
  - wtf: 当调用Log.wtf()或者Log.wtfQuiet()的过程；
  - lowmem: 当内存较低时，触发AMS.reportMemUsage()过程；
  
  触发这些事件后，最终都会调用DropBoxManagerService.add方法将数据写入到存储目录中。
  
  ### WMS的概述
  在Android中， WindowManagerService负责对系统中的所有窗口进行管理。所谓的管理大致包括对窗口进行创建、删除，以及更换窗口的焦点。
  
  ### 窗口可创建数
  1. Application Window(应用窗口)：例如Activity，Dialog；【取值范围为1~99】
  2. Sub Window(子窗口)：不能独立存在，需要依附在其他窗口，例如PopupWindow【取值范围为1000~1999】
  3. System Window(系统窗口)：例如Toast、输入法窗口、系统音量条窗口、系统错误窗口等【2000~2999】
  
  ### WMS的作用
  - 窗口管理
  WMS是窗口的管理者，它负责窗口的启动、添加和删除，另外，窗口的大小和层级也是由WMS进行管理的。
  
  - 窗口动画
  窗口动画由WMS的动画子系统来负责，动画子系统的管理者为WindowAnimator。
  
  - 输入系统的中转站
  通过对窗口触摸从产生的触摸事件，通过WMS中转站将触摸事件交给InputManagerService进行处理。
  
  - 输入系统相关：
  窗口并不具备有绘制的功能，因此每个窗口都需要有一块Surface来供自己绘制。为每个窗口分配Surface是由WMS来完成的。
  
  ### Window、WindowManager、WMS 关系
  Window:它是一个抽象类，具体实现类为 PhoneWindow ，它对 View 进行管理。Window是View的容器，View是Window的具体表现内容。创建一个Window，通过windowManager完成。
  WindowManager:是用来添加、删除、更新Window中的View，与WMS通过Binder来进行跨进程通信，将具体的工作交由WMS来处理。
  WindowsManagerService:是在SystemServer进程中的，WindowManger中的所有操作都是由WMS来最终完成的。
  
  ### WMS启动过程
  1. SystemServer中，优先启动引导服务，核心服务，其它服务。WMS属于其它服务的一种。
  2. 在WMS启动时，会先启动IMS,并将IMS对象作为参数赋值到WMS中，后续WMS处理输入事件时会与IMS进行交互。
  3. WMS的main方法中，获取DisplayThread的handler实例，在display线程中创建WMS实例对象，然后display进入等待状态。
  4. 调用WMS实例中OnInitReady方法，开始初始化窗口管理策略，通过PWM(PhoneWindowManager)在ui线程中进行初始化，完成后，通过Handler中notifyAll唤醒display线程。
  5. 完成初始化窗口管理策略后，调用WMS实例中displayReady方法初始化屏幕显示信息，然后调用WMS实例中SystemReady方法完成初始化工作完成。
  
  ### WMS添加一个窗口
  1. 对于不通类型的窗口添加过程不同，但是对于WMS处理部分，基本上是一样的。
  2. 通过WindowManager的addview方法，但实际会最终调用到WindowManagerGlobal中的addView方法中。
  3. WindowManagerGlobal对上层参数进行检查并进行相应的调整，同时初始化ViewRootImpl对象，将View交由ViewRootImpl管理。
  4. 在ViewRootImpl会完成对View的测量，布局和绘制。
  5. ViewRootImpl通过Binder与WMS进行跨进程通信,调用addToDisplay方法为窗口分配画布Surface,最终交给SurfaceFlinger，并绘制到屏幕上。
  
  ### WMS删除一个窗口
  1. 通过WindowManager的removeView方法，但实际会最终调用到WindowManagerGlobal中的removeView方法中。
  2. 在removeView方法会通过索引获取到对应的ViewRootImpl。然后调用ViewRootImpl的die方法。
  3. 若当前View已绘制完成，直接删除。若View正在绘制则通过Handler异步的方式，将View添加到一个待删除列表中进行删除。
  4. 删除将该View在索引表中删除。
  
  ## 项目中遇到的问题：
  难度最大的事情有两个
  1. 客户那边突然提出需要一个IOS App，又比较着急，我主动把这个活接过来。
  
  我花了一周时间 ,从Object-C语言基础，XCode使用，App界面实现，IOS-Framework SDK实现，最后到App上架做了一个快速了解。
  然后又花了几周时间完成App的开发,并最终交付上架。然后我把学习IOS以及该项目中遇到的困做了详细总结，上传自己的博客中做记录。
  
  2. 上架应用商店的App客户使用后反应卡顿，会议界面长时间待机崩溃。
  
  优先解决崩溃问题，我尝试多种方式进行定位，首先Android profile中Memory Profile组件去分析内存泄漏。
  其次Android Link,通过检测哪些代码会导致内存泄漏，最后用LeakCanary+MAT工具定位到内存泄漏的位置。
  是因为非静态内部持有的引用没有回收掉导致，通过静态内部类+弱引用的方式解决了这个问题。
  
  解决卡顿问题，我通过Layout inspector分析布局的层级结构，哪些布局层级较深，然后用Android Link将布局相关扫描勾选上，然后根据Link结果。
  定位到哪些布局需要优化，然后还通过开发人员选项中 GPU 渲染模式分析工具和过渡绘制检测功能 分析哪些布局由于重复绘制导致渲染时间长。
  最后尽量用约束布局代替线性和相对比较，ViewStub代替启动过程中不显示的控件，使用自定义View替代复杂的View叠加。
  
  以上两个问题解决后，对App重新上架。后续该相关问题客户没有再反应。
  
  ## 有什么问题要问的。
  1. 平时开发的技术栈 有哪些？
  如果没接触的话，我会提前做准备
  
  2. 就目前这个招聘岗位中的要求，还有其他的能力要求吗？
  我这边 学过c++学过ios 
  文档方面，设计文档 软著 专利，我都会写。
  没有的技能，我会尽量在短时间内学习。
  
  3. 如果顺利入职的话，您觉得有哪些方面，我有必要去特意加强一下的吗？
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
