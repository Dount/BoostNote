createdAt: "2019-09-26T02:02:22.087Z"
updatedAt: "2020-07-10T10:11:05.429Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Android 面试题"
tags: []
content: '''
  # Android 面试题
  [toc]
  ## 1、 Android类加载器
  在Android开发中，不管是插件化还是组件化，都是基于Android系统的类加载器ClassLoader来设计的。只不过Android平台上虚拟机运行的是Dex字节码，一种对class文件优化的产物，传统Class文件是一个Java源码文件会生成一个.class文件，而Android是把所有Class文件进行合并、优化，然后再生成一个最终的class.dex，目的是把不同class文件重复的东西只需保留一份，在早期的Android应用开发中，如果不对Android应用进行分dex处理，那么最后一个应用的apk只会有一个dex文件。
  
  Android中常用的类加载器有两种，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader,而BaseDexClassLoader继承自ClassLoader。
  区别在于
  PathClassLoader用来加载系统类及已安装的应用程序的类；
  DexClassLoader用来加载jar、apk、dex文件中的类。
  
  ## 2、Service
  - Service是在main Thread中执行，Service中不能执行耗时操作（网络请求，拷贝数据库，大文件）。
  - 可以在xml中设置Service所在的进程，让Service在另外的进程中执行。
  - Service执行的操作最多是20s，BroadcastReceiver是10s，Activity是5s。
  - Activity通过bindService（Intent，ServiceConnection，flag）与Service绑定。
  - Activity可以通过startService和bindService启动Service。
  
  ### IntentService
  IntentService是一个抽象类，继承自Service，内部存在一个ServiceHandler（Handler）和HandlerThread（Thread）。
  IntentService是处理异步请求的一个类，在IntentService中有一个工作线程（HandlerThread）来处理耗时操作，启动IntentService的方式和普通的一样，不过当执行完任务之后，IntentService会自动停止。
  另外可以多次启动IntentService，每一个耗时操作都会以工作队列的形式在IntentService的onHandleIntent回调中执行，并且每次执行一个工作线程。
  **IntentService的本质是：封装了一个HandlerThread和Handler的异步框架**。
  
  ### 生命周期示意图
  ![714198ff.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\714198ff.png)
  
  启动Service有两种方式，startService和bindService方式。
  
  ### startService生命周期
  当我们通过调用了Context的startService方法后，我们便启动了Service，通过startService方法启动的Service会一直无限期地运行下去，只有在外部调用Context的stopService或Service内部调用Service的stopSelf方法时，该Service才会停止运行并销毁。
  
  #### OnCreate
  onCreate: 执行startService方法时，如果Service没有运行的时候会创建该Service并执行Service的onCreate回调方法；如果Service已经处于运行中，那么执行startService方法不会执行Service的onCreate方法。也就是说如果多次执行了Context的startService方法启动Service，Service方法的onCreate方法只会在第一次创建Service的时候调用一次，以后均不会再次调用。我们可以在onCreate方法中完成一些Service初始化相关的操作。
  
  #### onStartCommand
  onStartCommand: 在执行了startService方法之后，有可能会调用Service的onCreate方法，在这之后一定会执行Service的onStartCommand回调方法。也就是说，如果多次执行了Context的startService方法，那么Service的onStartCommand方法也会相应的多次调用。onStartCommand方法很重要，我们在该方法中根据传入的Intent参数进行实际的操作，比如会在此处创建一个线程用于下载数据或播放音乐等。
  ```
  public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId) {
  }
  ```
  当Android面临内存匮乏的时候，可能会销毁掉你当前运行的Service，然后待内存充足的时候可以重新创建Service，Service被Android系统强制销毁并再次重建的行为依赖于Service中onStartCommand方法的返回值。我们常用的返回值有三种值，**START_NOT_STICKY、START_STICKY和START_REDELIVER_INTENT**，这三个值都是Service中的静态常量。
  
  #### START_NOT_STICKY
  如果返回START_NOT_STICKY，表示当Service运行的进程被Android系统强制杀掉之后，不会重新创建该Service，当然如果在其被杀掉之后一段时间又调用了startService，那么该Service又将被实例化。那什么情境下返回该值比较恰当呢？如果我们某个Service执行的工作被中断几次无关紧要或者对Android内存紧张的情况下需要被杀掉且不会立即重新创建这种行为也可接受，那么我们便可将 onStartCommand的返回值设置为START_NOT_STICKY。举个例子，某个Service需要定时从服务器获取最新数据：通过一个定时器每隔指定的N分钟让定时器启动Service去获取服务端的最新数据。当执行到Service的onStartCommand时，在该方法内再规划一个N分钟后的定时器用于再次启动该Service并开辟一个新的线程去执行网络操作。假设Service在从服务器获取最新数据的过程中被Android系统强制杀掉，Service不会再重新创建，这也没关系，因为再过N分钟定时器就会再次启动该Service并重新获取数据。
  
  #### START_STICKY
  如果返回START_STICKY，表示Service运行的进程被Android系统强制杀掉之后，Android系统会将该Service依然设置为started状态（即运行状态），但是不再保存onStartCommand方法传入的intent对象，然后Android系统会尝试再次重新创建该Service，并执行onStartCommand回调方法，但是onStartCommand回调方法的Intent参数为null，也就是onStartCommand方法虽然会执行但是获取不到intent信息。如果你的Service可以在任意时刻运行或结束都没什么问题，而且不需要intent信息，那么就可以在onStartCommand方法中返回START_STICKY，比如一个用来播放背景音乐功能的Service就适合返回该值。
  
  #### START_REDELIVER_INTENT
  如果返回START_REDELIVER_INTENT，表示Service运行的进程被Android系统强制杀掉之后，与返回START_STICKY的情况类似，Android系统会将再次重新创建该Service，并执行onStartCommand回调方法，但是不同的是，Android系统会再次将Service在被杀掉之前最后一次传入onStartCommand方法中的Intent再次保留下来并再次传入到重新创建后的Service的onStartCommand方法中，这样我们就能读取到intent参数。只要返回START_REDELIVER_INTENT，那么onStartCommand重的intent一定不是null。如果我们的Service需要依赖具体的Intent才能运行（需要从Intent中读取相关数据信息等），并且在强制销毁后有必要重新创建运行，那么这样的Service就适合返回START_REDELIVER_INTENT。
  
  #### onBind
  Service中的onBind方法是抽象方法，所以Service类本身就是抽象类，也就是onBind方法是必须重写的，即使我们用不到。在通过startService使用Service时，我们在重写onBind方法时，只需要将其返回null即可。onBind方法主要是用于给bindService方法调用Service时才会使用到。
  
  #### onDestroy
  onDestroy: 通过startService方法启动的Service会无限期运行，只有当调用了Context的stopService或在Service内部调用stopSelf方法时，Service才会停止运行并销毁，在销毁的时候会执行Service回调函数。
  
  ### bindService生命周期
  
  ![91895fe2.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\91895fe2.png)
  
  #### onCreate()
  首次创建服务时，系统将调用此方法。如果服务已在运行，则不会调用此方法，该方法只调用一次。
  
  #### onStartCommand()
  当另一个组件通过调用startService()请求启动服务时，系统将调用此方法。
  
  #### onDestroy()
  当服务不再使用且将被销毁时，系统将调用此方法。
  
  #### onBind()
  当另一个组件通过调用bindService()与服务绑定时，系统将调用此方法。
  
  #### onUnbind()：
  当另一个组件通过调用unbindService()与服务解绑时，系统将调用此方法。
  
  #### onRebind()：
  当旧的组件与服务解绑后，另一个新的组件与服务绑定，onUnbind()返回true时，系统将调用此方法。
  
  ## 3、Fragment
  [Android-ReadTheFuckingSourceCode/02_fragment.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/basic/02_fragment.md)
  ### 3.1 Activity与Fragment生命周期
  
  ![0d0a189d.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\88518779.png)
  
  Activity 直接影响它所包含的 Fragment 的生命周期，所以对 Activity 的某个生命周期方法的调用也会产生对Fragment 相同方法的调用。例如：当 Activity 的 onPause() 方法被调用时，它所包含的所有的 Fragment 的onPause() 方法都会被调用。
  
  Fragment 比 Activity 还要多出几个生命周期回调方法，这些额外的方法是为了与 Activity 的交互，如下：
  - onAttach()
  当 Fragment 被加入到 Activity 时调用（在这个方法中可以获得所在的 Activity）。
  - onCreateView()
  当 Activity 要得到 Fragment 的 layout 时，调用此方法，Fragment 在其中创建自己的 layout (界面)。
  - onActivityCreated()
  当 Activity 的 onCreated() 方法返回后调用此方法。
  - onDestroyView()
  当 Fragment 的 layout 被销毁时被调用。
  - onDetach()
  当 Fragment 被从 Activity 中删掉时被调用。
  
  一旦 Activity 进入 resumed 状态（也就是 running 状态），你就可以自由地添加和删除 Fragment 了。因此，只有当 Activity 在 resumed 状态时，Fragment 的生命周期才能独立的运转，其它时候是依赖于 Activity 的生命周期变化的。
  
  #### 3.1.1 动态加载:
  动态加载时，Activity的onCreate()调用完，才开始加载Fragment并调用其生命周期方法，所以第一个生命周期方法onAttach()中便能获取Activity以及Activity的布局的组件。
  
  #### 3.1.2 静态加载:
  1. 静态加载时，Activiy的onCreate()调用过程中，fragment也在加载，所以fragment无法获取到Activity的布局中的组件，但为什么能获取到Activity呢？
  
  2. 原来在fragment调用onAttach()之前其实还调用了一个方法onInflate(),该方法被调用时fragment已经是和Activity相互结合了，所以可以获取到对方，但是Activity的OnCreate()调用还未完成，故无法获取Activity的组件。
  
  3. Activity的OnCreate()调用完成时，fragment会调用onActivityCreated()生命周期方法，因此在这开始便能获取到Activity的布局组件。
  
  
  ### 3.2 创建方式
  
  ####  3.2.1 静态创建
  首先我们需要创建一个xml文件，然后创建与之对应的java文件，通过onCreatView()的返回方法进行关联，最后我们需要在Activity中进行配置相关参数即在Activity的xml文件中放上fragment的位置。
  ```
   <fragment
          android:name="xxx.BlankFragment"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
      </fragment>
  ```
  #### 3.2.2 动态创建
  动态创建Fragment 主要有以下几个步骤：
  1. 创建待添加的fragment示例。
  2. 获取FragmentManager,在Activity中可以直接通过调用getSupportFramentManager()方法得到。
  3. 开启一个实务，通过调用beginTransaction()方法开启。
  4. 向内容内添加或替换fragment,一般使用replace()方法实现，需要传入容器的id和待添加的fragment实例。
  5. 提交事务，调用commit()方法来完成。
  
  ### 3.3 Adapter对比 (ViewPage与Adapter使用)
  FragmentPageAdapter
  在每次切换页面时，只是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响。
  FragmentPageStateAdapter
  继承子 pager。该 PagerAdapter 的实现将只保留当前页面，当页面不在当前显示的时候，页面会清理，释放其资源。而在页面需要显示时，生成新的页面，重新生成数据。这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存。
  
  ### 3.4 Fragment与Activity通信
  
  #### 3.4.1 Activity向Fragment传值
  1. 第一种 handle方案
  activity响应事件，发送msg，到fragment中，而fragment中用来接收msg，所以用注册Handler对象，activity中发送msg的对象与fragment中handler对象必须为同一个（handler，msgqueen和looper相互唯一绑定），所以要在activity中暴露pubilic方法让fragment的acttch周期中传递handler。
  
  activity的响应事件发送msg：
  ```
  tvMain.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  //如果是activity相应事件，发送msg
                  if(handler == null){
                      return;
                  }
                  Message message = new Message();
                  Bundle bundle = new Bundle();
                  bundle.putString("hehe","我是activity发送的msg");
                  message.setData(bundle);
                  handler.sendMessage(message);
              }
          });
  ```
  activity中暴露的setHandler方法：
  ```
   //activity暴露方法来给fragment来设置
      public void setHandler(Handler handler){
          this.handler = handler;
      }
  ```
  fragment中传递handler：
  ```
  @Override
      public void onAttach(Context context) {
          super.onAttach(context);
          MainActivity activity = (MainActivity) getActivity();
          activity.setHandler(mHandler);
      }
  ```
  fragment注册handler用来接收msg：
  ```
  private Handler mHandler = new Handler(){
  
          @Override
          public void handleMessage(Message msg) {
              super.handleMessage(msg);
  
              Bundle bundle = msg.getData();
              strHandler = bundle.getString("hehe");
              textView.setText(strHandler+TwoFragment.class.getName());
          }
      };
  ```
  - fragment向activity传递消息同样可以利用此方法
  - Fragment对具体的activity存在耦合比较高，不利于Fragment复用，不利于维护。
  
  2. 第二种 Bundle方案
    1) Fragment动态加载的状态
    (Fragment是动态加载的)在activity中建一个bundle，把要传的值存入bundle，然后通过fragment的setArguments（bundle）传到fragment，在fragment中，用getArguments接收
  Activity:
  ```
  MyFragment fragment = new MyFragment();
  	Bundle bundle=new Bundle();
      bundle.putString("one","要传的值");
      fragment.setArguments(bundle);
      FragmentManager fm = getFragmentManager();
  	FragmentTransaction ft=fm.beginTransaction();
  	ft.add(R.id.frame,myFragment,"myFragment");
      ft.commit();
  ```
  Fragment:
  ```
  Bundle bundle=getArguments();
  String s=bundle.getString("one");
  ```
    2) Fragment静态加载的状态
  (Fragment是静态加载的)在Fragment中设置set,get方法，在activity中获取Fragment对象，fragment.setValue(),Fragment中getValue()
  注：静态加载Fragment的时候，一定要给Fragment设置一个唯一标识，id/tag
  
  activity：
  ```
  FragmentManager fm = getFragmentManager();
  MyFragment myFragment = (MyFragment)fm.findFragmentById(R.id.fragment);
  myFragment.setValue("传值");
  ```
  Fragment：
  ```
  	private String value;
  
  	private void setValue(String value){
  		this.value = value;
  	}
  
  	private String getValue(){
  		return this.value;
  	}
  
  //在需要获取的地方调用getValue()
  	@Nullable
      @Override
      public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
          View v=inflater.inflate(R.layout.fragment,null);
          // 给fragment上的按钮添加点击事件
          text = v.findViewById(R.id.tv_show);
          btn = v.findViewById(R.id.btn_get);
          btn.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
  				 text.setText(getValue());
              }
          });
          return v;
      }
  ```
  #### 3.4.2 Fragment向Activity传值
  1. 第一种 广播 方案
  在fragment中发送广播，在activity中注册广播接收者，并作出相应逻辑。
  在fragment中发送广播信息：
  ```
  button.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  //发送广播
                  Intent intent = new Intent();
                  intent.setAction("co.daggertest.fragment.ThreeFragment");
                  intent.putExtra("heihei","fragment发送广播");
                  //使用的本地广播，用于单个app内通信，性能和安全性好点
                  LocalBroadcastManager.getInstance(getActivity()).sendBroadcast(intent);
              }
          });
  ```
  在activity中注册广播：
  ```
    //注册本地广播接收者
          myBroadcast = new MyBroadcast();
          IntentFilter intentFilter = new IntentFilter();
          intentFilter.addAction("co.daggertest.fragment.ThreeFragment");
          LocalBroadcastManager.getInstance(this).registerReceiver(myBroadcast,intentFilter);
  ```
  ```
      内部类创建实例
   class MyBroadcast extends BroadcastReceiver{
  
          @Override
          public void onReceive(Context context, Intent intent) {
              heihei = intent.getStringExtra("heihei");
              tvMain.setText(heihei+MainActivity.class.getName());
  
          }
      }
  ```
  在activity的onDestory中注销广播：
  ```
  @Override
      protected void onDestroy() {
          super.onDestroy();
          LocalBroadcastManager.getInstance(this).unregisterReceiver(myBroadcast);
      }
  ```
  2. 第二种 回调接口 方案
  在fragment中创建接口，activity实现接口中方法，完成回调和参数传递。
  创建接口：
  ```
  public interface FourMainActivity{
          void changerSomething(String msg);
      }
  ```
  绑定activity：
  ```
   @Override
      public void onAttach(Context context) {
          super.onAttach(context);
          fourMainActivity = (FourMainActivity) context;
      }
  ```
  设置监听回调：
  ```
  button.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  fourMainActivity.changerSomething("我是通过接口传递到MainActivity中");
              }
          });
  ```
  activity实现接口：
  ```
  public class MainActivity extends AppCompatActivity implements FourFragment.FourMainActivity
  ```
  实现接口方法：
  ```
  @Override
      public void changerSomething(String msg) {
          tvMain.setText(msg);
      }
  ```
  
  #### 3.4.3 Fragment与Fragment 之间是如何传值的
  
  1. 第一种 实现接口（中间依赖Activity） 方案
  [A_activity_Two_fragment· GitHub](https://github.com/wanglianghai/A_activity_Two_fragment/commit/3d591c6286bc57667d341f7a96d46bd2f2f8a3fb?diff=unified)
  [同一个Activity托管的两个Fragment之间的数据交互 - 简书](https://www.jianshu.com/p/dd6376cf1f9d)
  [在同一个Activity下实现两个Fragment之间的通信 - 简书](https://www.jianshu.com/p/bf923a23358c)
  
  2. 第二种 EventBus 方案 
  [EventBus使用详解_cyc的专栏-CSDN博客_eventbus](https://blog.csdn.net/u012317510/article/details/78935720)
  
  **参考**
  [Fragment与Activity之间的传值_Silence_Sep的博客-CSDN博客_fragment向activity传递数据](https://blog.csdn.net/Silence_Sep/article/details/86572297)
  [fragment通信的几种方式（接口框架）_HUandroid的博客-CSDN博客_fragmeng通信](https://blog.csdn.net/HUandroid/article/details/79481363)
  
  ### 3.5 API的区别
  1. add
  一种是add方式来进行show和add,这种方式你切换fragment不会让frament重新刷新，只会调用onHiddenChange(boolean isHidden)
  2. replace
  而用replace方式会使fragment重新刷新，因为add方式是将fragment隐藏了而不是销毁再创建，replace方式每次都是重新重建。
  3. commit/commitAllowingStateLoss 
  [Android commit 和 commitAllowingStateLoss 的区别 - 简书](https://www.jianshu.com/p/83e673c453f9)
  两者都可以提交fragment的操作，唯一的不同是第二种方法，在Activity和FragmentActivity内的onSaveInstanceState方法保存了fragment的状态。在onSaveInstanceState方法后调用commit和commitAllowingStateLoss会引起一种问题：因内存不足而把不显示在前台的activity(带有 fragment)销毁，之后用户再回到此 activity 页面时，是会丢失在onSaveInstanceState后调用commit方法提交的页面状态信息!不同的只是调用commit会报错，调用commitAllowingStateLoss不报错
  
  ### 3.6 懒加载(解决预加载问题)
  经常在使用fragment时，常常会结合着viewpager使用，那么就会遇到一个问题，就是初始化fragment的时候，会连同网络请求一起执行，这样非常消耗性能，最理想的方式是，只有用户点开或滑动到当前fragment时，才进行请求网络的操作。因此，我们就产生了懒加载这样一个说法。
  
  在Viewpager与fragment使用时，默认加载前两个fragment。这样很容易造成网络丢包，阻塞等问题。
  
  最好的解决的问题的方法，重写Fragment的setUserVisibleHint()方法，实现Fragment内部的懒加载机制。
  
  由于setUserVisibleHint这个方法优于onCreate()，onCreateView()方法，它会通过isVisiBleToUser告诉我们当前Fragment我们是否可见，当可见时候再进行网络加载。但是如果在setUserVisibleHint()要实现懒加载的话，就必须要确保View 以及其他变量都已经初始化结束，避免空指针。
  
  [Fragment的懒加载](https://blog.csdn.net/u011315960/article/details/71404177)
  
  
  ## 4、Activity
  ### 4.1 点击Launcher图标来启动Activity
  用户从Launcher程序点击应用图标可启动应用的入口Activity，Activity启动时需要多个进程之间的交互，Android系统中有一个zygote进程专用于孵化Android框架层和应用层程序的进程。还有一个system_server进程，该进程里运行了很多binder service。例如ActivityManagerService，PackageManagerService，WindowManagerService，这些binder service分别运行在不同的线程中，其中ActivityManagerService负责管理Activity栈，应用进程，task。
  
  用户在Launcher程序里点击应用图标时，会通知ActivityManagerService启动应用的入口Activity，ActivityManagerService发现这个应用还未启动，则会通知Zygote进程孵化出应用进程，然后在这个dalvik应用进程里执行ActivityThread的main方法。应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法。
  
  ### 4.2 Activity生命周期
  ![16bff4353c5b177c.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\51da952a.png)
  
  #### 4.2.1 Activity的形态
  **Active/Running:** 
  Activity处于活动状态，此时Activity处于栈顶，是可见状态，可与用户进行交互
  
  **Paused:**
  当Activity失去焦点时，或被一个新的非全屏的Activity，或被一个透明的Activity放置在栈顶时，Activity就转化为Paused状态。但我们需要明白，此时Activity只是失去了与用户交互的能力，其所有的状态信息及其成员变量都还存在，只有在系统内存紧张的情况下，才有可能被系统回收掉。
  
  **Stopped:**
  当一个Activity被另一个Activity完全覆盖时，被覆盖的Activity就会进入Stopped状态，此时它不再可见，但是跟Paused状态一样保持着其所有状态信息及其成员变量。
  
  **Killed:**
  当Activity被系统回收掉时，Activity就处于Killed状态。
  
  #### 4.2.2 Activity的生命周期
  所谓的典型的生命周期就是在有用户参与的情况下，Activity经历从创建，运行，停止，销毁等正常的生命周期过程。
  
  **onCreate**
  该方法是在Activity被创建时回调，它是生命周期第一个调用的方法，我们在创建Activity时一般都需要重写该方法，然后在该方法中做一些初始化的操作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。
  
  **onStart**
  此方法被回调时表示Activity正在启动，此时Activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。可以简单理解为Activity已显示而我们无法看见摆了。
  
  **onResume**
  当此方法回调时，则说明Activity已在前台可见，可与用户交互了（处于前面所说的Active/Running形态），onResume方法与onStart的相同点是两者都表示Activity可见，只不过onStart回调时Activity还是后台无法与用户交互，而onResume则已显示在前台，可与用户交互。从流程图可以看出当Activity停止后（onPause方法和onStop方法被调用），重新回到前台时也会调用onResume方法，因此在onResume方法中初始化一些资源，然后在onPause或者onStop方法中释放的资源。
  
  **onPause**
  此方法被回调时则表示Activity正在停止（Paused形态），一般情况下onStop方法会紧接着被回调。但通过流程图看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象，这可能是用户操作使当前Activity退居后台后又迅速地再回到到当前的Activity，此时onResume方法就会被回调。
  当然，在onPause方法中可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示,而onPause方法执行完成后，新Activity的onResume方法才会被执行。
  
  **onStop**
  一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖（Stopped形态），此时Activity不可见，仅在后台运行。同样地，在onStop方法可以做一些资源释放的操作（不能太耗时）。
  
  **onRestart**
  表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。
  
  **onDestroy**
  此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。
  
  1) 当Activity启动时，依次会调用onCreate(),onStart(),onResume()，
  2) 当Activity退居后台时（不可见，点击Home或者被新的Activity完全覆盖），onPause()和onStop()会依次被调用。
  3) 当Activity退居后台且系统内存不足， 系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走onCreate()-->onStart()--->onResume()
  4) 当Activity返回前台（从桌面回到原Activity或者被覆盖后又回到原Activity）时，onRestart()，onStart()，onResume()会依次被调用。
  5) 当Activity退出销毁时（点击back键），onPause()，onStop()，onDestroy()会依次被调用，到此Activity的整个生命周期方法回调完成。
  6) 锁定屏与解锁屏幕 只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()
  7) 两个Activity之间切换: Activity A 启动另一个Activity B，回调如下:Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop();如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop；
  
  **注意**
  1. 透明主题对生命周期的影响
    当A-Activity启动B-Activity时，并且启动之后A-Activity还处于部分可见状态，当启动完B之后并不回调A的onStop()方法。
  [Activity A启动Activity B它们的生命周期变化（及设置Activity的透明度）_YoungForYou-CSDN博客_activitya启动activityb生命周期](https://blog.csdn.net/weixin_43589682/article/details/97030740)
  2. 屏幕旋转,屏幕大小改,键盘发生了改变,键盘的可用性发生了改变对生命周期的影响
  
  没有配置 configChanges：
  ```
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onResume()
  A: ==> onPause()
  A: ==> onSaveInstanceState()
  A: ==> onStop()
  A: ==> onDestroy()
  屏幕旋转后
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onRestoreInstanceState()
  A: ==> onResume()
  ```
  配置 configChanges 后：android:configChanges="keyboard|orientation|screenSize|keyboardHidden"
  ```
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onResume()
  A: ==> onConfigurationChanged()
  ```
  
  #### 4.2.3 保存与恢复 onSaveInstanceState() onRestoreInstanceState()
  1. onSaveInstanceState()
  (1)、当用户按下HOME键时。会调用 onSaveInstanceState() 方法
  (2)、长按HOME键，选择运行其他的程序时。会调用 onSaveInstanceState() 方法 
  (3)、按下电源按键（关闭屏幕显示）时。会调用 onSaveInstanceState() 方法
  (4)、从activity A中启动一个新的activity时。会调用 onSaveInstanceState() 方法
  (5)、屏幕方向切换时，例如从竖屏切换到横屏时。会调用 onSaveInstanceState() ,onRestoreInstanceState()方法
  
  2. onRestoreInstanceState()
  onRestoreInstanceState()被调用的前提是，activity A“确实”被系统销毁了。
  
  3. 屏幕旋转测试
  android:screenOrientation="portrait"
  去掉，支持转屏。然后就一定会触发onSaveInstanceState()和onRestoreInstanceState()。
  因为当 Activity 横竖屏切换的时候会重新走一遍生命周期，所以 Activity 会被销毁创建，由此会执行 onRestoreInstanceState() 方法。
  
  4. 保存Activity状态
  当Activity开始停止时，系统会调用，onSaveInstanceState()以便您的Activity可以使用一组键值对来保存状态信息。此方法的默认实现保存有关Activity视图层次结构状态的信息，例如EditText小部件中的文本或ListView的滚动位置。
  为了保存Activity的附加状态信息，您必须实现onSaveInstanceState()并向对象添加键值对Bundle
  ```
  static final String STATE_SCORE = "playerScore";
  static final String STATE_LEVEL = "playerLevel";
  ...
  
  @Override
  public void onSaveInstanceState(Bundle savedInstanceState) {
      // 保存用户自定义的状态
      savedInstanceState.putInt(STATE_SCORE, mCurrentScore);
      savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);
      
      // 调用父类交给系统处理，这样系统能保存视图层次结构状态
      super.onSaveInstanceState(savedInstanceState);
  }
  ```
  
  5. 恢复Activity状态
  当Activity在之前被破坏后重新创建时，您可以从Bundle系统通过您的Activity中恢复您的保存状态。这两个方法onCreate()和onRestoreInstanceState()回调方法都会收到Bundle包含实例状态信息的相同方法。
  
  因为onCreate()调用该方法是否系统正在创建一个新的Activity实例或重新创建一个以前的实例，所以必须Bundle在尝试读取之前检查该状态是否为空。如果它为空，那么系统正在创建一个Activity的新实例，而不是恢复之前被销毁的实例。
  ```
  @Override
  protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState); // 记得总是调用父类
     
      // 检查是否正在重新创建一个以前销毁的实例
      if (savedInstanceState != null) {
          // 从已保存状态恢复成员的值
          mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
          mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
      } else {
          // 可能初始化一个新实例的默认值的成员
      }
      ...
  }
  ```
  onCreate()可以选择执行onRestoreInstanceState()，而不是在系统调用onStart()方法之后恢复状态。系统onRestoreInstanceState()只有在存在保存状态的情况下才会恢复，因此您不需要检查是否Bundle为空：
  ```
  public void onRestoreInstanceState(Bundle savedInstanceState) {
      // 总是调用超类，以便它可以恢复视图层次超级
      super.onRestoreInstanceState(savedInstanceState);
     
      // 从已保存的实例中恢复状态成员
      mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
      mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
  }
  ```
  
  ### 4.3 启动模式
  #### 4.3.1 standard
  默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。
  
  #### 4.3.2 singleTop
  可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法。
  
  #### 4.3.3 singleTask
  只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。
  
  如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。
  
  个人理解：启动顺序A->B->C->D->B ,这时候B由于是singleTask,会把C D destory掉。task里只剩A B.
  [singleTask启动模式引发的问题和感悟 - 简书](https://www.jianshu.com/p/fe98ae8e3fb4)
  
  #### 4.3.4 singleInstance
  只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。
  [Activity SingleInstance启动模式 - javakam - 博客园](https://www.cnblogs.com/jooy/p/9494165.html)
  [SingleTask和SingleInstance详解_ywj2167917的专栏-CSDN博客_singletask和singleinstance](https://blog.csdn.net/ywj2167917/article/details/8827830)
  #### 4.3.5 task
  我们知道，一个应用中可能有多个 Activity，而这些 Activity 被以栈的形式管理。当我们新打开 Activity 或者按返回时，会导致 Activity 的入栈/出栈。
  Task 是指在执行特定任务时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈中。
  
  ### 4.4 ActivityThread类
  1. 在Android中它就代表了Android的主线程，注意是代表而不是说它就是一个Thread类
  2. 它是创建完新进程之后（肯定是在一个线程中啊），main函数被加载，然后执行一个loop的循环使当前线程进入消息循环，并且作为主线程。
  3. 接下来还会初始化很多必要的属性. 它的很多成员变量和内部类十分的重要，深入理解这些成员变量有助于我们进一步的认识Android系统的各个组件的交互。
  
  ### 4.5 Intent类
  Intent 分两种，显式 Intent 和隐式 Intent。 
  #### 4.5.1 显式Intent
  如果一个 Intent 明确指定了要启动的组件的完整类名，那么这个 Intent 就是显式 Intent.
  ```
  Intent intent = new Intent(this, xxx.class);
  startActivity(intent);
  ```
  
  #### 4.5.2 隐式Intent
  [Android的进阶学习(三)--Intent和IntentFilter - 简书](https://www.jianshu.com/p/a2f826064e29)
  [IntentFilter匹配规则详解 - 天涯海角路 - 博客园](https://www.cnblogs.com/aademeng/articles/11026731.html)
  IntentFilter(意图过滤器),当隐式启动系统组件的时候，就会根据IntentFilter来筛选出合适的进行启动。
  在Intent启动的时候对应设置Action、Category、DataAndType，这里设置的是为了过滤的时候对应IntentFilter匹配action、category、data。
  除过滤广播的的IntentFilter可以在代码中创建外，其它的IntentFilter都得在AndroidManifest.xml中给设置。
  
  ```
  Intent  intent = new Intent();
  intent.addAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.addDataType("video/mpeg");
  ```
  AndroidManifest.xml 设置
  ```
  <activity  android:name=".Activity_B"    
             android:label="@string/title_activity_activity__b"
             android:launchMode="singleInstance">  
    <intent-filter> 
      <action android:name="android.intent.action.ANSWER" />    
      <category android:name="android.intent.category.APP_EMAIL" />        
      <data  android:host="www.mathiasluo.com"   
             android:scheme="http" />  
    </intent-filter>
  </activity>
  ```
  一个组件可以有多个IntentFilter，在过滤的时候只要有一组符合要求的，就会被视为过滤通过。
  
  1) action匹配
  action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同
  2) category匹配
  如果Intent中的存在category那么所有的category都必须和IntentFilter中的category相同。才能和这个Activity匹配。
  Intent中的category数量可能少于IntentFilter中的category数量，但是Intent中category必须和IntentFilter中的category相同才能匹配。
  3) data匹配
  如果IntentFilter中有定义data，那么Intent中也必须也要定义date
  4) 隐式启动的判断
  判断隐式启动的Intent是否能找到相应的组件方法
  <一>
  ```
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.setDataAndType(Uri.EMPTY, "video/mpeg");
  PackageManager packageManager = getPackageManager();
  List<ResolveInfo> infoList = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
  Log.i(TAG, infoList.size() + "");
  if (infoList.size() != 0) {  
    startActivity(intent);
  } else { 
     Log.e(TAG, "没有匹配到Activity");
  }
  ```
  <二>
  ```
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.setDataAndType(Uri.EMPTY, "video/mpeg");
  ComponentName name =  intent.resolveActivity(getPackageManager());
  if (name != null){
      startActivity(intent);
  }else {
      Log.e(TAG,"没有匹配到Activity");
  }
  ```
  
  **注意**
  1. 如果 intent-filter 中没有包含任何Action类型，那么无论什么Intent请求都无法和这条 nintent-filter 匹配。
  2. 如果Intent请求中没有设定Action类型，那么只要 intent-filter 中包含有Action类型，这个Intent请求就将顺利地通过 intent-filter 的行为测试。
  3. intent中可以不存在category，但如果存在就必须匹配intent-filter其中一个
  4. 系统在startActivity或者startActivityForResult的时候默认为Intent加上一个android.intent.category.DEAFAULT，所以必须在intent-filter中加上android.intent.category.DEFAULT这个category
  
  ### 4.6 URL Scheme
  Android 中的 Scheme 是一种页面内跳转协议，是一种非常好的实现机制。通过定义自己的 Scheme 协议，可以非常方便跳转 App 中的各个页面。
  #### 4.6.1 使用场景
  通过小程序，利用 Scheme 协议打开原生 App。
  - H5 页面点击锚点，根据锚点具体跳转路径 App 端跳转具体的页面。
  - App 端收到服务器端下发的 Push 通知栏消息，根据消息的点击跳转路径跳转相关页面。
  - App 根据URL跳转到另外一个 App 指定页面。
  - 通过短信息中的 URL 打开原生 App。
  
  #### 4.6.2 Scheme 路径的规则
  ```
  <scheme> :// <host> : <port> [<path>|<pathPrefix>|<pathPattern>]
  ```
  #### 4.6.3 设置Scheme
  在 AndroidManifest.xml 中对标签增加设置 Scheme。
  ```
  <activity
      android:name=".ui.activity.SchemeActivity"
      android:screenOrientation="portrait">
      <!--Android 接收外部跳转过滤器-->
      <!--要想在别的 App 上能成功调起 App，必须添加 intent 过滤器-->
      <intent-filter>
          <!--协议部分配置，注意需要跟 web 配置相同-->
          <!--协议部分，随便设置 aa://bb:1024/from?type=jeanboy-->
          <data android:scheme="aa"
              android:host="bb"
              android:port="1024"
              android:path="/from"/>
          <!--下面这几行也必须得设置-->
          <category android:name="android.intent.category.DEFAULT" />
          <!--表示 Activity 允许通过网络浏览器启动，以显示链接方式引用，如图像或电子邮件-->
          <category android:name="android.intent.category.BROWSABLE" />
          <action android:name="android.intent.action.VIEW" />
      </intent-filter>
  </activity>
  ```
  #### 4.6.4 原生调用
  ```
  Uri uri = Uri.parse("aa://bb:1024/from?type=jeanboy");
  Intent intent = new Intent(Intent.ACTION_VIEW, uri);
  startActivity(intent);
  ```
  #### 网页调用
  ```
  <a href="aa://bb:1024/from?type=jeanboy">打开 App</a>
  ```
  #### 在Activity中处理Scheme跳转
  ```
  public class SchemeActivity extends AppCompatActivity {
  
      @Override
      protected void onCreate(@Nullable Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          Uri uri = getIntent().getData();
          if (uri != null) {
              //获取指定参数值
              String type = uri.getQueryParameter("type");
              Log.e("SchemeActivity", "type:" + type);
  
              if(type.equals("jeanboy")){
                  ActivityUtils.startActivity(XXXActivity.class);
              }else if(type.equals("main")){
                  ActivityUtils.startActivity(MainActivity.class);
              }
          }
          finish();
      }
  }
  ```
  
  ### 4.x 拓展
  #### 4.x.1 ActivityManagerService[AMS]
  AMS是系统的引导服务，应用进程的启动、切换和调度、四大组件的启动和管理都需要AMS的支持。
  [ActivityManagerService 你了解多少？ - Android - 掘金](https://juejin.im/entry/582d319e0ce463006ce68110)
  
  #### 4.x.2 ActivityStarter
  ActivityStarter是加载Activity的控制类，收集所有的逻辑来决定如何将Intent和Flags转为Activity并将其与Task和Stack关联。
  
  #### 4.x.3 ActivityStackSupervisor
  AMS 通过操作ActivityStackSupervisor来管理Activity
  
  #### 4.x.4 ActivityStack
  ActivityStack从名称来看是跟栈相关的类，其实它是一个管理类，用来管理系统所有Activity的各种状态。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。
  
  #### 4.x.5 ApplicationThread
  它是ActivityThread的私有内部类，也是一个Binder对象。在此处它是作为IApplicationThread对象的server端等待client端 的请求然后进行处理，最大的client就是AMS.
  
  #### 4.x.6 Context,Activity,Application的关系
  相同：Activity和Application都是Context的子关系
  不同：
     1.维护的生命周期不同
     2.Context维护的是当前Activity的生命周期
     3.Application维护的是整个项目的周期
  
  ### 4.6 Context
  1.描述的一个应用程序环境的信息即上下文的意思，在实际应用中它也确实是起到了管理 上下文环境中各个参数和变量的总用,方便我们可以简单的访问到各种资源。
  2.Context是一个接口，实现该接口的具体实现类Contextlml
  3.通过它我们可以获取应用程序的资源和类，也包括一些应用级别软件，例如，启动一个Activity,发送广播，接受intent信息等。
  ![16dfd0c7a29d65e6.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\cca26d9c.png)
  
  ## 5、BroadcastReceiver
  
  ## 6、ContentProvider
  
  ## 7、Activity,PhoneWindow和DecorView 的关系
  ![16bff4353cd98658.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\852c0377.png)
  
  ### 7.1 DecorView 浅析
  ![16bff4356573308b.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\4aeeca66.png)
  如图所示，DecorView为整个Window界面的最顶层View，它只有一个子元素LinearLayout。代表整个Window界面，包含通知栏、标题栏、内容显示栏三块区域。其中LinearLayout中有两个FrameLayout子元素。
  
  ### 7.2 DecorView 的作用
  DecorVuew是顶级View,本质是一个FrameLayout它包含两部分，标题栏和内容栏，都是FrameLayout,内容栏id是content,也就是Activity中设置setContentView的部分,最终将布局添加到id为content的FrameLayout中。获取content:
  ViewGroup content=findViewByld(android.id.content)获取设置的View :getChildAt(0);
  
  使用总结
  
  每个Activity都包含一个Window对象，Window对象通常是由PhoneWindow实现的。
  PhoneWindow:将DecorView设置为整个应用窗口的根View,是Window的实现类。它是Android中的基本的窗口系统，每个Activity均会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。
  DecorView:是顶层视图，将要呈现的具体内容呈现在PhoneWindow上，DecorView是当前Activity所有View的祖先，它并不会向用户呈现任何东西。
  
  ## 8、系统原理
  
  ### 8.1 打包原理
  1. 通过AAPT工具进行资源文件(包括AndroidManifest.xml、布局文件、各种xml资源等)的打包，生成R.java文件。
  AAPT:Android Asset Packaging Tool，在SDK的build-tools目录下。
  3. 通过AIDL工具处理 AIDL文件，生成相应的java文件。
  AIDL::Android Interface Definition Language,Android 接口定义语言（跨进程访问服务）
  为了使其他的应用程序也可以访问本应用程序提供的服务，Android系统采用了远程过程调用（Remote Procedure Call，RPC）方式来实现。与很多其他的基于RPC的解决方案一样，Android使用一种接口定义语言（Interface Definition Language，IDL）来公开服务的接口。我们知道4个Android应用程序组件中的3个（Activity、BroadcastReceiver和ContentProvider）都可以进行跨进程访问，另外一个Android应用程序组件Service同样可以。
  5. 通过javac工具编译项目编码，生成Class文件。
  6. 通过DX工具将所有的Class 文件转换成DEX文件，该过程主要完成java字节码转换成Dalvik字节码，压缩常量池以及清除,冗余信息等工作。
  DX工具:android将jar包转成dex格式二进制jar包工具,在SDK的platform-tools目录下
  7. 通过ApkBilder工具将资源文件、DEX文件打包生成Apk文件
  8. 利用KeyStore对生成的Apk文件进行签名
  9. 如果是正式版的APK,还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始举例都偏移4字节的整数倍,这样通过内存映射访问Apk文件的速度会更快。
  ZipAlign:Android SDK中包含了一个用于优化APK的新工具zipalign。它提高了优化后的Applications与Android系统的交互效率可以使整个系统的运行速度有了较大的提升。
  ![16bff4358a12ae4c.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\886e21c0.png)
  
  ### 8.2 安装流程
  1. 复制APK到/data/app目录下，解压并扫描安装包
  2. 资源管理器解析APK里的资源文件.
  3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。
  4. 然后对dex文件进行优化，并保存的dalvik-cache目录下。
  5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。
  6. 安装完成后，发送广播
  ![252739b9.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\252739b9.png)
  
  ## 9、屏幕适配
  
  ### 9.1 基本概念
  #### 9.1.1 屏幕尺寸
  含义：手机对角线的物理尺寸单位：英寸（inch）,1英寸=2.52cm
  Android手机常见的尺寸有5寸，5.5寸，6寸，6.5寸等等
  
  #### 9.1.2 屏幕分辨率
  含义：手机在横向、纵向上的像素点数总和
  一般描述成屏幕的”宽x高”=AxB 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点。
  例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点。
  单位：px（pixel），1px=1像素点
  Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920
  
  #### 9.1.3 屏幕像素密度
  含义：每英寸的像素点数 单位：dpi（dots per ich）
  
  假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi
  
  #### 9.1.4 适配方法
  1. 支持各种屏幕尺寸:使用wrap_content,match_parent,weight 
  2. 要确保布局的灵活性并适应各种尺寸的屏幕，应使用"wrap_content","match_parent"控制某些视图组件的宽度和高度。
  3. 使用相对布局
  4. 使用LinearLayout的weight的属性
  在Match_parent情况下，**权重设置的是显示优先级**
  当组件宽度设置为”match_parent”的时候，这里的权重值，表示的组件显示的优先级，而且值越小优先级越高，因为按钮2优先级为1，大于按钮1的优先级，所以按钮2占的是3/4,按钮1占的是1/4。 
  在wrap_content(0dp)情况下，**权重设置的是按比例分配显示空间**
  
  ## 10、性能优化
  ### 10.1 内存优化
  #### 10.1.1 LeakCanary工具
  LeakCanary是Square公司基于MAT开发的一款监控Android内存泄漏的开源框架。其工作的原理是： 监测机制利用了Java的WeakReference和ReferenceQueue，通过将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中，通过监测ReferenceQueue里面的内容就能检查到Activity是否能够被回收（在ReferenceQueue中说明可以被回收，不存在泄漏；否则，可能存在泄漏，LeakCanary是执行一遍GC，若还未在ReferenceQueue中，就会认定为泄漏）。
  
  如果Activity被认定为泄露了，就抓取内存dump文件(Debug.dumpHprofData)；之后通过HeapAnalyzerService.runAnalysis进行分析内存文件分析；接着通过HeapAnalyzer (checkForLeak—findLeakingReference---findLeakTrace)来进行内存泄漏分析。最后通过DisplayLeakService进行内存泄漏的展示。
  #### 10.1.2 Android Lint工具
  Android Lint Tool 是Android Sutido种集成的一个Android代码提示工具，它可以给你布局、代码提供非常强大的帮助。硬编码会提示以级别警告，例如：在布局文件中写了三层冗余的LinearLayout布局、直接在TextView中写要显示的文字、字体大小使用dp而不是sp为单位，就会在编辑器右边看到提示。
  
  ### 10.2 APK瘦身
  #### 10.2.1 安装包的组成
  assets文件夹 存放一些配置文件，资源文件，assets不会自动生成对应的ID,而是通过AssetManager类的接口获取
  
  res res是resource的缩写，这个目录存放资源文件，会自欧东生成对应的ID并映射到.R文件中，访问直接使用资源ID。
  
  META-INF. 保存应用的签名信息，签名信息可以炎症APK文件的完整性.
  
  AndroidManifes.xml, 这个文件用来描述Android应用的配置信息，一些组件的注册信息，可使用权限。
  
  classex.dex Dalvik字节码程序，让Dalvik虚拟机可执行，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将java字节码转换为Dalvik字节码
  
  resources.arsc 记录着资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。
  
  #### 10.2.2 减少安装包大小
  
  代码混淆：使用IDE 自带的 proGuard 代码混淆器工具 ，它包括压缩、优化、混淆等功能。 
  资源优化：使用 Android Lint 删除冗余资源，资源文件最少化等。 
  图片优化: 利用 PNG优化工具 对图片做压缩处理。推荐目前最先进的压缩工具Googlek开源库zopfli。如果应用在0版本以上，推荐使用 WebP图片格式。 
  
  ### 10.3 冷启动与热启动
  
  **冷启动** 
  在启动应用时，系统中没有该应用的进程，这时系统会创建一个新的进程分配给该应用；
  
  **热启动**
  在启动应用时，系统中已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程还是保留在后台）；
  
  **区别 冷启动**
  冷启动:系统没有该应用的进程，需要创建一个新的进程分配给应用，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。 
  热启动:从已有的进程中来启动，不会创建和初始化Application类，直接创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。
  
  **冷启动流程** 
  Zygote进程中fork创建出一个新的进程； 创建和初始化Application类、创建MainActivity； inflate布局、当onCreate/onStart/onResume方法都走完； contentView的measure/layout/draw显示在界面上。
  
  **冷启动优化** 
  减少在Application和第一个Activity的onCreate()方法的工作量； 不要让Application参与业务的操作； 不要在Application进行耗时操作； 不要以静态变量的方式在Application中保存数据； 减少布局的复杂性和深度；
  
  ## 文献
  
  [jeanboy_jeanboydev_CSDN博客-Android进阶,Java基础,Android进阶领域博主](https://blog.csdn.net/freekiteyu/article/list/1)
'''
linesHighlighted: [
  380
  733
  798
]
isStarred: false
isTrashed: false
