createdAt: "2019-09-26T02:02:22.087Z"
updatedAt: "2023-03-09T16:14:02.852Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Android"
tags: []
content: '''
  # Android
  [toc]
  ## 1、Application 生命周期
  - Application和Activity,Service一样，是Android框架的一个系统组件。
  - 当Android程序启动时系统会创建一个application对象用来存储系统的一些信息。
  - Android系统会为每个程序运行时创建一个Application类的对象且只创建一个。
  
  ### 1.1 Application中五个公开的方法
  1）void  onConfigurationChanged(Configuration newConfig)
  配置被改变时触发 
  2）void  onCreate() 
  程序创建时创建
  3）void  onLowMemory()
  内存不够时触发
  4）void  onTerminate()
  当终止程序时调用 但是不能保证一定调用(虚拟机上会触发)
  5）void onTrimMemory()
  内存清理时触发
  
  ### 1.2 实例展示
  ```
  public class MyApplication extends Application {
  
      private static String TAG = "MyApplication";
  
      @Override
      public void onCreate() {
          // 程序创建的时候执行
          KLog.d(TAG, "onCreate");
          super.onCreate();
      }
  
      @Override
      public void onTerminate() {
          //程序终止的时候执行
          //当终止应用程序对象时调用，不保证一定被调用，意思是当程序被内核终止以便为其他应用程序释放资源，那
          //么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程
          KLog.d(TAG, "onTerminate");
          super.onTerminate();
      }
  
      @Override
      public void onLowMemory() {
          // 当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必
          // 要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。
          KLog.d(TAG, "onLowMemory");
          super.onLowMemory();
      }
  
      @Override
      public void onTrimMemory(int level) {
          // 程序在内存清理的时候执行
          KLog.d(TAG, "onTrimMemory");
          super.onTrimMemory(level);
      }
  
      @Override
      //配置改变时触发这个方法
      public void onConfigurationChanged(Configuration newConfig) {
          KLog.d(TAG, "onConfigurationChanged");
          super.onConfigurationChanged(newConfig);
      }
  
  }
  ```
  ### 1.3 Android中什么是Context（★★★）
  Context字面意思是上下文，在Android中一个Activity就是一个Context,一个Service也是一个Context,可以Context抽象为**场景**，认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。
  ![a3592b88.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\efd63e31.png)
  在应用程序中Context的具体实现子类就是：Activity，Service，Applicatio
  **Context数量=Activity数量+Service数量+1**。
  
  
  ## 2、Service
  
  ### 2.1 Service 概述
  Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。
  
  - 启动状态
  当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。
  
  - 绑定状态
  当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。
  
  ![ed2399e5.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\ed2399e5.png)
  
  ### 2.2 Service在清单文件中的声明
  Service在AndroidManifest.xml中的声明语法
  ```
  <service android:enabled=["true" | "false"]
      android:exported=["true" | "false"]
      android:icon="drawable resource"
      android:isolatedProcess=["true" | "false"]
      android:label="string resource"
      android:name="string"
      android:permission="string"
      android:process="string" >
      . . .
  </service>
  ```
  - android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。
  
  - android:name：对应Service类名
  - android:permission：是权限声明
  - android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。
  - android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。
  - android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。 
  
  ### 2.3 Service启动服务
  首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。在实现中，我们需要重写一些回调方法，以处理服务生命周期的某些关键过程.
  ```
  package com.zejian.ipctest.service;
  
  import android.app.Service;a'd'b
  import android.content.Intent;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  
  public class SimpleService extends Service {
  
      /**
       * 绑定服务时才会调用
       * 必须要实现的方法  
       * @param intent
       * @return
       */
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return null;
      }
  
      /**
       * 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。
       * 如果服务已在运行，则不会调用此方法。该方法只被调用一次
       */
      @Override
      public void onCreate() {
          System.out.println("onCreate invoke");
          super.onCreate();
      }
  
      /**
       * 每次通过startService()方法启动Service时都会被回调。
       * @param intent
       * @param flags
       * @param startId
       * @return
       */
      @Override
      public int onStartCommand(Intent intent, int flags, int startId) {
          System.out.println("onStartCommand invoke");
          return super.onStartCommand(intent, flags, startId);
      }
  
      /**
       * 服务销毁时的回调
       */
      @Override
      public void onDestroy() {
          System.out.println("onDestroy invoke");
          super.onDestroy();
      }
  }
  ```
  从上面的代码我们可以看出SimpleService继承了Service类，并重写了onBind方法，该方法是必须重写的，但是由于此时是startService()的服务，则该方法无须实现，返回null即可，只有在bindService()的情况下才需要实现该方法并返回一个IBinder的实现类（这个后面会详细说），接着重写了onCreate、onStartCommand、onDestroy三个主要的生命周期方法，关于这几个方法说明如下:
  - onBind()
  当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须返回 一个IBinder 接口的实现类，供客户端用来与服务进行通信。无论是startService状态还是bindService状态，此方法必须重写，但在startService状态的情况下直接返回 null。
  - onCreate()
  首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法，该方法只调用一次
  - onStartCommand()
  当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。）
  - onDestroy()
  当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等，这是服务接收的最后一个调用。
  
  ### 2.4 StartService Demo 
  ```
  package com.zejian.ipctest;
  
  import android.content.Intent;
  import android.os.Bundle;
  import android.support.v7.app.AppCompatActivity;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.service.SimpleService;
  
  public class MainActivity extends AppCompatActivity implements View.OnClickListener {
  
      private Button startBtn;
      private Button stopBtn;
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          startBtn= (Button) findViewById(R.id.startService);
          stopBtn= (Button) findViewById(R.id.stopService);
          startBtn.setOnClickListener(this);
          assert stopBtn != null;
          stopBtn.setOnClickListener(this);
      }
  
      @Override
      public void onClick(View v) {
          Intent it=new Intent(this, SimpleService.class);
          switch (v.getId()){
              case R.id.startService:
                  startService(it);
                  break;
              case R.id.stopService:
                  stopService(it);
                  break;
          }
      }
  }
  ```
  ```
  <manifest ... >
    ...
    <application ... >
        <service android:name=".service.SimpleService" />
        ...
    </application>
  </manifest>
  ```
  
  从代码看出，启动服务使用startService(Intent intent)方法，仅需要传递一个Intent对象即可，在Intent对象中指定需要启动的服务。而使用startService()方法启动的服务，在服务的外部，必须使用stopService()方法停止，在服务的内部可以调用stopSelf()方法停止当前服务。如果使用startService()或者stopSelf()方法请求停止服务，系统会就会尽快销毁这个服务。**值得注意的是对于启动服务，一旦启动将与访问它的组件无任何关联，即使访问它的组件被销毁了，这个服务也一直运行下去，直到手动调用停止服务才被销毁。**
  
  ![20160930094006623.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\2d4a81e4.png)
  
  从Log可以看出，第一次调用startService方法时，onCreate方法、onStartCommand方法将依次被调用，(★★)**而多次调用startService时，只有onStartCommand方法被调用，最后我们调用stopService方法停止服务时onDestory方法被回调，这就是启动状态下Service的执行周期**。接着我们重新回过头来进一步分析onStartCommand（Intent intent, int flags, int startId），这个方法有3个传入参数，它们的含义如下：
  
  ### 2.5 onStartCommand 中参数的意义
  - intent 
  启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service
  - flags
  表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有
    - START_FLAG_REDELIVERY 
    这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。
    - START_FLAG_RETRY 
    该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。
  
  - startId
  指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。
  实际上onStartCommand的返回值int类型才是最最值得注意的，它有三种可选值， START_STICKY，START_NOT_STICKY，START_REDELIVER_INTENT
    - START_STICKY 
    当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。
    - START_NOT_STICKY
    当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务
    - START_REDELIVER_INTENT
    当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。
  
  
  ### 2.6 Service绑定服务
  绑定服务是Service的另一种变形，当Service处于绑定状态时，其代表着“客户端-服务器”中的服务器。
      情况1：需要从Activity组建中去调用Service中的方法。当其他组件（如 Activity）绑定到服务时，此时Activity以绑定的方式挂靠到Service后，就可以得到Service中的指定方法。
      情况2：组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应。
      情况3：可以通过绑定服务进行执行进程间通信 (即IPC，这个后面再单独分析)。
      **注意**
      与StartService不同的是BinderService的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说宿主(如Activity)销毁后，绑定服务就会被销毁。
  
  - 扩展Binder类
  如果服务是提供给自有应用专用的，并且Service(服务端)与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。 不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。
  - 使用Message
  Messenger可以翻译为信使，通过它可以在不同的进程中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。如果需要让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口，客户端就可利用 Message 对象向服务发送命令。同时客户端也可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。
  - 使用AIDL
  由于Messenger是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service仍然只能一个个处理，这也就是Messenger跨进程通信的缺点了，因此如果有大量并发请求，Messenger就会显得力不从心了，这时AIDL（Android 接口定义语言）就派上用场了， 但实际上Messenger 的跨进程方式其底层实现 就是AIDL，只不过android系统帮我们封装成透明的Messenger罢了，因此，如果我们想让服务同时处理多个请求，则应该使用 AIDL。
  
  ### 2.7 扩展Binder类
  如果我们的服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让客户端通过该类直接访问服务中的公共方法。其使用开发步骤如下
  - 创建BindService服务端，继承自Service并在类中，创建一个实现IBinder 接口的实例对象并提供公共方法给客户端调用
  - 从 onBind() 回调方法返回此 Binder 实例。
  - 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。
  **注意**
  此方式只有在客户端和服务位于同一应用和进程内才有效，如对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方式非常有效。
  另一点之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方式不执行任何跨进程编组。 
  
  ### 2.8 扩展Binder类Demo
  ```
  package com.zejian.ipctest.service;
  
  import android.app.Service;
  import android.content.Intent;
  import android.os.Binder;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  import android.util.Log;
  
  public class LocalService extends Service{
      private final static String TAG = "wzj";
      private int count;
      private boolean quit;
      private Thread thread;
      private LocalBinder binder = new LocalBinder();
  
      /**
       * 创建Binder对象，返回给客户端即Activity使用，提供数据交换的接口
       */
      public class LocalBinder extends Binder {
          // 声明一个方法，getService。（提供给客户端调用）
          LocalService getService() {
              // 返回当前对象LocalService,这样我们就可在客户端端调用Service的公共方法了
              return LocalService.this;
          }
      }
  
      /**
       * 把Binder类返回给客户端
       */
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return binder;
      }
  
  
      @Override
      public void onCreate() {
          super.onCreate();
          Log.i(TAG, "Service is invoke Created");
          thread = new Thread(new Runnable() {
              @Override
              public void run() {
                  // 每间隔一秒count加1 ，直到quit为true。
                  while (!quit) {
                      try {
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      count++;
                  }
              }
          });
          thread.start();
      }
  
      /**
       * 公共方法
       * @return
       */
      public int getCount(){
          return count;
      }
      /**
       * 解除绑定时调用
       * @return
       */
       @Override
      public boolean onUnbind(Intent intent) {
          Log.i(TAG, "Service is invoke onUnbind");
          return super.onUnbind(intent);
      }
  
      @Override
      public void onDestroy() {
          Log.i(TAG, "Service is invoke Destroyed");
          this.quit = true;
          super.onDestroy();
      }
  }
  ```
  BindService类继承自Service，在该类中创建了一个LocalBinder继承自Binder类，LocalBinder中声明了一个getService方法，客户端可访问该方法获取LocalService对象的实例，只要客户端获取到LocalService对象的实例就可调用LocalService服务端的公共方法，如getCount方法，值得注意的是，我们在onBind方法中返回了binder对象，该对象便是LocalBinder的具体实例，而binder对象最终会返回给客户端，客户端通过返回的binder对象便可以与服务端实现交互。接着看看客户端BindActivity的实现：
  ```
  package com.zejian.ipctest.service;
  
  import android.app.Activity;
  import android.app.Service;
  import android.content.ComponentName;
  import android.content.Intent;
  import android.content.ServiceConnection;
  import android.os.Bundle;
  import android.os.IBinder;
  import android.util.Log;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.R;
  
  public class BindActivity extends Activity {
      protected static final String TAG = "wzj";
      Button btnBind;
      Button btnUnBind;
      Button btnGetDatas;
      /**
       * ServiceConnection代表与服务的连接，它只有两个方法，
       * onServiceConnected和onServiceDisconnected，
       * 前者是在操作者在连接一个服务成功时被调用，而后者是在服务崩溃或被杀死导致的连接中断时被调用
       */
      private ServiceConnection conn;
      private LocalService mService;
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_bind);
          btnBind = (Button) findViewById(R.id.BindService);
          btnUnBind = (Button) findViewById(R.id.unBindService);
          btnGetDatas = (Button) findViewById(R.id.getServiceDatas);
          //创建绑定对象
          final Intent intent = new Intent(this, LocalService.class);
  
          // 开启绑定
          btnBind.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  Log.d(TAG, "绑定调用：bindService");
                  //调用绑定方法
                  bindService(intent, conn, Service.BIND_AUTO_CREATE);
              }
          });
          // 解除绑定
          btnUnBind.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  Log.d(TAG, "解除绑定调用：unbindService");
                  // 解除绑定
                  if(mService!=null) {
                      mService = null;
                      unbindService(conn);
                  }
              }
          });
  
          // 获取数据
          btnGetDatas.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  if (mService != null) {
                      // 通过绑定服务传递的Binder对象，获取Service暴露出来的数据
  
                      Log.d(TAG, "从服务端获取数据：" + mService.getCount());
                  } else {
  
                      Log.d(TAG, "还没绑定呢，先绑定,无法从服务端获取数据");
                  }
              }
          });
  
  
          conn = new ServiceConnection() {
              /**
               * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，
               * 通过这个IBinder对象，实现宿主和Service的交互。
               */
              @Override
              public void onServiceConnected(ComponentName name, IBinder service) {
                  Log.d(TAG, "绑定成功调用：onServiceConnected");
                  // 获取Binder
                  LocalService.LocalBinder binder = (LocalService.LocalBinder) service;
                  mService = binder.getService();
              }
              /**
               * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，
               * 例如内存的资源不足时这个方法才被自动调用。
               */
              @Override
              public void onServiceDisconnected(ComponentName name) {
                  mService=null;
              }
          };
      }
  }
  ```
  在客户端中我们创建了一个ServiceConnection对象，该代表与服务的连接，它只有两个方法， onServiceConnected和onServiceDisconnected.
  - onServiceConnected(ComponentName name, IBinder service) 
  系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。其中service便是服务端返回的IBinder实现类对象，通过该对象我们便可以调用获取LocalService实例对象，进而调用服务端的公共方法。而ComponentName是一个封装了组件(Activity, Service, BroadcastReceiver, or ContentProvider)信息的类，如包名，组件描述等信息，较少使用该参数。
  
  - onServiceDisconnected(ComponentName name) 
  **Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。注意:当客户端取消绑定时，系统“绝对不会”调用该方法。**
  
  在onServiceConnected()被回调前，我们还需先把当前Activity绑定到服务LocalService上，绑定服务是通过通过bindService()方法，解绑服务则使用unbindService()方法，
  - bindService(Intent service, ServiceConnection conn, int flags) 
  该方法执行绑定服务操作，其中Intent是我们要绑定的服务(也就是LocalService)的意图，而ServiceConnection代表与服务的连接，它只有两个方法，前面已分析过，flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建。
  - unbindService(ServiceConnection conn) 
  该方法执行解除绑定的操作，其中ServiceConnection代表与服务的连接，它只有两个方法，前面已分析过。
  
  Activity通过bindService()绑定到LocalService后，ServiceConnection#onServiceConnected()便会被回调并可以获取到LocalService实例对象mService，之后我们就可以调用LocalService服务端的公共方法了，最后还需要在清单文件中声明该Service。
  
  运行程序，点击绑定服务并多次点击绑定服务接着多次调用LocalService中的getCount()获取数据，最后调用解除绑定的方法移除服务，其结果如下： 
  ![20161003123125076.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\cc9b396a.png)
  
   通过Log可知，当我们第一次点击绑定服务时，LocalService服务端的onCreate()、onBind方法会依次被调用，此时客户端的ServiceConnection中onServiceConnected()被调用并返回LocalBinder对象，接着调用LocalBinder#getService方法返回LocalService实例对象，此时客户端便持有了LocalService的实例对象，也就可以任意调用LocalService类中的声明公共方法了。**更值得注意的是，我们多次调用bindService方法绑定LocalService服务端，而LocalService得onBind方法只调用了一次，那就是在第一次调用bindService时才会回调onBind方法。**接着我们点击获取服务端的数据，从Log中看出我们点击了3次通过getCount()获取了服务端的3个不同数据，最后点击解除绑定，此时LocalService的onUnBind、onDestroy方法依次被回调，并且多次绑定只需一次解绑即可。此情景也就说明了绑定状态下的Service生命周期方法的调用依次为onCreate()、onBind、onUnBind、onDestroy。
  
  #### 2.8.1 Bind使用总结
  - onBind只会调用一次.
  - onServiceDisconnected,系统在与服务的连接意外中断时调用该方法。注意:当客户端取消绑定时，系统“绝对不会”调用该方法。
  - BinderService会随着宿主的销毁而销毁。
  
  ### 2.9 使用Messenger
  前面了解了如何使用IBinder应用内同一进程的通信后，我们接着来了解服务与远程进程（即不同进程间）通信，而不同进程间的通信，最简单的方式就是使用 Messenger 服务提供通信接口，利用此方式，我们无需使用 AIDL 便可执行进程间通信 (IPC)。以下是 Messenger 使用的主要步骤：
  - 服务实现一个 Handler，由其接收来自客户端的每个调用的回调
  - Handler 用于创建 Messenger 对象（对 Handler 的引用）
  - Messenger 创建一个 IBinder，服务通过 onBind() 使其返回客户端
  - 客户端使用 IBinder 将 Messenger（引用服务的 Handler）实例化，然后使用Messenger将 Message 对象发送给服务
  - 服务在其 Handler 中（在 handleMessage() 方法中）接收每个 Message
  
  ### 2.10 使用Messenger接口Demo
  ```
  package com.zejian.ipctest.messenger;
  
  import android.app.Service;
  import android.content.Intent;
  import android.os.Handler;
  import android.os.IBinder;
  import android.os.Message;
  import android.os.Messenger;
  import android.util.Log;
  
  public class MessengerService extends Service {
  
      /** Command to the service to display a message */
      static final int MSG_SAY_HELLO = 1;
      private static final String TAG ="wzj" ;
  
      /**
       * 用于接收从客户端传递过来的数据
       */
      class IncomingHandler extends Handler {
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  case MSG_SAY_HELLO:
                      Log.i(TAG, "thanks,Service had receiver message from client!");
                      break;
                  default:
                      super.handleMessage(msg);
              }
          }
      }
  
      /**
       * 创建Messenger并传入Handler实例对象
       */
      final Messenger mMessenger = new Messenger(new IncomingHandler());
  
      /**
       * 当绑定Service时,该方法被调用,将通过mMessenger返回一个实现
       * IBinder接口的实例对象
       */
      @Override
      public IBinder onBind(Intent intent) {
          Log.i(TAG, "Service is invoke onBind");
          return mMessenger.getBinder();
      }
  }
  ```
  
  首先我们同样需要创建一个服务类MessengerService继承自Service，同时创建一个继承自Handler的IncomingHandler对象来接收客户端进程发送过来的消息并通过其handleMessage(Message msg)进行消息处理。接着通过IncomingHandler对象创建一个Messenger对象，该对象是与客户端交互的特殊对象，然后在Service的onBind中返回这个Messenger对象的底层Binder即可。
  ```
  package com.zejian.ipctest.messenger;
  
  import android.app.Activity;
  import android.content.ComponentName;
  import android.content.Context;
  import android.content.Intent;
  import android.content.ServiceConnection;
  import android.os.Bundle;
  import android.os.IBinder;
  import android.os.Message;
  import android.os.Messenger;
  import android.os.RemoteException;
  import android.util.Log;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.R;
  public class ActivityMessenger extends Activity {
      /**
       * 与服务端交互的Messenger
       */
      Messenger mService = null;
  
      /** Flag indicating whether we have called bind on the service. */
      boolean mBound;
  
      /**
       * 实现与服务端链接的对象
       */
      private ServiceConnection mConnection = new ServiceConnection() {
          public void onServiceConnected(ComponentName className, IBinder service) {
              /**
               * 通过服务端传递的IBinder对象,创建相应的Messenger
               * 通过该Messenger对象与服务端进行交互
               */
              mService = new Messenger(service);
              mBound = true;
          }
  
          public void onServiceDisconnected(ComponentName className) {
              // This is called when the connection with the service has been
              // unexpectedly disconnected -- that is, its process crashed.
              mService = null;
              mBound = false;
          }
      };
  
      public void sayHello(View v) {
          if (!mBound) return;
          // 创建与服务交互的消息实体Message
          Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
          try {
              //发送消息
              mService.send(msg);
          } catch (RemoteException e) {
              e.printStackTrace();
          }
      }
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_messenager);
          Button bindService= (Button) findViewById(R.id.bindService);
          Button unbindService= (Button) findViewById(R.id.unbindService);
          Button sendMsg= (Button) findViewById(R.id.sendMsgToService);
  
          bindService.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  Log.d("zj","onClick-->bindService");
                  //当前Activity绑定服务端
                  bindService(new Intent(ActivityMessenger.this, MessengerService.class), mConnection,
                          Context.BIND_AUTO_CREATE);
              }
          });
  
          //发送消息给服务端
          sendMsg.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  sayHello(v);
              }
          });
  
  
          unbindService.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  // Unbind from the service
                  if (mBound) {
                      Log.d("zj","onClick-->unbindService");
                      unbindService(mConnection);
                      mBound = false;
                  }
              }
          });
      }
  
  }
  ```
  在客户端进程中，我们需要创建一个ServiceConnection对象，该对象代表与服务端的链接，当调用bindService方法将当前Activity绑定到MessengerService时，onServiceConnected方法被调用，利用服务端传递给来的底层Binder对象构造出与服务端交互的Messenger对象，接着创建与服务交互的消息实体Message，将要发生的信息封装在Message中并通过Messenger实例对象发送给服务端。关于ServiceConnection、bindService方法、unbindService方法，前面已分析过，这里就不重复了，最后我们需要在清单文件声明Service和Activity，由于要测试不同进程的交互，则需要将Service放在单独的进程中，因此Service声明如下
  ```
  <service android:name=".messenger.MessengerService"
           android:process=":remote"
          />
  ```
  其中android:process=":remote"代表该Service在单独的进程中创建。
  接着多次点击绑定服务，然后发送信息给服务端，最后解除绑定，
  ![20161003162626563.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\1bd63ebb.png)
  
  通过上述例子可知Service服务端确实收到了客户端发送的信息，而且在Messenger中进行数据传递必须将数据封装到Message中，**因为Message和Messenger都实现了Parcelable接口，可以轻松跨进程传递数据，而Message可以传递的信息载体有，what,arg1,arg2,Bundle以及replyTo，至于object字段，对于同一进程中的数据传递确实很实用，但对于进程间的通信，则显得相当尴尬，在android2.2前，object不支持跨进程传输，但即便是android2.2之后也只能传递android系统提供的实现了Parcelable接口的对象，也就是说我们通过自定义实现Parcelable接口的对象无法通过object字段来传递，因此object字段的实用性在跨进程中也变得相当低了。不过所幸我们还有Bundle对象，Bundle可以支持大量的数据类型**。接着从Log我们也看出无论是使用拓展Binder类的实现方式还是使用Messenger的实现方式，它们的生命周期方法的调用顺序基本是一样的，即onCreate()、onBind、onUnBind、onDestroy，而且多次绑定中也只有第一次时才调用onBind()。
  
  ### 2.11 使用Message双向传递消息Demo
  在服务端，我们只需修改IncomingHandler，收到消息后，给客户端回复一条信息。
  ```
    /**
       * 用于接收从客户端传递过来的数据
       */
      class IncomingHandler extends Handler {
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  case MSG_SAY_HELLO:
                      Log.i(TAG, "thanks,Service had receiver message from client!");
                      //回复客户端信息,该对象由客户端传递过来
                      Messenger client=msg.replyTo;
                      //获取回复信息的消息实体
                      Message replyMsg=Message.obtain(null,MessengerService.MSG_SAY_HELLO);
                      Bundle bundle=new Bundle();
                      bundle.putString("reply","ok~,I had receiver message from you! ");
                      replyMsg.setData(bundle);
                      //向客户端发送消息
                      try {
                          client.send(replyMsg);
                      } catch (RemoteException e) {
                          e.printStackTrace();
                      }
  
                      break;
                  default:
                      super.handleMessage(msg);
              }
          }
      }
  ```
  接着修改客户端，为了接收服务端的回复，客户端也需要一个接收消息的Messenger和Handler，其实现如下：
  ```
    /**
       * 用于接收服务器返回的信息
       */
      private Messenger mRecevierReplyMsg= new Messenger(new ReceiverReplyMsgHandler());
  
  
      private static class ReceiverReplyMsgHandler extends Handler{
          private static final String TAG = "zj";
  
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  //接收服务端回复
                  case MessengerService.MSG_SAY_HELLO:
                      Log.i(TAG, "receiver message from service:"+msg.getData().getString("reply"));
                      break;
                  default:
                      super.handleMessage(msg);
              }
          }
      }
  ```
  除了添加以上代码，还需要在发送信息时把接收服务器端的回复的Messenger通过Message的replyTo参数传递给服务端，以便作为同学桥梁，
  ```
   public void sayHello(View v) {
          if (!mBound) return;
          // 创建与服务交互的消息实体Message
          Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
          //把接收服务器端的回复的Messenger通过Message的replyTo参数传递给服务端
          msg.replyTo=mRecevierReplyMsg;
          try {
              //发送消息
              mService.send(msg);
          } catch (RemoteException e) {
              e.printStackTrace();
          }
      }
  ```
  ![20161003173153947.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\239f7197.png)
  
  ### 2.12 关于绑定服务的注意点
  1. 多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 startService() 也启动了该服务）。
  
  2. 通常情况下我们应该在客户端生命周期（如Activity的生命周期）的引入 (bring-up) 和退出 (tear-down) 时刻设置绑定和取消绑定操作，以便控制绑定状态下的Service，一般有以下两种情况：
    - 如果只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。
    - 如果希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。需要注意的是，这意味着 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当提高该进程的权重时，系统很可能会终止该进程。
  
  3. **通常情况下(注意)，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，这样反复绑定与解绑是不合理的。此外，如果应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一次绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务，因此服务的绑定不应该发生在 Activity 的 onResume() 和 onPause()中。**
  
  4. 应用组件（客户端）可通过调用 bindService() 绑定到服务,Android 系统随后调用服务的 onBind() 方法，该方法返回用于与服务交互的 IBinder，而该绑定是异步执行的。
  
  
  ### 2.13 关于启动服务与绑定服务间的转换问题
  虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个Service创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个Service实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：
  
  - 先绑定服务后启动服务
  如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。
  
  - 先启动服务后绑定服务
  如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法抑或内存不足时才会销毁服务。
  
  以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论Service是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用Activity那样通过调用 Intent 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。
  
  
  ### 2.14 前台服务以及通知发送
  前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，状态栏位于“正在进行”标题下方，这意味着除非服务停止或从前台删除，否则不能清除通知。例如将从服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。如果需要设置服务运行于前台，Android官方给我们提供了两个方法，分别是startForeground()和stopForeground()。
  - startForeground(int id, Notification notification) 
  该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。
  
  - stopForeground(boolean removeNotification) 
  该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 
  但是，如果在服务正在前台运行时将其停止，则通知也会被删除。
  
  ### 2.15 前台服务通知Demo (Android8.0以后兼容有问题)
  [Android 8通过startService引起crash问题 - 王强博客 - 博客园](https://www.cnblogs.com/wangqiang9/p/10595417.html)
  ForegroundService代码实现:
  
  ```
  package com.zejian.ipctest.foregroundService;
  
  import android.app.Notification;
  import android.app.Service;
  import android.content.Intent;
  import android.graphics.BitmapFactory;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  import android.support.v4.app.NotificationCompat;
  
  import com.zejian.ipctest.R;
  
  /**
   * Created by zejian
   * Time 2016/10/4.
   * Description:启动前台服务Demo
   */
  public class ForegroundService extends Service {
  
      /**
       * id不可设置为0,否则不能设置为前台service
       */
      private static final int NOTIFICATION_DOWNLOAD_PROGRESS_ID = 0x0001;
  
      private boolean isRemove=false;//是否需要移除
  
      /**
       * Notification
       */
      public void createNotification(){
          //使用兼容版本
          NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
          //设置状态栏的通知图标
          builder.setSmallIcon(R.mipmap.ic_launcher);
          //设置通知栏横条的图标
          builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.screenflash_logo));
          //禁止用户点击删除按钮删除
          builder.setAutoCancel(false);
          //禁止滑动删除
          builder.setOngoing(true);
          //右上角的时间显示
          builder.setShowWhen(true);
          //设置通知栏的标题内容
          builder.setContentTitle("I am Foreground Service!!!");
          //创建通知
          Notification notification = builder.build();
          //设置为前台服务
          startForeground(NOTIFICATION_DOWNLOAD_PROGRESS_ID,notification);
      }
  
  
      @Override
      public int onStartCommand(Intent intent, int flags, int startId) {
          int i=intent.getExtras().getInt("cmd");
          if(i==0){
              if(!isRemove) {
                  createNotification();
              }
              isRemove=true;
          }else {
              //移除前台服务
              if (isRemove) {
                  stopForeground(true);
              }
              isRemove=false;
          }
  
          return super.onStartCommand(intent, flags, startId);
      }
  
      @Override
      public void onDestroy() {
          //移除前台服务
          if (isRemove) {
              stopForeground(true);
          }
          isRemove=false;
          super.onDestroy();
      }
  
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return null;
      }
  }
  ```
  在ForegroundService类中，创建了一个notification的通知，并通过启动Service时传递过来的参数判断是启动前台服务还是关闭前台服务，最后在onDestroy方法被调用时，也应该移除前台服务。以下是ForegroundActivity的实现：
  
  ```
  package com.zejian.ipctest.foregroundService;
  
  import android.app.Activity;
  import android.content.Intent;
  import android.os.Bundle;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.R;
  
  /**
   * Created by zejian
   * Time 2016/10/4.
   * Description:
   */
  public class ForegroundActivity extends Activity {
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_foreground);
          Button btnStart= (Button) findViewById(R.id.startForeground);
          Button btnStop= (Button) findViewById(R.id.stopForeground);
          final Intent intent = new Intent(this,ForegroundService.class);
  
  
          btnStart.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  intent.putExtra("cmd",0);//0,开启前台服务,1,关闭前台服务
                  startService(intent);
              }
          });
  
  
          btnStop.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  intent.putExtra("cmd",1);//0,开启前台服务,1,关闭前台服务
                  startService(intent);
              }
          });
      }
  }
  
  ```
  ### 2.16 保证服务不被杀死
  - 因内存资源不足而杀死Service 
  这种情况比较容易处理，可将onStartCommand() 方法的返回值设为 START_STICKY或START_REDELIVER_INTENT ，该值表示服务在内存资源紧张时被杀死后，在内存资源足够时再恢复。也可将Service设置为前台服务，这样就有比较高的优先级，在内存资源紧张时也不会被杀掉。
  
  - 用户通过 settings -> Apps -> Running -> Stop 方式杀死Service 
  这种情况是用户手动干预的，不过幸运的是这个过程会执行Service的生命周期，也就是onDestory方法会被调用，这时便可以在 onDestory() 中发送广播重新启动。这样杀死服务后会立即启动。这种方案是行得通的，但为程序更健全，我们可开启两个服务，相互监听，相互启动。服务A监听B的广播来启动B，服务B监听A的广播来启动A。
  ```
  package com.zejian.ipctest.neverKilledService;
  
  import android.app.Service;
  import android.content.BroadcastReceiver;
  import android.content.Context;
  import android.content.Intent;
  import android.content.IntentFilter;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  
  /**
   * Created by zejian
   * Time 2016/10/4.
   * Description:用户通过 settings -> Apps -> Running -> Stop 方式杀死Service
   */
  public class ServiceKilledByAppStop extends Service{
  
      private BroadcastReceiver mReceiver;
      private IntentFilter mIF;
  
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return null;
      }
  
      @Override
      public void onCreate() {
          super.onCreate();
          mReceiver = new BroadcastReceiver() {
              @Override
              public void onReceive(Context context, Intent intent) {
                  Intent a = new Intent(ServiceKilledByAppStop.this, ServiceKilledByAppStop.class);
                  startService(a);
              }
          };
          mIF = new IntentFilter();
          //自定义action
          mIF.addAction("com.restart.service");
          //注册广播接者
          registerReceiver(mReceiver, mIF);
      }
  
      @Override
      public void onDestroy() {
          super.onDestroy();
  
          Intent intent = new Intent();
          intent.setAction("com.restart.service");
          //发送广播
          sendBroadcast(intent);
  
          unregisterReceiver(mReceiver);
      }
  }
  ```
  - 用户通过 settings -> Apps -> Downloaded -> Force Stop 方式强制性杀死Service 
  
  ### 2.17 服务Service与线程Thread的区别
  - 两者概念的迥异
    - Thread 是程序执行的最小单元，它是分配CPU的基本单位，android系统中UI线程也是线程的一种，当然Thread还可以用于执行一些耗时异步的操作。
    - **Service是Android的一种机制**，**服务是运行在主线程上的，它是由系统进程托管**。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，**这种通信的载体是binder**，它是在linux层交换信息的一种IPC，而所谓的后台Service只不过是指没有UI的组件罢了。(把 Service 想象成一种消息服务)
  - 两者的执行任务迥异
    - 在android系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作。如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。
    - Service 则是android系统中的组件，一般情况下它运行于主线程中，因此在Service中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称Service为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让Service执行耗时任务，可在Service中开启单独线程去执行。
  - 两者使用场景
    - 当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程(Thread)，这样才能保证UI线程不被占用而影响用户体验。
    - 在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过Service+Notification方式在后台执行同时在通知栏显示着。
  - 两者的最佳使用方式
    在大部分情况下，Thread和Service都会结合着使用，比如下载文件，一般会通过Service在后台执行+Notification在通知栏显示+Thread异步下载，再如应用程序会维持一个Service来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个Thread与Service的结合来方便我们执行后台耗时任务，它就是IntentService，当然 IntentService并不适用于所有的场景，但它的优点是使用方便、代码简洁，**不需要我们创建Service实例并同时也创建线程**。
  
  ### 2.18 IntentService
  IntentService是一个抽象类，继承自Service，内部存在一个ServiceHandler（Handler）和HandlerThread（Thread）。
  IntentService是处理异步请求的一个类，在IntentService中有一个工作线程（HandlerThread）来处理耗时操作，启动IntentService的方式和普通的一样，不过当执行完任务之后，IntentService会自动停止。
  另外可以多次启动IntentService，每一个耗时操作都会以工作队列的形式在IntentService的onHandleIntent回调中执行，并且每次执行一个工作线程。
  **IntentService的本质是：封装了一个HandlerThread和Handler的异步框架**。
  
  **参考**
  [关于Android Service真正的完全详解，你需要知道的一切_zejian的博客-CSDN博客_android service](https://blog.csdn.net/javazejian/article/details/52709857)
  [](https://mp.weixin.qq.com/s/w1xiDiaOJTmxdcmQlCt0bg?)
  [【Android】Service前台服务的使用 - 简书](https://www.jianshu.com/p/5505390503fa)
  [【Android】跨进程通信——AIDL、之Service基本细节使用之：精通_虚妄狼的博客-CSDN博客_android service 跨进程](https://blog.csdn.net/qq_42470947/article/details/104088260)
  
  ### 2.19 在Service中启动Activity（★★）
  如果直接通过Intent的方式启动Activity，会报AndroidRuntimeException异常。
  
  ```
  Intent intent = new Intent(this,MainActivity.class);
  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);-----重要
  startActivity(intent);
  ```
  
  [Android 在Service中启动Activity的大坑_ZhangQiang_0的博客-CSDN博客](https://blog.csdn.net/zhangqiang_0/article/details/79566873)
  #### 2.19.1 解决这个异常后会出现问题？
  这样带来的问题就是在最近任务列表里面会出现两个相同的应用程序，比如你是在电话本里面启动的，那么最近任务列表就会出现两个电话本；因为有两个Task嘛！
  只要在新的Task里面的Activity里面配置android:excludeFromRecents=”true”就可以了。表示这个Activity不会显示在最近列表里面。
  
  ## 3、Fragment
  [Android-ReadTheFuckingSourceCode/02_fragment.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/basic/02_fragment.md)
  ### 3.1 Activity与Fragment生命周期（★★）
  
  ![0d0a189d.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\88518779.png)
  
  Activity 直接影响它所包含的 Fragment 的生命周期，所以对 Activity 的某个生命周期方法的调用也会产生对Fragment 相同方法的调用。例如：当 Activity 的 onPause() 方法被调用时，它所包含的所有的 Fragment 的onPause() 方法都会被调用。
  
  Fragment 比 Activity 还要多出几个生命周期回调方法，这些额外的方法是为了与 Activity 的交互，如下：
  - onAttach()
  当 Fragment 被加入到 Activity 时调用（在这个方法中可以获得所在的 Activity）。
  - onCreateView()
  当 Activity 要得到 Fragment 的 layout 时，调用此方法，Fragment 在其中创建自己的 layout (界面)。
  - onActivityCreated()
  当 Activity 的 onCreated() 方法返回后调用此方法。
  - onDestroyView()
  当 Fragment 的 layout 被销毁时被调用。
  - onDetach()
  当 Fragment 被从 Activity 中删掉时被调用。
  
  一旦 Activity 进入 resumed 状态（也就是 running 状态），你就可以自由地添加和删除 Fragment 了。因此，只有当 Activity 在 resumed 状态时，Fragment 的生命周期才能独立的运转，其它时候是依赖于 Activity 的生命周期变化的。
  
  ### 3.2 创建方式
  
  ####  3.2.1 静态创建(静态加载)
  首先我们需要创建一个xml文件，然后创建与之对应的java文件，通过onCreatView()的返回方法进行关联，最后我们需要在Activity中进行配置相关参数即在Activity的xml文件中放上fragment的位置。
  ```
   <fragment
          android:name="xxx.BlankFragment"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
      </fragment>
  ```
  #### 3.2.2 动态创建(动态加载)
  动态创建Fragment 主要有以下几个步骤：
  1. 创建待添加的fragment示例。
  2. 获取FragmentManager,在Activity中可以直接通过调用getSupportFramentManager()方法得到。
  3. 开启一个实务，通过调用beginTransaction()方法开启。
  4. 向内容内add fragment，需要传入容器的id和待添加的fragment实例。
  ```
  FragmentTransaction fragmentTransaction=fragmentManager.beginTransaction();
          hide(fragmentTransaction);
          if(i==0){
              if(fragment1==null){
                  fragment1=new Fragment1();
                  fragmentTransaction.add(R.id.framelayout,fragment1);
              }else {
                  fragmentTransaction.show(fragment1);
              }
          }
          if(i==1){
              if(fragment2==null){
                  fragment2=new Fragment2();
                  fragmentTransaction.add(R.id.framelayout,fragment2);
              }
              else {
                  fragmentTransaction.show(fragment2);
              }
          }
          fragmentTransaction.commit();
  
  ```
  5. 提交事务，调用commit()方法来完成。
  
  ### 3.3 Adapter对比 (ViewPage与Adapter使用)
  FragmentPageAdapter
  在每次切换页面时，只是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响。
  FragmentPageStateAdapter
  继承子 pager。该 PagerAdapter 的实现将只保留当前页面，当页面不在当前显示的时候，页面会清理，释放其资源。而在页面需要显示时，生成新的页面，重新生成数据。这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存。
  
  ### 3.4 Fragment与Activity通信
  
  #### 3.4.1 Activity向Fragment传值
  1. 第一种 handle方案
  activity响应事件，发送msg，到fragment中，而fragment中用来接收msg，所以用注册Handler对象，activity中发送msg的对象与fragment中handler对象必须为同一个（handler，msgqueen和looper相互唯一绑定），所以要在activity中暴露pubilic方法让fragment的acttch周期中传递handler。
  
  activity的响应事件发送msg：
  ```
  tvMain.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  //如果是activity相应事件，发送msg
                  if(handler == null){
                      return;
                  }
                  Message message = new Message();
                  Bundle bundle = new Bundle();
                  bundle.putString("hehe","我是activity发送的msg");
                  message.setData(bundle);
                  handler.sendMessage(message);
              }
          });
  ```
  activity中暴露的setHandler方法：
  ```
   //activity暴露方法来给fragment来设置
      public void setHandler(Handler handler){
          this.handler = handler;
      }
  ```
  fragment中传递handler：
  ```
  @Override
      public void onAttach(Context context) {
          super.onAttach(context);
          MainActivity activity = (MainActivity) getActivity();
          activity.setHandler(mHandler);
      }
  ```
  fragment注册handler用来接收msg：
  ```
  private Handler mHandler = new Handler(){
  
          @Override
          public void handleMessage(Message msg) {
              super.handleMessage(msg);
  
              Bundle bundle = msg.getData();
              strHandler = bundle.getString("hehe");
              textView.setText(strHandler+TwoFragment.class.getName());
          }
      };
  ```
  - fragment向activity传递消息同样可以利用此方法
  - Fragment对具体的activity存在耦合比较高，不利于Fragment复用，不利于维护。
  
  2. 第二种 Bundle方案
    1) Fragment动态加载的状态
    (Fragment是动态加载的)在activity中建一个bundle，把要传的值存入bundle，然后通过fragment的setArguments（bundle）传到fragment，在fragment中，用getArguments接收
  Activity:
  ```
  MyFragment fragment = new MyFragment();
  	Bundle bundle=new Bundle();
      bundle.putString("one","要传的值");
      fragment.setArguments(bundle);
      FragmentManager fm = getFragmentManager();
  	FragmentTransaction ft=fm.beginTransaction();
  	ft.add(R.id.frame,myFragment,"myFragment");
      ft.commit();
  ```
  Fragment:
  ```
  Bundle bundle=getArguments();
  String s=bundle.getString("one");
  ```
    2) Fragment静态加载的状态
  (Fragment是静态加载的)在Fragment中设置set,get方法，在activity中获取Fragment对象，fragment.setValue(),Fragment中getValue()
  注：静态加载Fragment的时候，一定要给Fragment设置一个唯一标识，id/tag
  
  activity：
  ```
  FragmentManager fm = getFragmentManager();
  MyFragment myFragment = (MyFragment)fm.findFragmentById(R.id.fragment);
  myFragment.setValue("传值");
  ```
  Fragment：
  ```
  	private String value;
  
  	private void setValue(String value){
  		this.value = value;
  	}
  
  	private String getValue(){
  		return this.value;
  	}
  
  //在需要获取的地方调用getValue()
  	@Nullable
      @Override
      public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
          View v=inflater.inflate(R.layout.fragment,null);
          // 给fragment上的按钮添加点击事件
          text = v.findViewById(R.id.tv_show);
          btn = v.findViewById(R.id.btn_get);
          btn.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
  				 text.setText(getValue());
              }
          });
          return v;
      }
  ```
  #### 3.4.2 Fragment向Activity传值
  1. 第一种 广播 方案
  在fragment中发送广播，在activity中注册广播接收者，并作出相应逻辑。
  在fragment中发送广播信息：
  ```
  button.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  //发送广播
                  Intent intent = new Intent();
                  intent.setAction("co.daggertest.fragment.ThreeFragment");
                  intent.putExtra("heihei","fragment发送广播");
                  //使用的本地广播，用于单个app内通信，性能和安全性好点
                  LocalBroadcastManager.getInstance(getActivity()).sendBroadcast(intent);
              }
          });
  ```
  在activity中注册广播：
  ```
    //注册本地广播接收者
          myBroadcast = new MyBroadcast();
          IntentFilter intentFilter = new IntentFilter();
          intentFilter.addAction("co.daggertest.fragment.ThreeFragment");
          LocalBroadcastManager.getInstance(this).registerReceiver(myBroadcast,intentFilter);
  ```
  ```
      内部类创建实例
   class MyBroadcast extends BroadcastReceiver{
  
          @Override
          public void onReceive(Context context, Intent intent) {
              heihei = intent.getStringExtra("heihei");
              tvMain.setText(heihei+MainActivity.class.getName());
  
          }
      }
  ```
  在activity的onDestory中注销广播：
  ```
  @Override
      protected void onDestroy() {
          super.onDestroy();
          LocalBroadcastManager.getInstance(this).unregisterReceiver(myBroadcast);
      }
  ```
  2. 第二种 回调接口 方案
  在fragment中创建接口，activity实现接口中方法，完成回调和参数传递。
  创建接口：
  ```
  public interface FourMainActivity{
          void changerSomething(String msg);
      }
  ```
  绑定activity：
  ```
   @Override
      public void onAttach(Context context) {
          super.onAttach(context);
          fourMainActivity = (FourMainActivity) context;
      }
  ```
  设置监听回调：
  ```
  button.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  fourMainActivity.changerSomething("我是通过接口传递到MainActivity中");
              }
          });
  ```
  activity实现接口：
  ```
  public class MainActivity extends AppCompatActivity implements FourFragment.FourMainActivity
  ```
  实现接口方法：
  ```
  @Override
      public void changerSomething(String msg) {
          tvMain.setText(msg);
      }
  ```
  
  #### 3.4.3 Fragment与Fragment 之间是如何传值的
  
  1. 第一种 实现接口（中间依赖Activity） 方案
  [A_activity_Two_fragment· GitHub](https://github.com/wanglianghai/A_activity_Two_fragment/commit/3d591c6286bc57667d341f7a96d46bd2f2f8a3fb?diff=unified)
  [同一个Activity托管的两个Fragment之间的数据交互 - 简书](https://www.jianshu.com/p/dd6376cf1f9d)
  [在同一个Activity下实现两个Fragment之间的通信 - 简书](https://www.jianshu.com/p/bf923a23358c)
  
  2. 第二种 EventBus 方案 
  [EventBus使用详解_cyc的专栏-CSDN博客_eventbus](https://blog.csdn.net/u012317510/article/details/78935720)
  
  **参考**
  [Fragment与Activity之间的传值_Silence_Sep的博客-CSDN博客_fragment向activity传递数据](https://blog.csdn.net/Silence_Sep/article/details/86572297)
  [fragment通信的几种方式（接口框架）_HUandroid的博客-CSDN博客_fragmeng通信](https://blog.csdn.net/HUandroid/article/details/79481363)
  
  ### 3.5 API的区别
  1. add
  一种是add方式来进行show和add,这种方式你切换fragment不会让frament重新刷新，只会调用onHiddenChange(boolean isHidden)
  2. replace
  而用replace方式会使fragment重新刷新，因为add方式是将fragment隐藏了而不是销毁再创建，replace方式每次都是重新重建。
  3. commit/commitAllowingStateLoss 
  [Android commit 和 commitAllowingStateLoss 的区别 - 简书](https://www.jianshu.com/p/83e673c453f9)
  两者都可以提交fragment的操作，唯一的不同是第二种方法，在Activity和FragmentActivity内的onSaveInstanceState方法保存了fragment的状态。在onSaveInstanceState方法后调用commit和commitAllowingStateLoss会引起一种问题：因内存不足而把不显示在前台的activity(带有 fragment)销毁，之后用户再回到此 activity 页面时，是会丢失在onSaveInstanceState后调用commit方法提交的页面状态信息!不同的只是调用commit会报错，调用commitAllowingStateLoss不报错
  
  ### 3.6 懒加载(解决预加载问题)
  经常在使用fragment时，常常会结合着viewpager使用，那么就会遇到一个问题，就是初始化fragment的时候，会连同网络请求一起执行，这样非常消耗性能，最理想的方式是，只有用户点开或滑动到当前fragment时，才进行请求网络的操作。因此，我们就产生了懒加载这样一个说法。
  
  在Viewpager与fragment使用时，默认加载前两个fragment。这样很容易造成网络丢包，阻塞等问题。
  
  最好的解决的问题的方法，重写Fragment的setUserVisibleHint()方法，实现Fragment内部的懒加载机制。
  
  由于setUserVisibleHint这个方法优于onCreate()，onCreateView()方法，它会通过isVisiBleToUser告诉我们当前Fragment我们是否可见，当可见时候再进行网络加载。但是如果在setUserVisibleHint()要实现懒加载的话，就必须要确保View 以及其他变量都已经初始化结束，避免空指针。
  
  [Fragment的懒加载](https://blog.csdn.net/u011315960/article/details/71404177)
  
  ## 4、Activity 
  ### 4.1 点击Launcher图标来启动Activity （★★★★★）
  用户从Launcher程序点击应用图标可启动应用的入口Activity，Activity启动时需要多个进程之间的交互，Android系统中有一个zygote进程专用于孵化Android框架层和应用层程序的进程。还有一个system_server进程，该进程里运行了很多binder service。例如ActivityManagerService，PackageManagerService，WindowManagerService，这些binder service分别运行在不同的线程中，其中ActivityManagerService负责管理Activity栈，应用进程，task。
  
  用户在Launcher程序里点击应用图标时，会通知ActivityManagerService启动应用的入口Activity，ActivityManagerService发现这个应用还未启动，则会通知Zygote进程孵化出应用进程，然后在这个dalvik应用进程里执行ActivityThread的main方法。应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法。
  
  ### 4.2 Activity生命周期
  ![16bff4353c5b177c.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\51da952a.png)
  
  #### 4.2.1 Activity的形态
  **Active/Running:** 
  Activity处于活动状态，此时Activity处于栈顶，是可见状态，可与用户进行交互
  
  **Paused:**
  当Activity失去焦点时，或被一个新的非全屏的Activity，或被一个透明的Activity放置在栈顶时，Activity就转化为Paused状态。但我们需要明白，此时Activity只是失去了与用户交互的能力，其所有的状态信息及其成员变量都还存在，只有在系统内存紧张的情况下，才有可能被系统回收掉。
  
  **Stopped:**
  当一个Activity被另一个Activity完全覆盖时，被覆盖的Activity就会进入Stopped状态，此时它不再可见，但是跟Paused状态一样保持着其所有状态信息及其成员变量。
  
  **Killed:**
  当Activity被系统回收掉时，Activity就处于Killed状态。
  
  #### 4.2.2 Activity的生命周期
  所谓的典型的生命周期就是在有用户参与的情况下，Activity经历从创建，运行，停止，销毁等正常的生命周期过程。
  
  **onCreate**
  该方法是在Activity被创建时回调，它是生命周期第一个调用的方法，我们在创建Activity时一般都需要重写该方法，然后在该方法中做一些初始化的操作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。
  
  **onStart**
  此方法被回调时表示Activity正在启动，此时Activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。可以简单理解为Activity已显示而我们无法看见摆了。
  
  **onResume**
  当此方法回调时，则说明Activity已在前台可见，可与用户交互了（处于前面所说的Active/Running形态），onResume方法与onStart的相同点是两者都表示Activity可见，只不过onStart回调时Activity还是后台无法与用户交互，而onResume则已显示在前台，可与用户交互。从流程图可以看出当Activity停止后（onPause方法和onStop方法被调用），重新回到前台时也会调用onResume方法，因此在onResume方法中初始化一些资源，然后在onPause或者onStop方法中释放的资源。
  
  **onPause**
  此方法被回调时则表示Activity正在停止（Paused形态），一般情况下onStop方法会紧接着被回调。但通过流程图看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象，这可能是用户操作使当前Activity退居后台后又迅速地再回到到当前的Activity，此时onResume方法就会被回调。
  当然，在onPause方法中可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示,而onPause方法执行完成后，新Activity的onResume方法才会被执行。
  
  **onStop**
  一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖（Stopped形态），此时Activity不可见，仅在后台运行。同样地，在onStop方法可以做一些资源释放的操作（不能太耗时）。
  
  **onRestart**
  表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。
  
  **onDestroy**
  此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。
  
  1) 当Activity启动时，依次会调用onCreate(),onStart(),onResume()，
  2) 当Activity退居后台时（不可见，点击Home或者被新的Activity完全覆盖），onPause()和onStop()会依次被调用。
  3) 当Activity退居后台且系统内存不足， 系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走onCreate()-->onStart()--->onResume()
  4) 当Activity返回前台（从桌面回到原Activity或者被覆盖后又回到原Activity）时，onRestart()，onStart()，onResume()会依次被调用。
  5) 当Activity退出销毁时（点击back键），onPause()，onStop()，onDestroy()会依次被调用，到此Activity的整个生命周期方法回调完成。
  6) 锁定屏与解锁屏幕 只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()
  7) 两个Activity之间切换: Activity A 启动另一个Activity B，回调如下:Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop();如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop；
  
  **注意**
  1. 透明主题对生命周期的影响
    当A-Activity启动B-Activity时，并且启动之后A-Activity还处于部分可见状态，当启动完B之后并不回调A的onStop()方法。
  [Activity A启动Activity B它们的生命周期变化（及设置Activity的透明度）_YoungForYou-CSDN博客_activitya启动activityb生命周期](https://blog.csdn.net/weixin_43589682/article/details/97030740)
  2. 屏幕旋转,屏幕大小改,键盘发生了改变,键盘的可用性发生了改变对生命周期的影响
  
  没有配置 configChanges：
  ```
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onResume()
  A: ==> onPause()
  A: ==> onSaveInstanceState()
  A: ==> onStop()
  A: ==> onDestroy()
  屏幕旋转后
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onRestoreInstanceState()
  A: ==> onResume()
  ```
  配置 configChanges 后：android:configChanges="keyboard|orientation|screenSize|keyboardHidden"
  ```
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onResume()
  A: ==> onConfigurationChanged()
  ```
  
  #### 4.2.3 保存与恢复 onSaveInstanceState() onRestoreInstanceState()  （★★）
  1. onSaveInstanceState()
  (1)、当用户按下HOME键时。会调用 onSaveInstanceState() 方法
  (2)、长按HOME键，选择运行其他的程序时。会调用 onSaveInstanceState() 方法 
  (3)、按下电源按键（关闭屏幕显示）时。会调用 onSaveInstanceState() 方法
  (4)、从activity A中启动一个新的activity时。会调用 onSaveInstanceState() 方法
  (5)、屏幕方向切换时，例如从竖屏切换到横屏时。会调用 onSaveInstanceState() ,onRestoreInstanceState()方法
  
  2. onRestoreInstanceState()
  onRestoreInstanceState()被调用的前提是，activity A“确实”被系统销毁了。
  
  3. 屏幕旋转测试
  android:screenOrientation="portrait"
  去掉，支持转屏。然后就一定会触发onSaveInstanceState()和onRestoreInstanceState()。
  因为当 Activity 横竖屏切换的时候会重新走一遍生命周期，所以 Activity 会被销毁创建，由此会执行 onRestoreInstanceState() 方法。
  
  4. 保存Activity状态
  当Activity开始停止时，系统会调用，onSaveInstanceState()以便您的Activity可以使用一组键值对来保存状态信息。此方法的默认实现保存有关Activity视图层次结构状态的信息，例如EditText小部件中的文本或ListView的滚动位置。
  为了保存Activity的附加状态信息，您必须实现onSaveInstanceState()并向对象添加键值对Bundle
  ```
  static final String STATE_SCORE = "playerScore";
  static final String STATE_LEVEL = "playerLevel";
  ...
  
  @Override
  public void onSaveInstanceState(Bundle savedInstanceState) {
      // 保存用户自定义的状态
      savedInstanceState.putInt(STATE_SCORE, mCurrentScore);
      savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);
      
      // 调用父类交给系统处理，这样系统能保存视图层次结构状态
      super.onSaveInstanceState(savedInstanceState);
  }
  ```
  
  5. 恢复Activity状态
  当Activity在之前被破坏后重新创建时，您可以从Bundle系统通过您的Activity中恢复您的保存状态。这两个方法onCreate()和onRestoreInstanceState()回调方法都会收到Bundle包含实例状态信息的相同方法。
  
  因为onCreate()调用该方法是否系统正在创建一个新的Activity实例或重新创建一个以前的实例，所以必须Bundle在尝试读取之前检查该状态是否为空。如果它为空，那么系统正在创建一个Activity的新实例，而不是恢复之前被销毁的实例。
  ```
  @Override
  protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState); // 记得总是调用父类
     
      // 检查是否正在重新创建一个以前销毁的实例
      if (savedInstanceState != null) {
          // 从已保存状态恢复成员的值
          mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
          mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
      } else {
          // 可能初始化一个新实例的默认值的成员
      }
      ...
  }
  ```
  onCreate()可以选择执行onRestoreInstanceState()，而不是在系统调用onStart()方法之后恢复状态。系统onRestoreInstanceState()只有在存在保存状态的情况下才会恢复，因此您不需要检查是否Bundle为空：
  ```
  public void onRestoreInstanceState(Bundle savedInstanceState) {
      // 总是调用超类，以便它可以恢复视图层次超级
      super.onRestoreInstanceState(savedInstanceState);
     
      // 从已保存的实例中恢复状态成员
      mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
      mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
  }
  ```
  
  ### 4.3 启动模式 （★★★★）
  #### 4.3.1 standard
  ![20160723152327677.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\22397131.png)
  
  标准模式是系统的默认模式（可以不指定），在这样模式下，每启动一个Activity都会重新创建一个Activity的新实例，并且将其加入任务栈中，而且完全不会去考虑这个实例是否已存在。
  
  #### 4.3.2 singleTop
  ![20160723155025823.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\ec26731d.png)
  栈顶复用模式,在这种模式下，如果有新的Activity已经存在任务栈的栈顶，那么此Activity就不会被重新创建新实例，而是复用已存在任务栈栈顶的Activity。此时Activity的onCreate、onStart方法不会被调用，会调用onNewIntent方法因为Activity并没有被重建。
  调用onNewIntent的生命周期：
  onCreate--->onStart--->onResume---onPause--->onNewIntent--->onResume
  
  ![20160723155032885.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\5b936102.png)
  如果新的Activity的实例已存在但没有位于栈顶，那么新的Activity仍然会被重建。
  
  #### 4.3.3 singleTask
  ![20160723162300494.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\1d4703c5.png)
  1. 只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在不在栈顶，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。若存在在栈顶，会调用onNewIntent方法。
  
  2. 如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。
  
  #### 4.3.4 singleInstance
  ![20160723180108411.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\1ec24d5e.png)
  只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。
  例如，ActivityA->ActivityB(SingleInstance)->ActivityC 点击Back退出顺序：结果为C-》A-》B
  原因：singleInstance模式是存在于另一个任务栈中的。也就是说ActivityA和ActivityC是处于同一个任务栈中的，ActivityB则是存在另个栈中。
  所以当关闭了ActivityC的时候，先去找当前任务栈存在的activity。当前的activity都finish了之后，才会去找另一个任务栈中的activity。
  解决方法是：在ActivityB定义一个全局变量，在onCreate方法将returnActivityB=true;
  然后在ActivityA界面onStart方法里判断returnActivityB是否为true，是的话就跳转到ActivityB，同时将returnActivityB=false;
  
  调用onNewIntent的生命周期：
  onPause--->跳转其它页面--->onCreate--->onStart--->onResume---onPause--->跳转A--->onNewIntent--->onRestart--->onStart--->onResume
  
  
  #### 4.3.5 启动模式参考文献
  [Activity启动模式与任务栈(Task)全面深入记录（下）_zejian的博客-CSDN博客_22activitytask](https://blog.csdn.net/javazejian/article/details/52072131)
  [Activity启动模式与任务栈(Task)全面深入记录（上）_zejian的博客-CSDN博客_任务栈的合并](https://blog.csdn.net/javazejian/article/details/52071885)
  [Activity SingleInstance启动模式 - javakam - 博客园](https://www.cnblogs.com/jooy/p/9494165.html)
  [SingleTask和SingleInstance详解_ywj2167917的专栏-CSDN博客_singletask和singleinstance](https://blog.csdn.net/ywj2167917/article/details/8827830)
  [singleTask启动模式引发的问题和感悟 - 简书](https://www.jianshu.com/p/fe98ae8e3fb4)
  
  ### 4.4 Task任务栈 （★★）
  - android任务栈又称为Task，它是一个栈结构，具有后进先出的特性，用于存放我们的Activity组件
  - 我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity组件，因此一个任务栈包含了一个activity的集合, android系统可以通过Task有序地管理每个activity，并决定哪个Activity与用户进行交互:只有在任务栈栈顶的activity才可以跟用户进行交互。 
  - 在退出应用程序时，必须把所有的任务栈中所有的activity清除出栈时,任务栈才会被销毁。当然任务栈也可以移动到后台, 并且保留了每一个activity的状态. 可以有序的给用户列出它们的任务, 同时也不会丢失Activity的状态信息。
  - 一个App中可能不止一个任务栈，某些特殊情况下，单独一个Actvity可以独享一个任务栈。
  - 一个Task中的Actvity可以来自不同的App，同一个App的Activity也可能不在一个Task中。
  
  ### 4.5 Intent类
  Intent 分两种，显式 Intent 和隐式 Intent。 
  #### 4.5.1 显式Intent
  如果一个 Intent 明确指定了要启动的组件的完整类名，那么这个 Intent 就是显式 Intent.
  ```
  Intent intent = new Intent(this, xxx.class);
  startActivity(intent);
  ```
  
  #### 4.5.2 隐式Intent
  [Android的进阶学习(三)--Intent和IntentFilter - 简书](https://www.jianshu.com/p/a2f826064e29)
  [IntentFilter匹配规则详解 - 天涯海角路 - 博客园](https://www.cnblogs.com/aademeng/articles/11026731.html)
  IntentFilter(意图过滤器),当隐式启动系统组件的时候，就会根据IntentFilter来筛选出合适的进行启动。
  在Intent启动的时候对应设置Action、Category、DataAndType，这里设置的是为了过滤的时候对应IntentFilter匹配action、category、data。
  除过滤广播的的IntentFilter可以在代码中创建外，其它的IntentFilter都得在AndroidManifest.xml中给设置。
  
  ```
  Intent  intent = new Intent();
  intent.addAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.addDataType("video/mpeg");
  ```
  AndroidManifest.xml 设置
  ```
  <activity  android:name=".Activity_B"    
             android:label="@string/title_activity_activity__b"
             android:launchMode="singleInstance">  
    <intent-filter> 
      <action android:name="android.intent.action.ANSWER" />    
      <category android:name="android.intent.category.APP_EMAIL" />        
      <data  android:host="www.mathiasluo.com"   
             android:scheme="http" />  
    </intent-filter>
  </activity>
  ```
  一个组件可以有多个IntentFilter，在过滤的时候只要有一组符合要求的，就会被视为过滤通过。
  
  1) action匹配
  action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同
  2) category匹配
  如果Intent中的存在category那么所有的category都必须和IntentFilter中的category相同。才能和这个Activity匹配。
  Intent中的category数量可能少于IntentFilter中的category数量，但是Intent中category必须和IntentFilter中的category相同才能匹配。
  3) data匹配
  如果IntentFilter中有定义data，那么Intent中也必须也要定义date
  4) 隐式启动的判断
  判断隐式启动的Intent是否能找到相应的组件方法
  <一>
  ```
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.setDataAndType(Uri.EMPTY, "video/mpeg");
  PackageManager packageManager = getPackageManager();
  List<ResolveInfo> infoList = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
  Log.i(TAG, infoList.size() + "");
  if (infoList.size() != 0) {  
    startActivity(intent);
  } else { 
     Log.e(TAG, "没有匹配到Activity");
  }
  ```
  <二>
  ```
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.setDataAndType(Uri.EMPTY, "video/mpeg");
  ComponentName name =  intent.resolveActivity(getPackageManager());
  if (name != null){
      startActivity(intent);
  }else {
      Log.e(TAG,"没有匹配到Activity");
  }
  ```
  
  **注意**
  1. 如果 intent-filter 中没有包含任何Action类型，那么无论什么Intent请求都无法和这条 nintent-filter 匹配。
  2. 如果Intent请求中没有设定Action类型，那么只要 intent-filter 中包含有Action类型，这个Intent请求就将顺利地通过 intent-filter 的行为测试。
  3. intent中可以不存在category，但如果存在就必须匹配intent-filter其中一个
  4. 系统在startActivity或者startActivityForResult的时候默认为Intent加上一个android.intent.category.DEAFAULT，所以必须在intent-filter中加上android.intent.category.DEFAULT这个category
  
  ### 4.6 URL Scheme
  Android 中的 Scheme 是一种页面内跳转协议，是一种非常好的实现机制。通过定义自己的 Scheme 协议，可以非常方便跳转 App 中的各个页面。
  #### 4.6.1 使用场景
  通过小程序，利用 Scheme 协议打开原生 App。
  - H5 页面点击锚点，根据锚点具体跳转路径 App 端跳转具体的页面。
  - App 端收到服务器端下发的 Push 通知栏消息，根据消息的点击跳转路径跳转相关页面。
  - App 根据URL跳转到另外一个 App 指定页面。
  - 通过短信息中的 URL 打开原生 App。
  
  #### 4.6.2 Scheme 路径的规则
  ```
  <scheme> :// <host> : <port> [<path>|<pathPrefix>|<pathPattern>]
  ```
  #### 4.6.3 设置Scheme
  在 AndroidManifest.xml 中对标签增加设置 Scheme。
  ```
  <activity
      android:name=".ui.activity.SchemeActivity"
      android:screenOrientation="portrait">
      <!--Android 接收外部跳转过滤器-->
      <!--要想在别的 App 上能成功调起 App，必须添加 intent 过滤器-->
      <intent-filter>
          <!--协议部分配置，注意需要跟 web 配置相同-->
          <!--协议部分，随便设置 aa://bb:1024/from?type=jeanboy-->
          <data android:scheme="aa"
              android:host="bb"
              android:port="1024"
              android:path="/from"/>
          <!--下面这几行也必须得设置-->
          <category android:name="android.intent.category.DEFAULT" />
          <!--表示 Activity 允许通过网络浏览器启动，以显示链接方式引用，如图像或电子邮件-->
          <category android:name="android.intent.category.BROWSABLE" />
          <action android:name="android.intent.action.VIEW" />
      </intent-filter>
  </activity>
  ```
  #### 4.6.4 原生调用
  ```
  Uri uri = Uri.parse("aa://bb:1024/from?type=jeanboy");
  Intent intent = new Intent(Intent.ACTION_VIEW, uri);
  startActivity(intent);
  ```
  #### 4.6.5 网页调用
  ```
  <a href="aa://bb:1024/from?type=jeanboy">打开 App</a>
  ```
  #### 4.6.6 在Activity中处理Scheme跳转
  ```
  public class SchemeActivity extends AppCompatActivity {
  
      @Override
      protected void onCreate(@Nullable Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          Uri uri = getIntent().getData();
          if (uri != null) {
              //获取指定参数值
              String type = uri.getQueryParameter("type");
              Log.e("SchemeActivity", "type:" + type);
  
              if(type.equals("jeanboy")){
                  ActivityUtils.startActivity(XXXActivity.class);
              }else if(type.equals("main")){
                  ActivityUtils.startActivity(MainActivity.class);
              }
          }
          finish();
      }
  }
  ```
  
  ### 4.7 Android横竖瓶切换Activity生命周期 （★★）
  关于Android横竖屏切换Activity是否会销毁重建，这个由Activity的configChanges属性控制。当一个配置改变时Activity默认会销毁重建，但是如果这个属性声明了此项配置后，Activit就不会销毁重建，而是回调Activity的onConfigurationChanged方法。
  
  configChanges的可配置属性如下：
  | 值 | 描述 | 
  | :-----: | :------- | 
  | mcc | 默认值，系统自动选择屏幕方向  | 
  | mnc | 跟activity堆栈中的下面一个activity的方向一致  |  
  | locale | 横屏方向，显示的宽比高长  |
  | keyboard | 竖屏方向，显示的高比宽长  | 
  | keyboardHidden |  由设备的屋里方向传感器决定，如果用户旋转设备，屏幕就会横竖屏切换  |
  | screenLayout |  忽略物理方向传感器，这样就不会随着用户旋转设备而横竖屏切换了（"unspecified"设置除外）|
  | orientation | 用户当前首选的方向|
  | screenSize |API 9 以上，反向横屏|
  | smallestScreenSize |API 9 以上，反向竖屏|
  | layoutDirection |API 9以上，横屏，但是可以根据物理方向传感器来切换正反向横屏|
  
  #### 4.7.1 横竖屏切换-Activity销毁重建
  对于android3.2（API13）及以后的系统，以下任意一种配置，横竖屏切换Activity的生命周期都会重新执行一次
  - 不配置configChanges属性
  - 设置android:configChanges="orientation"
  - 设置android:configChanges="orientation|keyboardHidden"(3.2系统之前的系统不会执行生命周期方法了)
  ![7a414398.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\7a414398.png)
  以上三种配置，横竖屏切换时Activity均会销毁重建，Activity的生命周期都会重新执行一次
  
  #### 4.7.2 横竖屏切换-Activity不销毁重建
  配置android:configChanges="orientation|keyboardHidden|screenSize" 可以控制Activity在横竖屏切换时不销毁重建。
  ```
   @Override
      public void onConfigurationChanged(Configuration newConfig) {
          super.onConfigurationChanged(newConfig);
          int orientation = newConfig.orientation;
          if (orientation == ORIENTATION_LANDSCAPE){
              Log.i(TAG, "-------------横屏-------------");
          }else {
              Log.i(TAG, "-------------竖屏-------------");
          }
          Log.i(TAG, "onConfigurationChanged: "+orientation);
      }
  ```
  ![8f13ec79.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\8f13ec79.png)
  可见配置了android:configChanges="orientation|keyboardHidden|screenSize"横竖屏切换时Activity不会销毁重建，而是会回调Activity的onConfigurationChanged方法。这里需要注意的是，第一次切换时onConfigurationChanged方法会回调两次
  
  总结：在遇到Android横竖屏切换的问题时，我们需要解决的问题主要有两个，布局的变化和数据的存储恢复。可以综合以上的属性设置达到最终自己想要的效果。
  
  ## 5、Broadcast
  ### 5.1 简介
  Broadcast（广播） 是 Android 的四大组件之一，用于进程/线程间通信。
  
  广播最大的特点就是发送方并不关心接收方是否接到数据，也不关心接收方是如何处理数据的，它只负责「说」而不管你「听不听」。
  
  广播可以来之系统，例如，Android 系统在发生各种系统事件时发送广播（系统启动或者设备开始充电时）。
  
  也可以来自于其他应用程序，例如，应用程序也可以发送自定义广播，来通知其他应用程序接受他们可能感兴趣的内容（更新数据）。
  
  ### 5.2 广播的分类
  #### 5.2.1 按发送方式分类
  - 标准广播
  是一种「完全异步执行」的广播，没有任何先后顺序，所有的广播接收器几乎同一时刻接收到这条广播消息，效率高，无法被截断。
  - 有序广播
  是一种「同步执行」的广播，有先后顺序，同一时刻只有一个接收器可以接收这个广播消息，优先级高的广播接收器可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法接收广播消息了。
  
  #### 5.2.2 按注册方式分类
  - 静态广播
  不管应用程序是否处于活动状态，都会进行监听。每次触发都会建立新的 Receiver 对象。
  - 动态广播
  在代码中进行注册，注意动态注册的广播一定要取消注册才行，通常是在 onDestroy() 方法中调用 unregisterReceiver() 方法来实现。
  从开始创建直到其被解除注册会使用同一个 Receiver，无论这个广播被触发几次。
  
  #### 5.2.3 按定义方式分类
  - 系统广播
  Android 系统中内置了多个系统广播，每个系统广播都具有特定的 IntentFilter，其中主要包括具体的 Action，系统广播发出后，将被相应的 BroadcastReceiver 接收。系统广播在系统内部当特定事件发生时，由系统自动发出。
  
  - 自定义广播
  由应用程序开发者自己定义的广播。
  
  #### 5.2.4 按范围方式分类
  - 全局广播
  发出的广播可以被其他任意的应用程序接收，或者可以接收来自其他任意应用程序的广播。
  - 本地广播
  只能在应用程序的内部进行传递的广播，广播接收器也只能接收内部的广播，不能接受其他应用程序的广播。
  
  ### 5.3 广播的使用
  #### 5.3.1 创建广播接收器
  使用广播我们需要先创建 BroadcastReceiver（广播接收器） ，直接继承 BroadcastReceiver 创建子类并实现父类的 onReceive() 方法即可
  ```
  public class MyReceiver extends BroadcastReceiver {
    // 自定义 action
    private static final String ACTION = "com.jeanboy.broadcast.MyReceiverFilter";
    
    @Override
    public void onReceive(Context context, Intent intent) {
      //TODO: 接收到广播进行处理
    }
  }
  ```
  #### 5.3.2 静态广播
  在使用广播时还需要在 AndroidMainfest 文件中定义，也就是注册静态广播。
  ```
  <receiver android:name=".ui.broadcast.MyReceiver"
            android:enabled="true"
            android:exported="true">
      <intent-filter>
          <!-- 例如：接收系统开机广播 -->
          <action android:name="android.intent.action.BOOT_COMPLETED" />
          <!-- 例如：接收自定义的广播 -->
          <action android:name="com.jeanboy.broadcast.MyReceiverFilter" />
      </intent-filter>
  </receiver>
  ```
  上面的 enabled 设置为 true 意味着能够接受到广播信息。exported 为 true 意味着能够接收到外部 APK 发送的广播信息。
  
  #### 5.3.3 动态广播
  使用动态广播不需要在 AndroidMainfest 文件中定义，只需在代码中注册即可。
  ```
  // 创建广播
  MyReceiver myReceiver = new MyReceiver();
  // 创建 IntentFilter
  IntentFilter intentFilter = new IntentFilter();
  // 例如：添加系统广播 action 接受网络变化
  intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  // 例如：添加自定义的 action
  intentFilter.addAction(MyReceiver.ACTION);
  // 注册广播
  registerReceiver(myReceiver, intentFilter);
  // 注销广播
  unregisterReceiver(myReceiver);
  ```
  #### 5.3.4 发送广播
  发送广播比较简单，无论静态广播还是动态广播，都是如下方式（系统广播 Android 系统会自动发送，不在本文讨论范围）。
  ```
  // 创建 Intent
  Intent intent = new Intent();
  // 例如：添加自定义的 action
  intent.setAction(MyReceiver.ACTION);
  // 发送广播
  sendBroadcast(intent);
  ```
  ### 5.4 带权限的广播
  使用广播可能引发的安全问题：
  - 如果别的应用程序监听我们的广播，那么会造成我们应用程序的数据泄露；
  - 如果别的应用程序冒充我们的应用发送广播，那么就会频繁的启动我们的广播接收程序，造成我们应用的混乱，甚至崩溃。
  为了避免以上安全问题，Android 为我们提供了权限机制。
  首先在注册静态广播时可以在 AndroidMainfest 文件中添加权限。
  ```
  <manifest ...>
    <!-- 自定义一个自己的权限 -->
    <permission android:name="com.jeanboy.permissions.MY_BROADCAST"/>
    <!-- 使用自定义的权限 -->
    <uses-permission android:name="com.jeanboy.permissions.MY_BROADCAST"/>
  
    <application ...>
      <!-- 添加权限 -->
      <receiver android:name=".ui.broadcast.MyReceiver"
                android:permission="com.jeanboy.broadcast.MY_BROADCAST"
                android:enabled="true"
                android:exported="true">
        <intent-filter>
          <!-- 例如：接收自定义的广播 -->
          <action android:name="com.jeanboy.broadcast.MyReceiverFilter" />
        </intent-filter>
      </receiver>
    </application>
  </manifest>
  ```
  然后在我们发送广播时，可以为它指定一个权限，只有具有该权限的应用才能接收到广播，如下所示：
  ```
  // 创建 Intent
  Intent intent = new Intent();
  // 例如：添加自定义的 action
  intent.setAction(MyReceiver.ACTION);
  // 发送广播，添加权限
  sendBroadcast(intent, "com.jeanboy.permissions.MY_BROADCAST");
  ```
  ### 5.5 本地广播
  上面介绍的 Broadcast 用于应用之间的传递消息，本质上它是跨进程的，还有可能被其他应用拦截。
  
  而 LocalBroadcast（本地广播）用于应用内部传递消息，比 跨进程Broadcast 更加高效，它只在应用内部有效，不需要考虑安全问题。
  
  本地广播的创建仍然是继承 BroadcastReceiver 创建子类，并实现父类的 onReceive() 方法。在注册、发送、注销广播时使用 LocalBroadcastManager 来进行相关操作。
  ```
  // 创建广播
  MyReceiver myReceiver = new MyReceiver();
  // 创建 IntentFilter
  IntentFilter intentFilter = new IntentFilter();
  // 例如：添加自定义的 action
  intentFilter.addAction(MyReceiver.ACTION);
  // 注册本地广播
  LocalBroadcastManager.getInstance(this)
                  .registerReceiver(myReceiver, intentFilter);
  
  // 发送广播
  Intent intent = new Intent(MyReceiver.ACTION));
  LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
  
  // 注销本地广播
  LocalBroadcastManager.getInstance(this).unregisterReceiver(myReceiver);
  ```
  
  ## 6、ContentProvider
  ### 6.1 ContentProvider 作用与原理
  作用：进程间进行数据交互与共享，即跨进程通信。
  ![944365-3c4339c5f1d4a0fd.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\931e58bc.png)
  
  原理：Android中的Binder机制。
  
  ### 6.2 ContentProvice 具体使用
  
  #### 6.2.1 统一资源标识符（URL）
  外界通过URL来获取ContentProvider其中的数据，再进行数据操作。
  ![944365-96019a2054eb27cf.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\b1ee5396.png)
  
  - 设置URI
  Uri uri = Uri.parse("content://com.carson.provider/User/1") 
  上述URI指向的资源是：名为 `com.carson.provider`的`ContentProvider` 中表名 为`User` 中的 `id`为1的数据
  
  - URI模式存在匹配通配符* & ＃
  ```
  // *：匹配任意长度的任何有效字符的字符串
  // 以下的URI 表示 匹配provider的任何内容
  content://com.example.app.provider/* 
  // ＃：匹配任意长度的数字字符的字符串
  // 以下的URI 表示 匹配provider中的table表的所有行
  content://com.example.app.provider/table/# 
  ```
  #### 6.2.2 MIME数据类型
  作用：指定某个扩展名的文件用某种应用程序来打开
  如指定.html文件采用text应用程序打开、指定.pdf文件采用flash应用程序打开
  
  #### 6.2.3 MIME具体使用
  1. ContentProvider根据 URI 返回MIME类型
  ```
  ContentProvider.geType(uri)
  ```
  2. MIME类型组成
  每种MIME类型 由2部分组成 = 类型 + 子类型
  ```
  text / html
  // 类型 = text、子类型 = html
  ```
  
  3. MIME类型形式
     1)单条记录 
  ```
   vnd.android.cursor.item/自定义
  ```
     2)多条记录
  ```
   vnd.android.cursor.dir/自定义 
  ```
  - vnd：表示父类型和子类型具有非标准的、特定的形式。
  - 父类型已固定好（即不能更改），只能区别是单条还是多条记录
  - 子类型可自定义
  
  ```
  <-- 单条记录 -->
    // 单个记录的MIME类型
    vnd.android.cursor.item/vnd.yourcompanyname.contenttype 
  
    // 若一个Uri如下
    content://com.example.transportationprovider/trains/122   
    // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型
    vnd.android.cursor.item/vnd.example.rail
  
  
  <-- 多条记录 -->
    // 多个记录的MIME类型
    vnd.android.cursor.dir/vnd.yourcompanyname.contenttype 
    // 若一个Uri如下
    content://com.example.transportationprovider/trains 
    // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型
    vnd.android.cursor.dir/vnd.example.rail
  
  ```
  
  ### 6.3 ContentProvice类
  
  #### 6.3.1 四个核心方法
  ```
    public Uri insert(Uri uri, ContentValues values) 
  ```
  外部进程向 ContentProvider 中添加数据
  ```
   public int delete(Uri uri, String selection, String[] selectionArgs) 
  ```
  外部进程 删除 ContentProvider 中的数据
  ```
  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
  ```
  外部进程更新 ContentProvider 中的数据
  
  ```
  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)　 
  ```
  外部应用 获取 ContentProvider 中的数据
  
  #### 6.3.2 两个其它方法
  ```
  public boolean onCreate() 
  ```
  ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用
  注：运行在ContentProvider进程的主线程，故不能做耗时操作
  
  ```
  public String getType(Uri uri)
  
  ```
  得到数据类型，即返回当前 Url 所代表数据的MIME类型
  
  ### 6.4 ContentResolver类
  
  1. 作用
     - 通过 URI 即可操作 不同的ContentProvider 中的数据
     - 外部进程通过 ContentResolver类 从而与ContentProvider类进行交互
  
  2. 具体使用
  ```
  public Uri insert(Uri uri, ContentValues values)　 
  ```
  外部进程向 ContentProvider 中添加数据
  ```
  public int delete(Uri uri, String selection, String[] selectionArgs)
  ```
  外部进程 删除 ContentProvider 中的数据
  
  ```
  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
  ```
  外部进程更新 ContentProvider 中的数据
  
  ```
  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
  ```
  外部应用 获取 ContentProvider 中的数据
  
  3. 实例说明
  使用ContentResolver前，需要先获取ContentResolver
  可通过在所有继承Context的类中 通过调用getContentResolver()来获得ContentResolver
  ```
  ContentResolver resolver =  getContentResolver();  
  ```
  设置ContentProvider的URI
  ```
  Uri uri = Uri.parse("content://cn.scu.myprovider/user"); 
  ```
  根据URI 操作 ContentProvider中的数据
  ```
  Cursor cursor = resolver.query(uri, null, null, null, "userid desc"); 
  ```
  此处是获取ContentProvider中 user表的所有记录 
  
  ### 6.5 辅助工具类
  1. ContentUris类
  - 核心方法有两个：withAppendedId（） &parseId（）
  withAppendedId（）作用：向URI追加一个id
  ```
  Uri uri = Uri.parse("content://cn.scu.myprovider/user") 
  Uri resultUri = ContentUris.withAppendedId(uri, 7);  
  ```
  最终生成后的Uri为：content://cn.scu.myprovider/user/7
  
  parseId（）作用：从URL中获取ID
  ```
  Uri uri = Uri.parse("content://cn.scu.myprovider/user/7") 
  long personid = ContentUris.parseId(uri); 
  ```
  获取的结果为:7
  
  2. UriMatcher类
  - 在ContentProvider 中注册URI
  - 根据 URI 匹配 ContentProvider 中对应的数据表
  ```
  // 步骤1：初始化UriMatcher对象
      UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); 
      //常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码
      // 即初始化时不匹配任何东西
  
  // 步骤2：在ContentProvider 中注册URI（addURI（））
      int URI_CODE_a = 1；
      int URI_CODE_b = 2；
      matcher.addURI("cn.scu.myprovider", "user1", URI_CODE_a); 
      matcher.addURI("cn.scu.myprovider", "user2", URI_CODE_b); 
      // 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a
      // 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b
  
  // 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））
  
  @Override   
      public String getType(Uri uri) {   
        Uri uri = Uri.parse(" content://cn.scu.myprovider/user1");   
  
        switch(matcher.match(uri)){   
       // 根据URI匹配的返回码是URI_CODE_a
       // 即matcher.match(uri) == URI_CODE_a
        case URI_CODE_a:   
          return tableNameUser1;   
          // 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser1的表
        case URI_CODE_b:   
          return tableNameUser2;
          // 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameUser2的表
      }   
  }
  ```
  3. ContentObserver类
  - 当ContentProvider 中的数据发生变化（增、删 & 改）时，就会触发该 ContentObserver类
  ```
  // 步骤1：注册内容观察者ContentObserver
      getContentResolver().registerContentObserver（uri,true,MyContentObserver）；
      // 通过ContentResolver类进行注册，并指定需要观察的URI
  
  // 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）
      public class UserContentProvider extends ContentProvider { 
        public Uri insert(Uri uri, ContentValues values) { 
        db.insert("user", "userid", values); 
        getContext().getContentResolver().notifyChange(uri, null); 
        // 通知访问者
     } 
  }
  
  // 步骤3 创建MyContentObserver类，并继承ContentObserver.在onchange方法中通过回调处理数据变更的逻辑。
  
  
  // 步骤4：解除观察者
   getContentResolver().unregisterContentObserver（uri）；
      // 同样需要通过ContentResolver类进行解除
  ```
  ### 6.6 进程内通信Demo （★）
  Step1:创建数据库类
  Step2:自定义Provider类，如果涉及多个表可以使用uriMatcher工具。
  Step3:自定义Provider类中，需要在oncreate中对数据进行初始化（例如获取数据库getWritableDatabase）
  Step4:自定义Provider类中，对增删改查方法进行重写。
  Step5:在AndroidManifest注册ContentProvider类
  Step6:在处理类中，首先定义URI链接以及获取ContentResolver
  Step7:在处理类中，通过ContentResolver 根据URI 向ContentProvider中进行增删改查处理。
  
  ### 6.7 进程间通信Demo （★）
  Step1:在进程1中创建数据库类 自定义 ContentProvider 类 
  Step2:注册 创建的 ContentProvider类 ,
  Step3:声明外界进程可访问该Provider的权限
  例如：
  android:permission="scut.carson_ho.PROVIDER"
  android:readPermisson = "scut.carson_ho.Read"
  android:writePermisson = "scut.carson_ho.Write"
  Step4: 设置此provider是否可以被其他进程使用(android:exported="true")
  Step5: 声明本应用 可允许通信的权限(<permission android:name="scut.carson_ho.Read" android:protectionLevel="normal"/>)
  Step6: 进程2中声明本应用可允许通信的权限( <uses-permission android:name="scut.carson_ho.PROVIDER"/>)
  Step7: 同样在处理类中，首先定义URI链接以及获取ContentResolver，并通过ContentResolver 根据URI 向ContentProvider中进行增删改查处理。
  
  ### 6.8 多个进程同时调用一个ContentProvider的query获取数据，ContentPrvoider是如何反应的呢？
  一个content provider可以接受来自另外一个进程的数据请求。尽管ContentResolver与ContentProvider类隐藏了实现细节，但是ContentProvider所提供的query()，insert()，delete()，update()都是在ContentProvider进程的线程池中被调用执行的，而不是进程的主线程中。这个线程池是有Binder创建和维护的，其实使用的就是每个应用进程中的Binder线程池。
  
  ### 6.9 Sqlite数据库的使用
  Step1 创建一个子类继承SQLiteOpenHelper类（复写onCreat()、onUpgrade()）,onCreate用来创建数据库，onUpgrade用来更新数据库。
  Step2 实现子类，并通过构造方法初始化数据库。
  Step3 通过子类调用getWritableDatabase(),getReadableDatabase()读写方法，并获取SQLiteDatabase的对象。
  Step4 通过SQLiteDatabase 对象可以调用数据库的增，删，改，查的方法。
  
  ### 6.9 文献
  [Android：关于ContentProvider的知识都在这里了！ - 简书](https://www.jianshu.com/p/ea8bc4aaf057)
  [Android ContentObserver的使用](https://www.jb51.net/article/121731.htm)
  
  ## 7、 Android - 系统启动过程 （★★★★★）
  
  ### 7.1  启动流程图
  ![完整启动过程.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\2dc66a3e.png)
  
  ### 7.2 启动步骤
  Step1  Bootlloader —系统启动加载器
  
  Step2  Bootloader —会读取Boot ROM找到操作系统并将 Kernel(Linux内核) 加载到RAM中。
  
  Step3  当Kernel(Linux内核)启动后会初始化各种软硬环境，加载驱动程序，挂载根文件系统，最后Kernel会调用init.cpp中main()方法。——init是Linux系统中用户空间的第一个进程(pid=1).
  
  Step4  init.main() 首先初始化Kernel log ,创建一块共享的内存空间，加载/default.prop文件，解析init.rc文件。
  
  Step5  init.rc 脚本中配置了一些重要服务，init进程通过创建子进程来启动这些服务。（注意:在这个阶段可以看到 Android log 画面）
  
  Step6  Zygote进程用来孵化所有的Android 应用程序, 该进程的启动也标志着Framework框架初始化启动的开始。Zygote进程启动后，会执行App_main.cpp. 文件的main()方法。开始启动java 虚拟机. 
  
  Step7  在App_main.cpp中启动ZygoteInit.main()方法，启动预加载和资源，并启动system_server.
  
  Step8  system_server进程启动后将开启 引导服务，核心服务，其它服务。
  
  Step9  在Zygote中启动的服务都会注册到ServiceManager中。
  
  Step10 ActivityManagerService 服务启动完成后，会进入 ActivityManagerService.systemReady()，然后启动 SystemUI，WebViewFactory，Watchdog，最后启动桌面 Launcher App。
  
  ### 7.3 init.rc 进程中启动的服务
  1. service_manager： Binder IPC 通信过程中的守护进程，本身也是一个 Binder 服务。ServiceManager 进程主要是启动 Binder，提供服务的查询和注册。
  2. mountd：设备安装 Daemon，负责设备安装及状态通知
  3. debuggerd：启动 debug system，处理调试进程的请求
  4. rild：启动 radio interface layer daemon 服务，处理电话相关的事件和请求
  5. media_server：MediaServer 进程主要是启动 AudioFlinger 音频服务，CameraService 相机服务。负责处理音频解析播放，相机相关的处理。
  6. surface_flinger：负责图像绘制，是应用 UI 的核心，其功能是合成所有 Surface 并渲染到显示设备。SurfaceFlinger 进程主要是启动 FrameBuffer，初始化显示系统。
  7. zygote：进程孵化器，启动 Android Java VMRuntime 和启动 systemserver，负责 Android 应用进程的孵化工作 （重要）
  
  ### 7.4 system_server进程启动的服务
  1. 引导服务：
  ActivityManagerService，
  PowerManagerService，
  LightsService，
  DisplayManagerService，
  PackageManagerService，
  UserManagerService。
  
  2. 核心服务：
  BatteryService
  UsageStatsService
  
  3. 其它服务：
  InputManagerService，
  WindowManagerService
  
  ### 7.5 参考文献
  [Android-ReadTheFuckingSourceCode/Android-系统启动过程.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/Android-系统启动过程.md)
  
  
  ## 8、Android - Activity 启动过程 (参考ActivityManagerService)
  
  ## 9、IPC (★★★★★) 
  
  ### 9.1 Android中实现IPC通信的8种方式
  1. 使用Bundle ----> 用于android四大组件间的进程间通信
  2. 使用SharePreference ---->用于单线程读写
  3. 使用Messenger ---->用于可存放在message中的数据的传递
  4. 使用AIDL ---->主要用于调用远程服务的方法的情况 还可以注册接口
  5. ContentProvider方式----> 实现对另一个应用进程开放provider数据的查询
  6. Socket方法----> 这种方式也可以实现 但是不常用
  7. BroadCase ----> 不关心何时发来广播，大多也不关心是谁发送的，只管接收特定类型的消息(应用场景比较单一)
  
  ### 9.2 AIDL 知识 (★★★★★)
  
  #### 9.2.1 序列化与反序列化的知识
  
  序列化
  - 将对象或数据结构转化为字节序列的过程
  
  反序列化
  - 将字节序列恢复为原始对象的过程
  
  #### 9.2.2 Serializable与Parcelable的区别(★★★)
  
  - Serializable接口是在java中的序列化抽象类，而Parcelable接口则是android中特有的序列化接口
  - Serializable使用IO读写存储在硬盘上。序列化过程使用了反射技术，并且期间产生大量临时对象,从而引起频繁的GC。
  - Parcelable是直接在内存中读写，由于内存的读写速度肯定优于硬盘读写速度，所以Parcelable序列化方式性能上要优于Serializable方式很多。
  
  [序列化与反序列化之Parcelable和Serializable浅析_zejian的博客-CSDN博客_parcelable和serializable](https://blog.csdn.net/javazejian/article/details/52665164)
  #### 9.2.3 Parcelable 实现案例
  ```
  package com.zejian.ipctest;
  import android.os.Parcel;
  import android.os.Parcelable;
  
  public class NewClient implements Parcelable {
  
      public int id;
      public String name;
      public User user;
  
      /**
       * 当前对象的内容描述,一般返回0即可
       */
      @Override
      public int describeContents() {
          return 0;
      }
  
      /**
       * 将当前对象写入序列化结构中
       */
      @Override
      public void writeToParcel(Parcel dest, int flags) {
          dest.writeInt(this.id);
          dest.writeString(this.name);
          dest.writeParcelable(this.user,0);
      }
  
      public NewClient() {
      }
  
      /**
       * 从序列化后对象中创建原始对象
       */
      protected NewClient(Parcel in) {
          this.id = in.readInt();
          this.name = in.readString();
         //User是另一个序列化对象，此方法序列需要传递当前线程的上下文类加载器，否则会报无法找到类的错误
         this.user=in.readParcelable(Thread.currentThread().getContextClassLoader());
      }
  
      /**
       * public static final一个都不能少，内部对象CREATOR的名称也不能改变，必须全部大写。
       * 重写接口中的两个方法：
       * createFromParcel(Parcel in) 实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层，
       * newArray(int size) 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。
       */
      public static final Parcelable.Creator<NewClient> CREATOR = new Parcelable.Creator<NewClient>() {
          /**
           * 从序列化后的对象中创建原始对象
           */
          @Override
          public NewClient createFromParcel(Parcel source) {
              return new NewClient(source);
          }
  
          /**
           * 创建指定长度的原始对象数组
           * @param size
           * @return
           */
          @Override
          public NewClient[] newArray(int size) {
              return new NewClient[size];
          }
      };
  }
  ```
  从代码可知，通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。
  
  **Parcel是一个容器，它主要用于存储序列化数据，然后可以通过Binder在进程间传递这些数据**
  
  #### 9.2.4 AIDL的概述
  在Android系统中，每个进程都运行在一块独立的内存中，在其中完成自己的各项活动，与其他进程都分隔开来。可是有时候我们又有应用间进行互动的需求，比较传递数据或者任务委托等，AIDL就是为了满足这种需求而诞生的。
  **通过AIDL，可以在一个进程中获取另一个进程的数据和调用其暴露出来的方法，从而满足进程间通信的需求**。
  
  #### 9.2.5 AIDL的语法
  支持的数据类型:
  - 八种基本数据类型：byte、char、short、int、long、float、double、boolean
  - String，CharSequence
  - 实现了Parcelable接口的数据类型
  - List 类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象
  - Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象
  
  #### 9.2.6 AIDL文件构成
  1. 一类用来声明实现了Parcelable接口的数据类型，以供其他AIDL文件使用那些非默认支持的数据类型。
  2. 一类是用来定义接口方法，声明要暴露哪些接口给客户端调用，定向Tag就是用来标注这些方法的参数值。
  
  #### 9.2.7 AIDL定向Tag
  定向Tag表示在跨进程通信中数据的流向，用于标注方法的参数值，分为 in、out、inout 三种。
  in:表示数据只能由客户端流向服务端。
  out:表示数据只能由服务端流向客户端。
  inout:表示数据可在服务端与客户端之间双向流通。
  **注意**
  如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。
  
  #### 9.2.8 使用AIDL的步骤 (★★★★★)
  
  服务端：
  
  1. 服务端创建.aidl的文件，也就是双方远程通信的接口方法
  2. 定义跟客服端沟通的数据类，比如序列化parcelable的类，基础类
  3. build 生成相应的Java文件
  4. 创建继承Service的自定义服务，并在Manifest.xml中注册
  5. 声明.Stub类型变量（Binder类型），并实现接口方法
  6. 重写onBind方法返回.Stub类型变量(Binder类型)
  
  客服端：
  1. 将服务端定义好的接口aidl文件和数据类复制到客服端
  2. 声明ServiceConnection类型变量，并完成bindService
  3. 在onServiceConnected中通过.Stub.asInterface,获取到服务端binder实例。
  4. 调用服务端binder实例，实现与服务端的通信。
  
  #### 9.2.9 AIDL的工作原理 (★★★★★)
  **在客户端与服务端通信的过程中，真正协助发挥作用的是通过AIDL编译出来的.java文件。AIDL文件的目的就是为了生成.java文件，AIDL只是为了简化写.java文件**
  
  ##### 9.2.9.1 关键Stub类
  Stub类基本结构如下：
  - 静态方法 asInterface(android.os.IBinder obj)
  - 静态内部类 Proxy
  - 方法 onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)
  - 方法 asBinder()
  - private的String类型常量DESCRIPTOR
  - private的int类型常量TRANSACTION_connect
  - private的int类型常量TRANSACTION_sendInMessage
  
  1. AsInterface类
  ```
          /**
           * Cast an IBinder object into an com.gebilaolitou.android.aidl.IMyAidlInterface interface,
           * generating a proxy if needed.
           */
          public static com.gebilaolitou.android.aidl.IMyAidlInterface asInterface(android.os.IBinder obj) {
              //非空判断
              if ((obj == null)) {
                  return null;
              }
              // DESCRIPTOR是常量为"com.gebilaolitou.android.aidl.IMyAidlInterface"
              // queryLocalInterface是Binder的方法，搜索本地是否有可用的对象
              android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
              //如果有，则强制类型转换并返回
              if (((iin != null) && (iin instanceof com.gebilaolitou.android.aidl.IMyAidlInterface))) {
                  return ((com.gebilaolitou.android.aidl.IMyAidlInterface) iin);
              }
              //如果没有，则构造一个IMyAidlInterface.Stub.Proxy对象
              return new com.gebilaolitou.android.aidl.IMyAidlInterface.Stub.Proxy(obj);
          }
  ```
  主要的作用就是根据传入的Binder对象转换成客户端需要的IMyAidlInterface接口。如果客户端和服务端处于同一进程，那么queryLocalInterface()方法返回就是服务端Stub对象本身；如果是跨进程，则返回一个封装过的Stub.Proxy，也是一个代理类，在这个代理中实现跨进程通信。
  
  2. onTransact()方法解析 
  ```
  @Override
          public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
              switch (code) {
                  case INTERFACE_TRANSACTION: {
                      reply.writeString(DESCRIPTOR);
                      return true;
                  }
                  case TRANSACTION_connect: {
                      data.enforceInterface(DESCRIPTOR);
                      this.connect();
                      reply.writeNoException();
                      return true;
                  }
                  case TRANSACTION_sendInMessage: {
                      data.enforceInterface(DESCRIPTOR);
                      com.gebilaolitou.android.aidl.Message _arg0;
                      if ((0 != data.readInt())) {
                          _arg0 = com.gebilaolitou.android.aidl.Message.CREATOR.createFromParcel(data);
                      } else {
                          _arg0 = null;
                      }
                      this.sendInMessage(_arg0);
                      reply.writeNoException();
                      return true;
                  }
              }
              return super.onTransact(code, data, reply, flags);
          }
  ```
  code : 确定客户端请求的目标方法是什么。
  data : 如果目标方法有参数的话，就从data取出目标方法所需的参数。
  reply : 当目标方法执行完毕后，如果目标方法有返回值，就向reply中写入返回值。
  
  onTransact方法就是服务端处理的核心。接收到客户端的请求，并且通过客户端携带的参数，执行完服务端的方法，返回结果。
  
  3. Proxy类
  ```
  private static class Proxy implements com.gebilaolitou.android.aidl.IMyAidlInterface {
              private android.os.IBinder mRemote;
   
              Proxy(android.os.IBinder remote) {
                  mRemote = remote;
              }
              //Proxy的asBinder()返回位于本地接口的远程代理
              @Override
              public android.os.IBinder asBinder() {
                  return mRemote;
              }
   
              public java.lang.String getInterfaceDescriptor() {
                  return DESCRIPTOR;
              }
  //连接
              
              @Override
              public void connect() throws android.os.RemoteException {
                  android.os.Parcel _data = android.os.Parcel.obtain();
                  android.os.Parcel _reply = android.os.Parcel.obtain();
                  try {
                      _data.writeInterfaceToken(DESCRIPTOR);
                      mRemote.transact(Stub.TRANSACTION_connect, _data, _reply, 0);
                      _reply.readException();
                  } finally {
                      _reply.recycle();
                      _data.recycle();
                  }
              }
  //发送消息  客户端——> 服务器
   
              @Override
              public void sendInMessage(com.gebilaolitou.android.aidl.Message message) throws android.os.RemoteException {
                  android.os.Parcel _data = android.os.Parcel.obtain();
                  android.os.Parcel _reply = android.os.Parcel.obtain();
                  try {
                      _data.writeInterfaceToken(DESCRIPTOR);
                      if ((message != null)) {
                          _data.writeInt(1);
                          message.writeToParcel(_data, 0);
                      } else {
                          _data.writeInt(0);
                      }
                      mRemote.transact(Stub.TRANSACTION_sendInMessage, _data, _reply, 0);
                      _reply.readException();
                  } finally {
                      _reply.recycle();
                      _data.recycle();
                  }
              }
          }
  ```
  connect和sendInMessage都是AIDL文件中声明的方法，是服务端跨进程远程调用的方法。
  - android.os.Parcel_data和_reply是用来进行跨进程传输的"载体"。_data用来存储客户端流向服务端的数据，_reply用来存储服务端流向客户端的数据。
  - 通过mRemote. transact()方法，将_data和_reply传过去
  - 通过_reply.readException()来读取服务端执行方法的结果。
  - 最后通过finally回收l_data和_reply
  
  4. 客户端与服务端使用AIDL进行 IPC 的工作流程
  
  Stub充当服务端角色，持有Binder实体（本地对象）。
  
  - 获取客户端传过来的数据，根据方法 ID 执行相应操作。
  - 将传过来的数据取出来，调用本地写好的对应方法。
  - 将需要回传的数据写入 reply 流，传回客户端。
  
  Proxy代理类充当客户端角色，持有Binder引用（句柄）。
  
  - 生成 _data 和 _reply 数据流，并向 _data 中存入客户端的数据。
  - 通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。
  - 接收 _reply 数据流，并从中取出服务端传回来的数据。
  
  ![ab3caee4.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\ab3caee4.png)
  
  ![522039c7.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\522039c7.png)
  
  #### 9.2.10 AIDL与HIDL (★★★★★)
  AIDL和HIDL都是主要用于跨进程通信，本质是Binder通信。
  
  ##### 9.2.10 区别
  - AIDL 生成java代码，客户端(client)对应Proxy,服务端(server)对应Stub。HIDL生成c++代码，客户端(client)对应BP(Binder Proxy),服务端(Server)对应BN(Binder Native).
  - AIDL 常用于连接APP和Framework,HIDL则是用来连接Framework和HAL.
  - AIDL 使用Binder通信，HIDL使用HwBinder通信，他们都是通过Binder驱动完成通信，只不过两个Binder域不一样。
  
  #### 9.2.11 为什么需要HIDL
  目前Android系统生态是几乎每年google都会出一个Android大版本，而普通手机用户一部手机一般要用两三年，所以你会发现尽管Android系统已经升级到了10，马上11出来了，然后还是有很多用户依然使用的是Android 5，6，7等版本，对普通用户来说如果不更换手机就很难跟上Android版本，这是因为OEM厂商在同一设备上进行系统升级需要花费时间金钱成本很高，导致他们不愿意升级，成本高的原因是Android O之前Android Framework的升级需要OEM将HAL也进行对应升级，Framework和HAL是一起被编译成system.img，它们存在高耦合，针对这种情况google在Android O中引入了Treble计划，Treble的目的就是解耦Framework和HAL，就是通过HIDL来实现，Framework不再直接调用HAL，而是通过HIDL来间接使用HAL模块，每个HAL模块都可以对应一个HIDL服务，Framework层通过HwBinder创建HIDL服务，通过HIDL服务来获取HAL相关模块继而打开HAL下的设备，而最终HAL也从system.img中分离，被编进一个单独的分区vendor.img，从而简化了Android系统升级的影响与难度
  
  #### 9.2.11 文献
  [Android：学习AIDL，这一篇文章就够了(上) - 简书](https://www.jianshu.com/p/a8e43ad5d7d2)
  [Android：学习AIDL，这一篇文章就够了(下) - 简书](https://www.jianshu.com/p/0cca211df63c)
  [Android中AIDL的基本使用 - 简书](https://www.jianshu.com/p/7b8bb36ad109)
  [Android AIDL 使用 - 妖久 - 博客园](https://www.cnblogs.com/tangZH/p/10775848.html)
  [Binder系列9—如何使用AIDL - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2015/11/23/binder-aidl/)
  [Android IPC —— AIDL的原理_休闲的灵魂的博客-CSDN博客_android aidl原理](https://blog.csdn.net/haazzz/article/details/116753360)
  [Android跨进程通信——AIDL原理解析_Jason_Lee155的博客-CSDN博客_android aidl原理](https://blog.csdn.net/Jason_Lee155/article/details/118243598)
  [Android中AIDL的工作原理 - 简书](https://www.jianshu.com/p/e0c583ea9289)
  [AIDL 和 HIDL_aidl hidl_bobuddy的博客-CSDN博客](https://blog.csdn.net/u010783226/article/details/122506828)
  
  ## 10、Binder学习(★★★★★)
  
  ### 10.1 Binder概述 (★★★★)
  Binder是跨进程通信(IPC)的桥梁
  - 从性能上:
  共享内存方式虽然无需数据拷贝，但控制复杂。
  Socket方式需要2次数据拷贝，传输效率低，开销大
  Binder,需要1次数据拷贝，性能上仅此共享内存
  - 从稳定性上：
  Binder采用C/S架构，需求控制架构较清晰。
  共享内存方式虽然无需拷贝数据，控制比较复杂，难以使用。
  - 从安全性上：
  传统的IPC要发送类似的UID也只能放在数据包里，但也容易被拦截，恶意进攻，
  socket则需要暴露自己的ip和端口，这些恶意程序则可以进行任意接入。
  Binder 为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志，因此安全性较高。
  
  ### 10.2 进程隔离的概念(★★★★)
  - 操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据.
  - 但是内核空间却是可共享的。Client进程向Server进程通信恰恰是利用内核空间来完成底层通信工作的。
  
  ### 10.3 用户空间（User Space）/内核空间(Kernel Space)区别
  用户空间：是用户程序运行的空间，可以执行任意命令，调用系统的一切资源； 
  内核空间：是Linux内核的运行空间，只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。
  
  系统调用主要通过如下两个函数来实现：
  copy_from_user() //将数据从用户空间拷贝到内核空间
  copy_to_user() //将数据从内核空间拷贝到用户空间
  
  ### 10.4 Binder驱动概念
  Android通过LKM（动态内核可加载模块）添加一个内核模块运行在内核空间，使得进程间通过这个模块作为桥梁，就可以完成通信了。
  Android 系统中，这个运行在内核空间的，负责进程间通信的内核模块叫做 Binder 驱动;
  
  ### 10.5 一次Binder IPC通信过程
  ![binder_main_request.jpg](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\2dadde28.jpg)
  
  Step1: Service先注册服务，首先向ServiceManager注册服务，
  Step2: ServiceManager,向Kernel(内核)中Binder驱动的全局链表中插入服务端的信息
  Step3: 同时向svcinfo已注册服务列表中缓存一下注册的服务。
  Step4: 客户端通过ServiceManager向svcinfo列表中查询一下返回服务端的代理。
  Step5: 客户端利用获取到的服务端代理，即BinderProxy，将请求发送给ServiceManager.
  Step6: ServiceManager使用内核方法copy_from_user()将参数拷贝到内核空间。
  Step7: 这时候客户端进入等待状态。
  Step8: 然后 Binder 驱动向全局链表队列里面插入一条事务.
  Step9: 执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间
  Step10:唤醒等待的客户端并把结果响应给客户端。
  
  ### 10.6 Binder 进程与线程
  ![process_thread.jpg](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\55fc103c.jpg)
  对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，
  且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，
  即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，
  来记录当前进程内所有的 binder_thread。
  
  ### 10.7 参考文献
  [Android-ReadTheFuckingSourceCode/Android-Binder进程间通讯.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/Android-Binder%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF.md)
  [Binder系列—开篇 - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2015/10/31/binder-prepare/)
  
  ## 11、性能优化 (★★★★★)
  ### 11.1 内存优化
  #### 11.1.1 LeakCanary工具
  LeakCanary是Square公司基于MAT开发的一款监控Android内存泄漏的开源框架。其工作的原理是： 监测机制利用了Java的WeakReference和ReferenceQueue，通过将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中，通过监测ReferenceQueue里面的内容就能检查到Activity是否能够被回收（在ReferenceQueue中说明可以被回收，不存在泄漏；否则，可能存在泄漏，LeakCanary是执行一遍GC，若还未在ReferenceQueue中，就会认定为泄漏）。
  
  如果Activity被认定为泄露了，就抓取内存dump文件(Debug.dumpHprofData)；之后通过HeapAnalyzerService.runAnalysis进行分析内存文件分析；接着通过HeapAnalyzer (checkForLeak—findLeakingReference---findLeakTrace)来进行内存泄漏分析。最后通过DisplayLeakService进行内存泄漏的展示。
  #### 11.1.2 Android Lint工具
  Android Lint Tool 是Android Sutido中集成的一个Android代码提示工具，它可以给你布局、代码提供非常强大的帮助。硬编码会提示以级别警告，例如：在布局文件中写了三层冗余的LinearLayout布局、直接在TextView中写要显示的文字、字体大小使用dp而不是sp为单位，就会在编辑器右边看到提示。
  
  ### 11.2 APK瘦身(★★★★)
  #### 11.2.1 安装包的组成
  assets文件夹 存放一些配置文件，资源文件，assets不会自动生成对应的ID,而是通过AssetManager类的接口获取
  
  res 是resource的缩写，这个目录存放资源文件，会自动生成对应的ID并映射到.R文件中，访问直接使用资源ID。
  
  META-INF. 保存应用的签名信息，签名信息可以炎症APK文件的完整性.
  
  AndroidManifes.xml, 这个文件用来描述Android应用的配置信息，一些组件的注册信息，可使用权限。
  
  classex.dex Dalvik字节码程序，让Dalvik虚拟机可执行，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将java字节码转换为Dalvik字节码
  
  resources.arsc 记录着资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。
  
  #### 11.2.2 减少安装包大小 (★★★★)
  
  代码混淆：使用IDE 自带的 proGuard 代码混淆器工具 ，它包括压缩、优化、混淆等功能。 
  资源优化：使用 Android Lint 删除冗余资源，资源文件最少化等。 
  图片优化: 利用 PNG优化工具 对图片做压缩处理。推荐目前最先进的压缩工具Googlek开源库zopfli。如果应用在0版本以上，推荐使用 WebP图片格式。 
  
  ### 11.3 冷启动与热启动 (★★★★)
  
  **冷启动** 
  在启动应用时，系统中没有该应用的进程，这时系统会创建一个新的进程分配给该应用；
  
  **热启动**
  在启动应用时，系统中已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程还是保留在后台）；
  
  **区别 冷启动**
  冷启动:系统没有该应用的进程，需要创建一个新的进程分配给应用，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。 
  热启动:从已有的进程中来启动，不会创建和初始化Application类，直接创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。
  
  **冷启动流程** 
  Zygote进程中fork创建出一个新的进程； 创建和初始化Application类、创建MainActivity； inflate布局、当onCreate/onStart/onResume方法都走完； contentView的measure/layout/draw显示在界面上。
  
  **冷启动优化** 
  减少在Application和第一个Activity的onCreate()方法的工作量； 不要让Application参与业务的操作； 不要在Application进行耗时操作； 不要以静态变量的方式在Application中保存数据； 减少布局的复杂性和深度；
  
  ## 12、HandleThread 使用与源码解析
  
  ### 12.1 HandleThread 的特点
  - HandlerThread本质上是一个线程类，它继承了Thread；
  - HandlerThread有自己的内部Looper对象，可以进行looper循环；
  - 通过获取HandlerThread的looper对象传递给Handler对象，然后在handleMessage方法中执行异步任务。
  - 创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象。
  
  ### 12.1 HandleThread 使用
  1. 创建实例对象
  ```
  HandlerThread handlerThread = new HandlerThread("downloadImage");
  ```
  2. 启动HandlerThread线程
  ```
  必须先开启线程
  handlerThread.start();
  ```
  3. 构建循环消息处理机制
  ```
  该callback运行于子线程
      class ChildCallback implements Handler.Callback {
          @Override
          public boolean handleMessage(Message msg) {
              在子线程中进行相应的网络请求
              通知主线程去更新UI
              mUIHandler.sendMessage(msg1);
              return false;
          }
      }
  ```
  4. 构建异步handler
  ```
  Handler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback());
  ```
  ### 12.2 HandlerThread的使用案例
  ```
  public class HandlerThreadActivity extends Activity {
      /**
       * 图片地址集合
       */
      private String url[]={
              "https://img-blog.csdn.net/20160903083245762",
              "https://img-blog.csdn.net/20160903083252184",
              "https://img-blog.csdn.net/20160903083257871",
              "https://img-blog.csdn.net/20160903083257871",
              "https://img-blog.csdn.net/20160903083311972",
              "https://img-blog.csdn.net/20160903083319668",
              "https://img-blog.csdn.net/20160903083326871"
      };
      private ImageView imageView;
      private Handler mUIHandler = new Handler(){
          @Override
          public void handleMessage(Message msg) {
              LogUtils.e("次数:"+msg.what);
              ImageModel model = (ImageModel) msg.obj;
              imageView.setImageBitmap(model.bitmap);
          }
      };
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_handler_thread);
          imageView= (ImageView) findViewById(R.id.image);
          //创建异步HandlerThread
          HandlerThread handlerThread = new HandlerThread("downloadImage");
          //必须先开启线程
          handlerThread.start();
          //子线程Handler
          Handler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback());
          for(int i=0;i<7;i++){
              //每个1秒去更新图片
              childHandler.sendEmptyMessageDelayed(i,1000*i);
          }
      }
      /**
       * 该callback运行于子线程
       */
      class ChildCallback implements Handler.Callback {
          @Override
          public boolean handleMessage(Message msg) {
              //在子线程中进行网络请求
              Bitmap bitmap=downloadUrlBitmap(url[msg.what]);
              ImageModel imageModel=new ImageModel();
              imageModel.bitmap=bitmap;
              imageModel.url=url[msg.what];
              Message msg1 = new Message();
              msg1.what = msg.what;
              msg1.obj =imageModel;
              //通知主线程去更新UI
              mUIHandler.sendMessage(msg1);
              return false;
          }
      }
      private Bitmap downloadUrlBitmap(String urlString) {
          HttpURLConnection urlConnection = null;
          BufferedInputStream in = null;
          Bitmap bitmap=null;
          ---省略图片处理逻辑----
          return bitmap;
      }
  }
  ```
  
  ### 12.3 源码解析
  - HandleThread 继承于Thread
  - 在创建HandlerThread对象后，调用start方法后执行HandleThread类中的run方法，由于run方法中有Looper.parpare(),会使当前线程变为异步线程，这样能保证传给handler对象是Looper对象。进而确保Handler对象中的handleMessage方法是在异步线程执行的
  - Looper对象创建后将其赋值给HandlerThread的内部变量mLooper，并通过notifyAll()方法去唤醒等待线程，最后执行Looper.loop()代码，开启looper循环语句，这里利用notifyAll的目的是因为Looper的创建是在子线程中执行的，而调用getLooper方法则是在主线程进行的，这样我们就无法保障在调用getLooper方法时Looper已经被创建，只有当线程创建成功并且Looper对象也创建成功之后才能获得mLooper的值，HandlerThread内部则通过等待唤醒机制解决了同步问题。
  
  ### 12.4 Handle,HandleThread,Thread 的区别
  1. Handler：在android中负责发送和处理消息，通过它可以实现其他支线线程与主线程之间的消息通讯。
  2. Thread：Java进程中执行运算的最小单位，亦即执行处理机调度的基本单位。某一进程中一路单独运行的程序。
  3. HandlerThread：一个继承自Thread的类HandlerThread，Android中没有对Java中的Thread进行任何封装，而是提供了一个继承自Thread的类HandlerThread类，这个类对Java的Thread做了很多便利的封装。
  
  ### 12.5 参考文献
  [Android 多线程之HandlerThread 完全详解_zejian的博客-CSDN博客_handlerthread](https://blog.csdn.net/javazejian/article/details/52426353)
  [Handler机制-Looper源码解析_yumodev-CSDN博客_handler looper](https://blog.csdn.net/wangkaishou/article/details/90302304)
   
  ## 13、AsyncTask
  
  ### 13.1 AsyncTask中的方法
  1. onPreExecute()
  该方法在主线程中执行，将在execute(Params… params)被调用后执行，一般用来做一些UI的准备工作，如在界面上显示一个进度条。
  
  2. doInBackground(Params…params)
  抽象方法，必须实现，该方法在线程池中执行，用于执行异步任务，将在onPreExecute方法执行后执行。其参数是一个可变类型，表示异步任务的输入参数，在该方法中还可通过publishProgress(Progress… values)来更新实时的任务进度，而publishProgress方法则会调用onProgressUpdate方法。此外doInBackground方法会将计算的返回结果传递给onPostExecute方法。
  
  3. onProgressUpdate(Progress…)
  在主线程中执行，该方法在publishProgress(Progress… values)方法被调用后执行，一般用于更新UI进度，如更新进度条的当前进度。
  
  4. onPostExecute(Result)
  在主线程中执行，在doInBackground 执行完成后，onPostExecute 方法将被UI线程调用，doInBackground 方法的返回值将作为此方法的参数传递到UI线程中，并执行一些UI相关的操作，如更新UI视图。
  
  5. onCancelled()
  在主线程中执行，当异步任务被取消时,该方法将被调用,要注意的是这个时onPostExecute将不会被执行
  
  ### 13.1 AsyncTask中四个方法调用的顺序
  Step1 在主线程中调用execute方法会先去执行onPreExecute方法。
  Step2 接着是doInBackground异步方法,去执行耗时操作。
  Step3 在doInBackground中如果调用了publishProgress方法，那么onProgressUpdate方法将会被执行。
  Step4 最后doInBackground方法执行后完后。
  Step5 onPostExecute方法将被执行。
  
  ### 13.2 AsyncTask使用步骤
  Step 1 自定义AsyncTask的子类，同时指定三种泛型参数的类型。
  Step 2 重写AsyncTask的四种方法。
  Step 3 在主线程中创建AsyncTask子类的对象并且调用execute()方法启动子线程。
  Step 4 在主线程销毁时查看子线程是否在运行，如果在运行那么销毁子线程。
  
  ### 13.3 AsyncTask使用规则
  - AsyncTask的实例必须在主线程（UI线程）中创建 ，execute方法也必须在主线程中调用。
  - 不要在程序中直接的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法。
  - 不能在doInBackground(Params… params)中更新UI。
  - 一个AsyncTask对象只能被执行一次，也就是execute方法只能调用一次，否则多次调用时将会抛出异常。
  
  ### 13.4 AsyncTask原理
  ![20160907201617633.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\b7ec1796.png)
  
  准备工作：AsyncTask 构造函数时 初始化了一个线程池，mWorker,mFuture,mHandler这三个对象，
  - mWorker是一个Callbale对象，其中的call方法回调的结果将传递给doinBackground.
  - mFuture是一个FutureTask对象，并封装了mWorker对象，目的是需要向线程池中传出一个Runnable对象。FutureTask  继承的是Runnable
  - mHandler 是主线程的Hanlder对象，这也是为什么AsyncTask的类要在主线程加载。
  
  Step1 execute方法中执行executeOnExecutor方法，此时会判断AsyncTask对象任务的状态，如果多次执行execute方法会报异常。
  
  Step2 执行onPreExecute()方法。此时的线程为主线程。
  
  Step3 开始线程切换，这时通过线程池执行mFuture对象，其中在mWorker回调call方法中将执行结果传递给doinBackground，在doinBackground中将执行结果通过Handler方式发送。
  
  Step4 Handler把doInBackGround的执行结果，发送到InternalHandler中，并通过handleMessage对消息的类型进行了判断，
  如果这是一条 MESSAGE_POST_RESULT 消息，就会去执行 finish() 方法，
  如果这是一条 MESSAGE_POST_PROGRESS 消息，就会去执行 onProgressUpdate() 方法
  这里由于Handle 是主线程的Handle，因此handleMessage也是在主线程处理。
  
  Step5 在finish()方法中如果当前任务被取消掉了，就会调用 onCancelled() 方法，如果没有被取消，则调用 onPostExecute() 方法。
  
  ### 13.5 AsyncTask 的类为什么必须在主线程加载 
  AsyncTask的构造函数中对handler进行了初始化的操作，重要的一步就是要获取主线程的handle,否则AsyncTask无法进行线程切换工作。
  
  ### 13.6  AsyncTask 调用 cancel() 任务是否立即停止执行？onPostExecute() 还会被调用吗？onCancelled() 什么时候被调用？ 
  并不会打断doInbackground中的异步的任务，cancel()方法是将AsyncTask 设置为已取消的状态。onProgressUpdate 和 onPostExecute 都不会被调用是因为当异步任务执行完成后，会根据cancel的状态决定是否执行。
  
  ### 13.5 参考文献
  [android多线程-AsyncTask之工作原理深入解析(上)_zejian的博客-CSDN博客_asynctask原理 site:blog.csdn.net](https://blog.csdn.net/javazejian/article/details/52462830)
  [android多线程-AsyncTask之工作原理深入解析(下)_zejian的博客-CSDN博客_android asynctask工作原理](https://blog.csdn.net/javazejian/article/details/52464139)
  [理解 AsyncTask 原理 - 掘金](https://juejin.im/post/6844903784968093704)
  [AsyncTask 面试解析 - 掘金](https://juejin.im/post/6844903842841100295#heading-9)
  
  ## 14、EventBus
  ### 14.1 EventBus概述
  EventBus简化了应用程序内各个组件之间进行通信的复杂度，尤其是Fragment之间进行通信的问题,可以避免由于使用广播通信而带来的诸多不便。
  1. EventBus  三个角色
  Event事件，Subscriber事件订阅者，Publisher事件发布者
  
  2. 四种线程模式
  POSTING (默认) 表示事件处理函数的线程跟发布事件的线程在同一个线程。
  MAIN 表示事件处理函数的线程在主线程(UI)线程，因此在这里不能进行耗时操作。
  BACKGROUND 表示事件处理函数的线程在后台线程，因此不能进行UI操作。如果发布事件的线程是主线程(UI线程)，那么事件处理函数将会开启一个后台线程，如果发布事件的线程是在后台线程，那么事件处理函数就使用该线程。
  ASYNC 表示无论事件发布的线程是哪一个，事件处理函数始终会新建一个子线程运行，同样不能进行UI操作。
  
  ### 14.2 EventBus基本使用
  #### 14.2.1 定义事件
  首先创建一个model类，初始化get/set方法，以及构造函数。
  
  #### 14.2.2 订阅事件
  订阅者需要定义事件处理方法，当发布对应类型的事件时，该方法将被调用。
  在EventBus3中用@Subscribe注解来定义订阅者方法。
  然后根据Activity或者Fragment的生命周期来注册和注销。
  EventBus.getDefault().register(this);
  EventBus.getDefault().unregister(this);
  
  注意：
  在fagment中使用，由于项目中一般我们都会使用BaseFragment等基类，
  而Context也是作为基类的protected变量初始化，方便在其他地方获取context。
  但是在EventBus初始化中，register（）方法传入的是一个Object，而不是Context，如果将基类的Context传入，就会导致应用直接崩溃。
  
  #### 14.2.3 发布事件
  通过post方法将事件发布出去。
  EventBus.getDefault().post();
  
  ### 14.3 线程模式
  1. ThreadMode.POSTING:
  只能在同一个线程中接收,
  如果在主线程中发布消息就只能在主线程中接收消息。
  如果是在子线程中，那么也只能在相同的子线程中去接收消息。
  
  2. ThreadMode.MAIN:
  这种模式保证了订阅者指定的那个接收方法肯定要主线程中执行，可以放心的在里面执行更新UI操作。
  无论发布者是在主线程中还是在那一条子线程中发布消息，这边接收的都在主线程中。
  其做法是通过Handler去发送消息，然后在HandleMessage中执行的。 
  
  3. ThreadMode.BACKGROUND:
  无论发布者是在主线程或者是那一条子线程中发布消息，接收的肯定是在子线程中，
  如果是在主线程中发布消息，那么就会随机开辟一条子线程来接收消息。
  如果是在子线程中发布消息，那么就会在相同的子线程来接收消息。
  
  4. ThreadMode.ASYNC:
  无论你在那个线程中发布消息都会在不同的线程中接受消息。
  如果你在主线程中发布消息，就会随机的开辟一条子线程来接收消息。
  如果是在子线程中发布消息，就会开辟一条不同的子线程来接收消息。
  
  ### 14.4 粘性事件
  在发送事件之后再订阅该事件也能收到该事件的通知。
  例如，把一个Event发送到一个还没有初始化Fragment，即尚未订阅事件。如果只用Post一个事件，是无法收到通知的。
  如果利用PostSticky的话，会等待Fragment初始化后，再发送通知。此时要注意注册订阅时机不能早与控件的初始化。
  
  ### 14.5 粘性事件使用步骤
  Step1: @Subscribe(sticky=true)
  Step2: EventBus.getDefault().postStick(Object event);
  Step3: removeStickyEvent  移除指定的粘性事件
  
  ### 14.6 事件优先级
  在定义订阅者方法时指定事件传递的优先级。默认情况下，订阅者方法的事件传递优先级为0，数值越大，优先级越高。
  在相同的线程模式下，更高优先级的订阅者方法将优先接收到事件。
  注意：优先级只有在相同的线程模式下才有效。
  
  设置优先级:
  Step1 priority=x(数值越大，优先级越高)
  Step2 EventBus.getDefault().cancelEventDelivery(event); 取消事件订阅后等级低的将不接收该事件。
  
  ### 14.7 EventBus的实现原理
  EventBus的设计理念是基于观察者模式。主要通过三个模块来实现。
  1. 获取实例的过程
  getDefault方法获取实例是通过单例模式双重校验锁的方式来获取。
  builder方式直接获取一个EventBusBuilder对象，然后通过EventBusBuilder可以定制EventBus.
  
  2. 注册
  Step1 首先获取注册的类，
  Step2 通过subscriberMethodFinder实例去查找类中带有Subscribe标注的订阅方法。
  Step3 首先从缓存中去取该订阅者的订阅方法，如果缓存中没有，
  Step4 从当前类开始遍历该类的所有父类，其中会用反射的方法获取用注册声明的订阅方法。当获取了所有的订阅方法后，至此查找订阅者的订阅方法结束。
  Step5 开始注册订阅方法，首先会将观察者和订阅方法封装为一个，Subscription对象。然后对它进行 优先级排序和是否需要粘性处等处理。至此注册流程结束。
  
  3. 通知
  Step1 在post方法中，通过循环事件队列，将事件取出进行处理。
  Step2 在处理的过程中循环查找该事件的所有订阅者，
  Step3 根据ThreadMode,在不同线程中调用订阅者的事件响应函数。
  
  ### 14.8 在EventBus中，使用 @Subscribe 注解的时候指定的 ThreadMode 是如何实现在不同线程间传递数据的？
  会根据当前线程的状态和ThreadMode指定的线程状态来决定在哪个线程触发。
  PostThread模式，不需要线程切换，ThreadMode在哪个线程就在哪个线程进行处理。
  MainThread模式，通过Handle进行线程切换。
  BackgroundThread模式，不是主线程则在发布者线程直接处理事件，否则线程切换至线程池处理。
  Async模式 ，不论是主线程还是子线程，都会重新另起一个新的线程。
  
  ### 14.9 参考文献
  [EventBus使用详解_cyc的专栏-CSDN博客_eventbus](https://blog.csdn.net/u012317510/article/details/78935720)
  [EventBus的粘性事件 - 你要 - 博客园](https://www.cnblogs.com/fuyaozhishang/p/7968059.html)
  [EventBus 源码解析 EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解 @codeKK 开源项目源码分析站](http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)
  [消息框架 EventBus 的实现原理](https://mp.weixin.qq.com/s?__biz=MzA3MzgzMzgyNw==&mid=2247483871&idx=1&sn=da92daf306552ba8dd621d3cc9a4c625&chksm=9f084dd3a87fc4c583dfd45bd337cf20198684f18d2b9160616376bf2fd998a2da3989075833&scene=158#rd)
  
  ## 15 OKHttp (★★★★)
  
  ### 15.1 OKHttp使用步骤
  1. 创建OkHttpClient对象
  2. 创建Request对象
  3. 创建Call对象
  4. 发送请求(execute/enqueue)并获取服务器返回的数据。
  
  ### 15.2 OKHttp中的变种Build模式
  1. 在构建类中创建一个静态内部类Builder。
  2. Builder的参数与构建类一致。
  3. 在构建类的构造方法中，使用Builder的变量一一赋值给构建类。
  4. Builder静态内部类提供参数的setter方法，并且返回值是当前Builder对象。
  5. 提供一个build方法作用是new 一个构建类的对象，参数是当前Builder对象。
  ```
  public class Person {
      /*名字（必须）*/
      private final String name;
      /*性别（必须）*/
      private final String gender;
      /*年龄（非必须）*/
      private final String age;
      /*鞋子（非必须）*/
   
      private Person(Builder builder) {
          this.name = builder.name;
          this.gender = builder.gender;
          this.age = builder.age;
      }
  
      public static class Builder {
          private final String name;
          private final String gender;
          private String age;
  
          public Builder(String name,String gender) {
              this.name = name;
              this.gender = gender;
          }
  
          public Builder age(String age) {
              this.age = age;
              return this;
          }
      }
  ```
  ### 15.3 OKHttp源码分析
  Step1 在OkhttpClient类通过Builder模式对常量进行初始化。
  Step2 创建Request对象。同样通过Builder模式对常量进行初始化。
  Step3 创建Call对象,主要目的是new一个RealCall对象。
  Step4 通过RealCall对象设定是异步请求(enqueue())或同步请求(execute())。
  
  #### 15.3.1 RealCall()中的同步与异步
  情况1：同步请求
  在RealCall中实现了同步方法
  Step1 将RealCall 加入一个双端队列(runningSyncCalls)，runningSyncCalls是用来记录正在运行的同步请求队列。
  Step2 通过getResponseWithInterceptorChain(),返回Response。
  Step3 通过calls.remove(all)把当前RealCall从正在运行的同步请求队列中移除。
  	
  情况2：异步请求
  在RealCall中实现了异步方法
  Step 1 在Dispatcher(分发器)中先判断当前，正在运行的异步请求队列数（即runningAsyncCalls双端队列的大小）小于最大并发请求书，同时判断每个主机正在运行的请求数(即runningCallsForHost)小于每个主机最大请求数。
  如果满足将当前请求继续加入"正在运行的异步请求队列"并在线程池中执行，否则将当前请求加入"准备中的异步请求队列"。
  
  Step 2 通过getResponseWithInterceptorChain(),返回Response的回调。
  
  ##### 15.3.2 getResponseWithInterceptorChain() 拦截器 (重点)
  责任链模式: 拦截器构建成一条责任链，每个拦截器负责相应的功能，上一个拦截器完成会传给下一个拦截器，直到最后一个拦截器执行完再一层层向上返回Response。
  
  源码分析:
  Step1: 构建一条责任链，并把责任链需要用到的参数传过去。
  Step2: 开始处理责任链中的拦截器。
  Step3: 从拦截器集合中取出当前拦截器并调用intercept()方法。
  Step4: 如果完成任务会马上返回Response.
  Step5  否则会在intercept()方法中继续处理责任链。
  
  ##### 15.3.3 重试与重定向拦截器(RetryAndFollowUpInterceptor) 
  主要负责失败后重连以及重定向
  1. 创建StreamAllocation对象，用来协调connections,Stream,Calls之间的关心。
      1）Connections:连接到远程服务器的物理套接字。
      2）Streams:在连接层的逻辑http请求/响应。
      3）Calls:流的逻辑序列,通常是初始请求以及它的重定向请求。
  2. 执行BridgeInterceptor拦截器，
  3. 发送异常进行重试。
     1）客户端配置出错不再重试。
     2）无法再次发送request body。
     3）发生协议,中断,SLL等异常。
     4）没有更多的路线可供尝试。
  
  ##### 15.3.4 桥拦截器(BridgeInterceptor)
  将用户的请求转换为发给服务器的请求，然后使用该请求访问网络，最后将服务器返回的响应转换为用户可用的响应。
  1. 将用户的请求添加一些请求头，并转换为服务器请求。
  2. 执行下一个拦截器进行网络请求。
  3. 将服务器返回的响应转换为用户可用的响应。主要是解析服务器返回的header.
  
  ##### 15.3.5 缓存拦截器(CacheInterceptor)
  主要用来实现缓存的读取和存储，即进行网络请求的时候执行到缓存拦截器会先判断是否有缓存，如果有会直接返回缓存，没有则会执行后面的拦截器继续请求网络，请求成功会将请求到的数据缓存起来。
  1. 通过request 获取cache缓存（Cache底层使用DiskLruCache）
  2. 通过CacheStrategy(缓存策略)判断是使用缓存还是使用网络请求，或者都不使用，直接返回失败，停止后面的拦截器的执行。如果不使用网络请求，则直接返回缓存，然后停止后面拦截器。
  3. 如果从网络获取数据，则会继续执行下一个拦截器。
  4. 最后将请求返回的结果进行缓存。
  
  ##### 15.3.6 连接拦截器(ConnectInterceptor)(重点)
  主要用来打开与目标服务器的连接，然后继续执行下一个拦截器。
  1. 通过newStream方法创建HttpCodec对象。
  1.1 newStream方法中通过findHealthyConnection方法寻找可用的连接,并通过这个链接创建HttpCodec对象。
  1.1.1 findHealthyConnection方法中通过findConnection()方法寻找一个连接，如果是健康链接则不需要后面你的健康检查。如果不健康，则禁止创建新流，并且继续循环查找可用的链接。
  1.1.2 findConnection方法中, 判断当前连接是否可用
    1) 可用则进行复制，直接返回。
    2) 不可用，先从连接池中获取可用连接。
    3) 连接池中没有可用连接，切换不同的路由再次从连接池中获取可用连接。
    4) 还是没有的话，就重新创建一个新的连接。
  1.1.3 通过TCP和TLS进行连接(核心)，并将新创建的连接放到连接池中。
  1.2 通过newStream返回的连接对象，去创建一个HttpCodec对象。
  2. 执行下一个拦截器
  
  ##### 15.3.7 服务器请求拦截器（CallServerInterceptor）
  主要用来向服务器发起请求并获取数据，它是责任链中的最后一个拦截器，获取到服务器的数据后会直接返回给上一个拦截器。
  1. 通过上一个ConnectInterceptor拦截器获取上HttpCodec以及StreamAllocation对象。
  2. 通过HttpCodec以及StreamAllocation向服务器进行读写操作。
  3. 将获取的数据，返回给上一个拦截器。
  
  ### 15.4 ConnectionPool(连接池)
  连接池的作用是从连接池中找到了可用的连接，那么就不用重新创建新的连接，也省去了 TCP 和 TLS 握手。
  1. 连接池中默认设置最大允许空闲的连接数量为 5 个，连接的存活时间为 5 分钟。
  2. get方法，连接池中获取可用的连接，做法是遍历记录连接的双端队列。
  3. put方法，将新创建的连接放进连接池中，做法是先删除无效的连接，然后再将新创建的连接插入到双端队列中。
  
  ### 15.5 okhttp中的线程池的参数 
  ```
  new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
  ```
  1. corePoolSize为0表示，没有核心线程，所有执行请求的线程，使用完了如果过期了就回收。
  2. maximumPoolSize为max_Value 表示无限大的线程池空间
  3. keepAliveTime 为60 表示 线程空闲时存活时间为 60 秒。
  4. SynchronousQueue 表示一个同步队列，它里面每插入一个操作必须等待另一个线程移除之后才能操作。
  5. threadFactory , 创建一个守护线程来处理dispatcher类。
  
  ### 15.6 总结
  okHttp用到的有build模式，责任链模式，其核心是通过拦截器形成责任链，每个拦截器负责相应的功能，发送的请求通过拦截器由上到下依次执行，响应的数据依次从下往上。而底层连接方式是通过socket进行通信。
  
  ### 15.7 参考文献
  [Android 主流开源框架（二）OkHttp 使用详解 - 掘金](https://juejin.im/post/6844903970662514701#heading-8)
  [Android 主流开源框架（三）OkHttp 源码解析 - 掘金](https://juejin.im/post/6844903975091699726)
  [Java 大白话讲解设计模式之 -- 建造者（Builder）模式 - 简书](https://www.jianshu.com/p/afe090b2e19c)
  [Android-OkHttp3-分发器和线程池配置 - 简书](https://www.jianshu.com/p/da4a526a9d72)
  [腾讯被面Okhttp3 惨挂，我总结了一套学习心得 - 知乎](https://zhuanlan.zhihu.com/p/160788977)
  [OkHttp3(六)--Dispatcher - 简书](https://www.jianshu.com/p/efc6faa7a8a0)
  
  ## 16 Handler,MessageQueue与Looper关系（★★★★★）
  1. Message:
  Handler接收和处理消息的对象。
  
  2. Looper:
  每个线程只能有一个Looper。它的loop方法负责读取MessageQueue中的消息，读到消息后把消息发送给Handler进行处理。
  
  3. MessageQueue:
  消息队列，它采用先进先出的方式来管理Message。程序创建Looper对象时，会在它的构造方法中创建MessageQueue对象。
  
  4. Handler:
  作用有两个发送消息和与处理消息,程序使用Handler发送消息，由Handler发送的消息必须被送到指定的MessageQueue;否则消息就没有在MessageQueue进行保存了。
  而MessageQueue是由Looper负责管理的，如果希望Handler正常工作的话，就必须在当前线程中有一个Looper对象。
  
  ### 16.1 Handler构造方法源码
  ```
  public class Handler {
  	/**
  	 * 未实现的空方法handleMessage（）
  	 */
  	public void handleMessage(Message msg) {
  	}
  	/**
  	 * 我们通常用于创建Handler的构造方法之一
  	 */
  	public Handler() {
  		this(null, false);
  	}
  	// 构造方法的内调用的this(null, false)的具体实现
  	public Handler(Callback callback, boolean async) {
  //检查Handler是否是static的，如果不是的，那么有可能导致内存泄露
          if (FIND_POTENTIAL_LEAKS) {  
              final Class<? extends Handler> klass = getClass();  
              if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&  
                      (klass.getModifiers() & Modifier.STATIC) == 0) {  
                  Log.w(TAG, "The following Handler class should be static or leaks might occur: " +  
                      klass.getCanonicalName());  
              }  
          }  
          //获取当前进程的looper对象
          mLooper = Looper.myLooper();   
          if (mLooper == null) {  
              //Handler是必须在有Looper的线程上执行，这个也就是为什么我在HandlerThread中初始化Handler  
              //而没有在Thread里面初始化，如果在Thread里面初始化需要先调用Looper.prepare方法  
              throw new RuntimeException(  
                  "Can't create handler inside thread that has not called Looper.prepare()");  
          }  
          //将mLooper里面的消息队列复制到MessageQueue的mQueue,这也就意味着Handler和Looper是公用一个消息队列  
          mQueue = mLooper.mQueue; 
          //回调函数默认是Null  
          mCallback = null;  
  	}
  ```
  在创建Handler时，Handler内部会去创建一个Looper对象，这个Looper对象是通过Looper.myLooper()创建的(后续会分析这个方法)，同时还会创建一个消息队列MessageQueue，而这个MessageQueue是从Looper中获取的，这也就意味着Handler和Looper共用一个消息队列，当然此时Handler,Looper以及MessageQueue已经捆绑到一起了。
  
  ```
  if (mLooper == null) {  
    //Handler是必须在有Looper的线程上执行，这个也就是为什么我在HandlerThread中初始化Handler  
    //而没有在Thread里面初始化，如果在Thread里面初始化需要先调用Looper.prepare方法  
    throw new RuntimeException(  
      "Can't create handler inside thread that has not called Looper.prepare()");  
    }  
  ```
  判断Looper是否为空，如果为null，那么就会报错，在前面说过Handler的作用有两个—发送消息和处理消息，使用Handler发送消息，由Handler发送的消息必须被送到指定的MessageQueue;否则就无法进行消息循环。而MessageQueue是由Looper负责管理的，也就是说，如果希望Handler正常工作的话，就必须在当前线程中有一个Looper对象。
  为了保证Handler一定有Looper线程，需要分两种情况:
  1. 主UI线程中，系统已经初始化好了一个Looper对象，因此我们可以直接创建Handler并使用即可。
  2. 在子线程中，必须自己手动去创建一个Looper对象，并且去启动它，才可以使用Handler进行消息发送与处理,如下。
  ```
  class childThread extends Thread{
          public Handler mHandler;
   
          @Override
          public void run() {
              //子线程中必须先创建Looper
              Looper.prepare();
              
              mHandler =new Handler(){
                  @Override
                  public void handleMessage(Message msg) {
                      super.handleMessage(msg);
                      //处理消息
                  }
              };
              //启动looper循环
              Looper.loop();
          }
      }
  ```
  
  ### 16.2 Handler主要方法源码
  ```
  // 发送一个空消息的方法，实际上添加到MessagerQueue队列中
  public final boolean sendEmptyMessage(int what) {
  	return sendEmptyMessageDelayed(what, 0);
  }
  // 给上一个方法调用
  public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
  	Message msg = Message.obtain();
  	msg.what = what;
  	return sendMessageDelayed(msg, delayMillis);
  }
  // 给上一个方法调用
  public final boolean sendMessageDelayed(Message msg, long delayMillis) {
  	if (delayMillis < 0) {
  		delayMillis = 0;
  	}
  	return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
  }
  // 给上一个方法调用
  public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
  	MessageQueue queue = mQueue;
  	if (queue == null) {
  		RuntimeException e = new RuntimeException(this
  				+ " sendMessageAtTime() called with no mQueue");
  		Log.w("Looper", e.getMessage(), e);
  		return false;
  	}
  	return enqueueMessage(queue, msg, uptimeMillis);
  }
  // 最后调用此方法添加到消息队列中
  private boolean enqueueMessage(MessageQueue queue, Message msg,
  		long uptimeMillis) {
  	msg.target = this;// 设置发送目标对象是Handler本身
  	if (mAsynchronous) {
  		msg.setAsynchronous(true);
  	}
  	return queue.enqueueMessage(msg, uptimeMillis);// 添加到消息队列中
  }
  // 在looper类中的loop（）方法内部调用的方法
  public void dispatchMessage(Message msg) {
  	if (msg.callback != null) {
  		handleCallback(msg);
  	} else {
  		if (mCallback != null) {
  			if (mCallback.handleMessage(msg)) {
  				return;
  			}
  		}
  		handleMessage(msg);
  	}
  }
  ```
  通过源码，当调用sendEmptyMessage(int)发送消息后。最终Handler内部会去调用enqueueMessage(MessageQueue queue,Message msg)方法把发送的消息添加到消息队列MessageQueue中，同时还有设置msg.target=this此时就把当前handler对象绑定到msg.target中了，这样就完成了Handler向消息队列存放消息的过程。
  
  在Android中的消息队列指的也是MessageQueue，MessageQueue主要包含了两种操作，插入和读取，而读取操作本身也会伴随着删除操作，插入和读取对应的分别是enqueueMessage和next，其中enqueueMessage是向消息队列中插入一条消息，而next的作用则是从消息队列中取出一条消息并将其从队列中删除。虽然一直称其为消息队列但是它的内部实现并不是队列，而是通过一个**单链表的数据结构**来维护消息列表的。
  ### 16.3 Looper 源码
  ```
  public final class Looper {
  	// sThreadLocal.get() will return null unless you've called prepare().
  	//存放线程的容器类,为确保获取的线程和原来的一样
  	static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
  	private static Looper sMainLooper; // guarded by Looper.class
  	//消息队列
  	final MessageQueue mQueue;
  	final Thread mThread;
  	//perpare()方法，用来初始化一个Looper对象
  	public static void prepare() {
  		prepare(true);
  	}
  		
  	private static void prepare(boolean quitAllowed) {
  		if (sThreadLocal.get() != null) {
  		throw new RuntimeException("Only one Looper may be created per thread");
  		}
  		sThreadLocal.set(new Looper(quitAllowed));
  	}
  	//handler调用的获取Looper对象的方法。实际是在ThreadLocal中获取。
  	public static Looper myLooper() {
  		return sThreadLocal.get();
  	}
  		
  	//Looper类的构造方法，可以发现创建Looper的同时也创建了消息队列MessageQueue对象
  	private Looper(boolean quitAllowed) {
  		mQueue = new MessageQueue(quitAllowed);
  		mRun = true;
  		mThread = Thread.currentThread();
  	}
  		
  //这个方法是给系统调用的，UI线程通过调用这个线程，从而保证UI线程里有一个Looper  
  //需要注意：如果一个线程是UI线程，那么myLooper和getMainLooper是同一个Looper 
        public static final void prepareMainLooper() {  
  	prepare();  
  	setMainLooper(myLooper());  
  	if (Process.supportsProcesses()) {  
  	 myLooper().mQueue.mQuitAllowed = false;  
  	        }  
  	}  
  	  
  //获得UI线程的Looper,通常我们想Hanlder的handleMessage在UI线程执行时通常会new  Handler(getMainLooper());  
         public synchronized static final Looper getMainLooper() {  
  	        return mMainLooper;  
        }  
  		
  //looper中最重要的方法loop()，该方法是个死循环，会不断去消息队列MessageQueue中获取消息，然后调dispatchMessage(msg)方法去执行
        public static void loop() {
  	final Looper me = myLooper();
  	if (me == null) {
  		throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
  		}
  	    final MessageQueue queue = me.mQueue;
  	    //死循环
  	    for (;;) {
  		Message msg = queue.next(); // might block
  		if (msg == null) {
  		// No message indicates that the message queue is quitting.
  				return;
  		}
  //这里其实就是调用handler中的方法，而在Handler的源码中也可以知道dispatchMessage(msg)内部调用的就是handlerMessage()方法
  		msg.target.dispatchMessage(msg);
  		msg.recycle();
  	}
  }
  ```
  1. Looper 的创建
  
  ```
  //perpare()方法，用来初始化一个Looper对象
  public static void prepare() {
  	prepare(true);
  }
  		
  private static void prepare(boolean quitAllowed) {
  if (sThreadLocal.get() != null) {
  	throw new RuntimeException("Only one Looper may be created per thread");
  	}
  	sThreadLocal.set(new Looper(quitAllowed));
  }
  
  ```
  通过源码可以知道perpare()方法就可以创建Looper对象,在创建Looper对象前先会去判断ThreadLocal中是否已经存在Looper对象，如果不存在就新创建一个Looper对象并且存放ThreadLocal中。
  ```
  //Looper类的构造方法，可以发现创建Looper的同时也创建了消息队列MessageQueue对象
  	private Looper(boolean quitAllowed) {
  		mQueue = new MessageQueue(quitAllowed);
  		mRun = true;
  		mThread = Thread.currentThread();
  	}
  ```
  **这里还有一个要注意的是在Looper创建的同时MessageQueue消息队列也被创建完成**，这样的话Looper中就持有了MessageQueue对象。
  2. 获取Looper对象：
  ```
  //handler调用的获取Looper对象的方法。实际是在ThreadLocal中获取。
  	public static Looper myLooper() {
  		return sThreadLocal.get();
  	}
  ```
  通过源码知道myLooper()方法就可以获取到Looper对象
  
  3. Looper管理MessageQueue对象
  ```
  //looper中最重要的方法loop()，该方法是个死循环，
  //会不断去消息队列MessageQueue中获取消息，
  //然后调dispatchMessage(msg)方法去执行
        public static void loop() {
  	final Looper me = myLooper();
  	if (me == null) {
  		throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
  		}
  	    final MessageQueue queue = me.mQueue;
  	    //死循环
  	    for (;;) {
  		Message msg = queue.next(); // might block
  		if (msg == null) {
  		// No message indicates that the message queue is quitting.
  				return;
  		}
  //这里其实就是调用handler中的方法，而在Handler的源码中也可以知道dispatchMessage(msg)内部调用的就是handlerMessage()方法
  		msg.target.dispatchMessage(msg);
  		msg.recycle();
  	}
  ```
  通过looper()方法内部源码可以知道，首先会通过myLoooper()去获取一个Looper对象，如果Looper对象为null，就会报出一个非常熟悉的错误提示，“No Looper;Looper.prepare() wasn't called on this thread”,要求我们先通过Looper.prepare()方法去创建Looper对象；如果Looper不为null，那么就会去获取消息队列MessageQueue对象，接着就进入一个for的死循环，不断从消息队列MessageQueue对象中获取消息，如果消息不为空，那么久会调用msg.target的dispatchMessage(Message)方法，msg.target就是创建的Handler对象(msg.target=this);
  ```
  // 在looper类中的loop()方法内部调用的方法
  public void dispatchMessage(Message msg) {
  	if (msg.callback != null) {
  		handleCallback(msg);
  	} else {
  		if (mCallback != null) {
  			if (mCallback.handleMessage(msg)) {
  				return;
  			}
  		}
  		handleMessage(msg);
  	}
  ```
  首先，检测Message的callback是否为null，不为null就通过handleCallback方法来处理消息,接着会去检查mCallback是否为null，不为null，则调用mCallback的handleMessage回调方法来处理消息。
  最后如果以上条件都不成立的话，就会去调用Handler的handleMessage方法来处理消息。而 我们的Handler是在主线程创建的，也就是说Looper也是主线程的Looper，因此handleMessage内部处理最终都会在主线程上执行，
  
  ![20160304230155772.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\c6c56a57.png)
  
  ### 16.4 Handler总结
  Android中的Looper类主要作用是用来**封装消息循环和消息队列**，Handler是用来**向消息队列中插入消息的并对消息进行处理**。
  
  (1) Looper类主要是为每个线程开启的单独的消息循环。 默认情况下android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环） Looper对象负责管理MessageQueue，而MessageQueue主要是用来存放handler发送的消息，而且一个线程只能有一个Looper，对应一个MessageQueue。
  
  (2) 我们通常是通过Handler对象来与Looper进行交互的。Handler可看做是Looper的一个接口，用来向指定的Looper中的MessageQueue发送消息并且Handler还必须定义自己的处理方法。 默认情况下Handler会与其被定义时所在线程的Looper绑定，如Handler在主线程中定义，它是与主线程的Looper绑定。 
  mainHandler = new Handler() 等价于 new Handler（Looper.myLooper()）
  Looper.myLooper(),获取当前**进程**的looper对象， 
  Looper.getMainLooper() 用于获取**主线程**的Looper对象。 
  
  (3) 在非主线程中直接new Handler() 会报如下的错误:  Can't create handler inside thread that has not called Looper.prepare() 原因是非主线程中默认没有创建Looper对象，需要先调用Looper.prepare()启用Looper，然后再调用Looper.loop()。
  
  (4) Looper.loop():启动looper中的循环线程，Handler就会从消息队列里取消息并进行对应处理。 
  最后要注意的是写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop()才会中止，其后的代码才能得以运行。
  
  ### 16.5 参考文献
  [深入Android的消息机制源码详解～Handler,MessageQueue与Looper关系_zejian的博客-CSDN博客](https://blog.csdn.net/javazejian/article/details/50791598)
  
  ## 17 OOM内存泄漏(★★★★)
  
  内存泄漏原因：堆上分配的对象已经不会再使用，但是GC收集器无法对其进行回收，此对象被强应用所引用 。
  
  ### 17.1 非静态内部类导致内存泄露（Handler泄漏）
  
  #### 17.1.1 发生原因
  当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会**隐式**地持有一个外部类对象（通常是一个Activity）的引用，而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕之后，通过消息机制通知Handler，然后Handler把图片更新到UI界面。然而，如果用户在网络请求过程中关闭了Activity，GC在检查时，由于这时线程尚未执行完，而该线程持有Handler的引用，Handler又持有Activity的引用，就导致该Activity无法被回收，导致内存泄漏。
  
  #### 17.1.2 应用场景
  ```
  private Handler handler = new Handler()
   {
        public void handleMessage(android.os.Message msg)
  　　　　 {
              if (msg.what == 1) 
  　　　　　　　　{
                  noteBookAdapter.notifyDataSetChanged();
               }
          }
   };
  ```
  #### 17.1.2 解决方法
  解决方案：
  1. 通过程序逻辑来进行保护。
  在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。 
  如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。
  
  2. 将Handler声明为静态类+WeakReference
  在Java 中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用，静态的内部类不会持有外部类的引用。
  静态类不持有外部类的对象，所以你的Activity可以随意被回收。由于Handler不再持有外部类对象的引用，导致程序不允许你在Handler中操作Activity中的对象了。所以你需要在Handler中增加一个对Activity的弱引用（WeakReference）。
  
  WeakReference：弱引用的对象拥有短暂的生命周期。在垃圾回收器线程扫描时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
  ```
  static class MyHandler extends Handler
      {
          WeakReference<Activity> mWeakReference;
          public MyHandler(Activity activity) 
          {
              mWeakReference=new WeakReference<Activity>(activity);
          }
          @Override
          public void handleMessage(Message msg)
          {
              final Activity activity=mWeakReference.get();
              if(activity!=null)
              {
                  if (msg.what == 1)
                  {
                      noteBookAdapter.notifyDataSetChanged();
                  }
              }
          }
      }
  ```
  ### 17.2 单例导致内存泄露
  #### 17.2.1 发生原因
  单例的静态特性使得它的生命周期同应用程序的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。
  
  #### 17.2.2 应用场景
  ```
  public class DimenUtil {
      private Context mContext;
      private static DimenUtil instance;
   
      public DimenUtil(Context context) {
          this.mContext = context;
      }
   
      public static synchronized DimenUtil getInstance(Context context) {
          if(instance == null) {
              instance = new DimenUtil(context);
          }
   
          return instance;
      }
   
      public float dip2px(float dipValue) {
          float scale = this.mContext.getResources().getDisplayMetrics().density;
          return dipValue * scale + 0.5F;
      }
  }
  ```
  上面它是一个单例类，如果在调用DimenUtil.getInstance(Context context)方法的时候传入的context参数是Activity、Service等上下文，就会导致内存泄露。
  以Activity为例，当启动一个Activity，并调用DimenUtil.getInstance(Context context)方法去获DimenUtil的单例，传入Activity.this作为context，这样DimenUtil类的单例instance就持有了Activity的引用，当我们退出Activity时，该Activity就没有用了，但是因为intance作为静态单例（在应用程序的整个生命周期中存在）会继续持有这个Activity的引用，导致这个Activity对象无法被回收释放，这就造成了内存泄露。
  
  #### 17.2.3 解决方法
  为了避免这样单例导致内存泄露，可以将context参数改为全局的上下文。
  ```
  public DimenUtil(Context context) {
      this.mContext = context.getApplicationContext();
  }
  ```
  ### 17.3 WebView导致的内存泄漏
  不同安卓版本的WebView会有差异，加上不同厂商的定制ROM的WebView的差异，这就导致WebView存在很大的兼容性问题。WebView都会存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。即使是调用了它的destroy方法，依然会导致内存泄漏。
  
  #### 17.3.2 解决办法
  其实避免WebView导致内存泄漏的最好方法就是让WebView所在的Activity处于另一个进程中，使用AIDL与应用的主进程进行通信。WebView进程可以根据业务需求，在合适的时机进行销毁。
  
  ### 17.4 Adapter 持有 Activity的对象导致内存泄漏
  
  #### 17.4.1 发生原因
  如果建立一个专门存放Adapter类的Package包,首先在初始adapter的时候会传入context,这时adapter就持有了Activity引用，如果我们在adapter中进行耗时操作（比如加载图片之类的），并且finish Activity，虽然此时Activity销毁了，但是GC是无法回收activity的，这样就发生了内存泄漏。
  #### 17.4.2 应用场景
  ```
  //外面的Adapter类
  public class ExampleAdapter extends BaseAdapter {
      private Context mContext;
      public ExampleAdapter(Context context) {
          this.mContext = context;
      }
  
      @Override
      public View getView(int position, View convertView, ViewGroup parent) {
          if (convertView == null) {
              //这里也用到了activity的引用
              convertView = LayoutInflater.from(mContext).inflate(R.layout.list_item, null);
          }
          return convertView;
  }
  
  //MainActivity代码展示
  public class MainActivity extends Activity {
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          ListView listView = (ListView) findViewById(R.id.listView);
          //这里将activity对象传入adapter
          ExampleAdapter adapter = new ExampleAdapter(this);
          listView.setAdapter(adapter);
      }
  }
  ```
  #### 17.4.3 解决方法
  将Adapter写成静态内部类写在Activity里面。
  
  ### 17.5 资源未关闭导致的内存泄漏
  在Activity销毁的时候要及时关闭或者注销。
  1. BraodcastReceiver：调用unregisterReceiver()注销；
  2. Cursor，Stream、File：调用close()关闭；
  3. Bitmap：调用recycle()释放内存（2.3版本后无需手动）。
  
  ### 17.6参考文献
  [内存泄漏的场景_wanghong940821的博客-CSDN博客](https://blog.csdn.net/wanghong940821/article/details/79439569?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-2-79439569.nonecase&utm_term=oom%20%E5%87%BA%E7%8E%B0%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF&spm=1000.2123.3001.4430)
  [Android开发——告诉你Adapter应该写在Activity里面还是外面 - 齐天大猴子 - 博客园](https://www.cnblogs.com/qitian1/p/6461501.html)
  
  ## 18 ANR的场景(★★★★★)
  
  ### 18.1 发生ANR的具体表现
  Android系统中，ActivityManagerService(简称AMS)和WindowManagerService(简称WMS)会检测App的响应时间，如果App在特定时间无法相应屏幕触摸或键盘输入时间，或在主线程(UI线程)里面做了太多的阻塞耗时操作,系统会向用户显示一个对话框，这个对话框称作“应用程序无响应”（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，也可以选择“强制关闭”。
  
  ### 18.2 导致ANR的场景
  1. 当前事件正在处理 但是由于耗时太长没有能及时的完成;
  2. 在BroadcastReceiver里做耗时的操作或计算；
  3. CPU使用过高；
  4. 发生了死锁；
  5. 耗时操作的动画需要大量的计算工作；
  
  ### 18.3 ANR的条件
  InputDispatching Timeout：5秒内无法响应屏幕触摸事件或键盘输入事件
  BroadcastQueue Timeout ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒。
  Service Timeout ：前台服务20秒内，后台服务在200秒内没有执行完毕。
  ContentProvider Timeout ：ContentProvider执行超时，20s
  
  ### 18.4 ANR日志分析
  通过ADB将记录ANR的log,traces.txt文档导出，可以查看ANR的原因，进程id，包名，以及具体行数
  ```
  $adb pull data/anr/traces.txt .
  ```
  #### 18.4.1 CPU负载
  ```
  Load: 2.62 / 2.55 / 2.25
  CPU usage from 0ms to 1987ms later (2020-03-10 08:31:55.169 to 2020-03-10 08:32:17.156):
    41% 2080/system_server: 28% user + 12% kernel / faults: 76445 minor 180 major
    26% 9378/com.xiaomi.store: 20% user + 6.8% kernel / faults: 68408 minor 68 major
  ........省略N行.....
  66% TOTAL: 20% user + 15% kernel + 28% iowait + 0.7% irq + 0.7% softirq
  ```
  ```
  * 第一行：1、5、15 分钟内正在使用和等待使用CPU 的活动进程的平均数
  * 第二行：表明负载信息抓取在ANR发生之后的0~1987ms。同时也指明了ANR的时间点：2020-03-10 08:31:55.169
  * 中间部分：各个进程占用的CPU的详细情况
  * 最后一行：各个进程合计占用的CPU信息。
  ```
  名词解释：
  - user:用户态,kernel:内核态
  - faults:内存缺页，minor——轻微的，major——重度，需要从磁盘拿数据
  - iowait:IO使用（等待）占比
  - irq:硬中断，softirq:软中断
  
  注意：
  主要关注iowait关键字，若iowait占比很高，意为有很大可能是io耗时导致ANR。
  
  #### 18.4.2 内存信息
  ```
  Total number of allocations 476778　　进程创建到现在一共创建了多少对象
  Total bytes allocated 52MB　进程创建到现在一共申请了多少内存
  Total bytes freed 52MB　　　进程创建到现在一共释放了多少内存
  Free memory 777KB　　　 不扩展堆的情况下可用的内存
  Free memory until GC 777KB　　GC前的可用内存
  Free memory until OOME 383MB　　OOM之前的可用内存
  Total memory 当前总内存（已用+可用）
  Max memory 384MB 进程最多能申请的内存
  ```
  注意：
  1. 若Free memory until OOME的值很小，说明处于内存紧张状态，ANR可能由于应用占用过多内存。
  2. 若ANR时间点前后，在LogCat日志中含有onTrimMemory，说明已经处于内存紧张状态。
  
  #### 18.4.3 堆栈消息
  ```
  suspend all histogram:  Sum: 2.834s 99% C.I. 5.738us-7145.919us Avg: 607.155us Max: 41543us
  DALVIK THREADS (248):
  "main" prio=5 tid=1 Native
    | group="main" sCount=1 dsCount=0 flags=1 obj=0x74b17080 self=0x7bb7a14c00
    | sysTid=2080 nice=-2 cgrp=default sched=0/0 handle=0x7c3e82b548
    | state=S schedstat=( 757205342094 583547320723 2145008 ) utm=52002 stm=23718 core=5 HZ=100
    | stack=0x7fdc995000-0x7fdc997000 stackSize=8MB
    | held mutexes=
    kernel: __switch_to+0xb0/0xbc
    kernel: SyS_epoll_wait+0x288/0x364
    kernel: SyS_epoll_pwait+0xb0/0x124
    kernel: cpu_switch_to+0x38c/0x2258
    native: #00 pc 000000000007cd8c  /system/lib64/libc.so (__epoll_pwait+8)
    native: #01 pc 0000000000014d48  /system/lib64/libutils.so (android::Looper::pollInner(int)+148)
    native: #02 pc 0000000000014c18  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+60)
    native: #03 pc 0000000000127474  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)
    at android.os.MessageQueue.nativePollOnce(Native method)
    at android.os.MessageQueue.next(MessageQueue.java:330)
    at android.os.Looper.loop(Looper.java:169)
    at com.android.server.SystemServer.run(SystemServer.java:508)
    at com.android.server.SystemServer.main(SystemServer.java:340)
    at java.lang.reflect.Method.invoke(Native method)
    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:536)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:856)
     
    ........省略N行.....
     
    "OkHttp ConnectionPool" daemon prio=5 tid=251 TimedWaiting
    | group="main" sCount=1 dsCount=0 flags=1 obj=0x13daea90 self=0x7bad32b400
    | sysTid=29998 nice=0 cgrp=default sched=0/0 handle=0x7b7d2614f0
    | state=S schedstat=( 951407 137448 11 ) utm=0 stm=0 core=3 HZ=100
    | stack=0x7b7d15e000-0x7b7d160000 stackSize=1041KB
    | held mutexes=
    at java.lang.Object.wait(Native method)
    - waiting on <0x05e5732e> (a com.android.okhttp.ConnectionPool)
    at com.android.okhttp.ConnectionPool$1.run(ConnectionPool.java:103)
    - locked <0x05e5732e> (a com.android.okhttp.ConnectionPool)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
    at java.lang.Thread.run(Thread.java:764)
  
  ```
  | Java Thread 状态 | Cpp Thread 状态  | 说明                                     |
  | ---------------- | ---------------- | ---------------------------------------- |
  | TERMINATED       | ZOMBIE           | 线程死亡，终止运行                       |
  | RUNNABLE         | RUNNING/RUNNABLE | 线程可运行或正在运行                     |
  | TIMED_WAITING    | TIMED_WAIT       | 执行了带有超时参数的wait,sleep或join函数 |
  | BLOCKED          | MONITOR          | 线程阻塞，等待获取对象锁                 |
  | WAITING          | WAIT             | 执行了无超时参数的wait函数               |
  | NEW              | INITIALIZING     | 新建，正在初始化，为其分配资源           |
  | NEW              | STARTING         | 新建，正在启动                           |
  | RUNNABLE         | NATIVE           | 正在执行JNI本地函数                      |
  | WAITING          | VMWAIT           | 正在等待VM资源                           |
  | RUNNABLE         | SUSPENDED        | 线程暂停，通常是由于GC或debug被暂停      |
  |                  | UNKNOWN          | 未知状态                                 |
  
  注意：
  main线程处于BLOCK,WAITING,TIMEWAITING状态，可以确定函数阻塞导致ANR.;
  
  
  
  ### 18.5 ANR其它分析方式
  #### 18.5.3 通过DDMS Update Thread工具查看
  通过DDMS Update Threads工具查看该进程下的所有线程状态。需要注意的是main线程中的调用栈信息，以及线程状态，正常情况下main线程应当是处于空闲等待状态，如果长时间处于处理某一个任务时就会导致其他被发送到主线程的事件无法被及时处理，导致ANR,如果线程状态是MONITOR状态，就可能是ANR。(JVM中10种线程状态)。
  
  ### 18.5.4 Traceview
  Traceview是分析工具，用于定位应用代码中的耗时操作。
  
  ### 18.5.5 Systrace 
  Android4.1新增的应用性能数据采样和分析工具
  
  ### 18.6 ANR的处理
  1. 开辟单独的子线程来处理耗时阻塞事务，通过继承Thread或实现Runnable接口。
  2. 使用AsyncTask,通过AsyncTask异步执行。继承AsyncTask,在doInBackground中实现耗时操作，然后在onProgressUpdate或onPostExecute回调方法中实现接收结果，最后通过执行execute执行AsyncTask。
  3. 使用Handler,HandlerThread来对UI进行更新。
  4. Activity的onCreate和onResume回调中尽量避免耗时的代码，应该尽可能的做比较少的事情
  5. BoadcastReceiver中onReceive代码也要尽量减少耗时
  
  ### 18.7 参考文献
  [Android App优化之ANR详解 - 简书](https://www.jianshu.com/p/6d855e984b99)
  [Android应用ANR分析 - 简书](https://www.jianshu.com/p/30c1a5ad63a3)
  [理解Android ANR的触发原理 - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2016/07/02/android-anr/)
  [ANR日志分析汇总_yaoming168的博客-CSDN博客_anr日志分析](https://blog.csdn.net/yaoming168/article/details/119782869?spm=1001.2014.3001.5502)
  
  ## 19 ListView 与 RecycleView 学习 
  
  ### 19.1 ListView 学习
  
  #### 19.1.1 什么是ListView
  ListView是一个可以将数据以动态滚动的方式展示给用户的一种View
  
  #### 19.1.2 为什么要用Adapter
  Adapter在listView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁去访问真正的数据源。Adapter其实是一个统一的接口。
  
  #### 19.1.3 ListView的复用机制
  ![434e6a29.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\434e6a29.png)
  **该机制是由ListView的父类AbsListView中的内部类RecycleBin来完成**
  RecycleBin是实现复用的关键类，首先当我们在屏幕上滑动视图，滑动的View会通过RecycleBin存储到，
  mActivityView的数组中，当滑动listView的时候，有些View被滑动到屏幕之外,已经无法与用户进行交互了，
  成了废弃的View,将会被RecycleBin存储到mScrapView数组中，**但是没有销毁**,目的是为了再次复用。
  当新的View需要显示的时候，先判断mActivityView中是否存在，如果存在直接取出，如果不存在从mScrapView数组中进行判断，
  如果存在，就二次复用当前的视图，如果还不存在，表示没有复用的数据，需要重新inflater数据。
  
  #### 19.1.4 ListView的性能优化
  1. 在ListView的Adapter中复用getView方法中的convertView.
  2. 使用静态内部类ViewHolder,持有Item中控件的引用，从而减少findViewByld的调用次数。
  3. getView中尽量少使用逻辑。
  4. 如果是网络加载图片的话，通过监听listView的滑动状态来判断是否记载。
  
  ### 19.2 RecycleView 学习
  
  #### 19.2.1 什么是RecycleView 
  RecycleView是Android5.0后谷歌推出的一个用于在有限的窗口中展示大量数据集的控件，可以实现与ListView和GridView一样的效果，而且还提供针三种自定样式的功能接口，LayoutManager(布局管理)，ItemDecoration(自定义分割线),ItemAnimator(item动画效果)
  
  #### 19.2.2 RecycleView的adapter的使用
  首先继承RecycleView.Adapter,并传入一个继承自Recycle.viewHolder的静态内部类，这个内部类的作用初始化item布局中的子控件。
  然后实现，onCreateViewHolder，onBindViewHolder，getItemCount三个方法。
  
  #### 19.2.3 RecycleView的四级缓存
  | 缓存级别 | 实际变量                      |
  | -------- | ----------------------------- |
  | 一级缓存 | mAttachedScrap和mChangedScrap |
  | 二级缓存 | mCachedViews                  |
  | 三级缓存 | ViewCacheExtension            |
  | 四级缓存 | 根据ViewType来缓存ViewHolder  |
  
  mAttachedScrap和mChangedScrap：
  RecycleView在获取ViewHolder时，优先会到这两个缓存来找。
  mAttachedScrap**存储的是从屏幕上分离出来，但又即将添加到屏幕上去的ViewHolder**(RecyclerView上下滑动，滑出一个新的Item,此时会重新调用LayoutManager的onLayoutChildren方法，从而会将屏幕上所有的ViewHolder先舍弃掉，添加到mAttachedScrap里面去，然后在重新布局每个ItemView时，会从优先mAttachedScrap里面获取。)
  mChangedScrap**存储的是数据被更新的ViewHolder**,比如说调用了Adapter的notifyItemChanged方法，
  
  mCachedViews: 
  存储预加载的ViewHolder,也会存储回收时的ViewHolder.默认大小为2，通常是3，3由默认的大小2+预取的个数1。
  
  ViewCacheExtension：
  自定义缓存,通常用不到。
  
  RecycleViewPool：
  根据ViewType来缓存ViewHolder,每个ViewType的数组大小为5，可以动态的改变。
  
  ### 19.3 参考文献
  [Android学习笔记之ListView复用机制 - 代码丶如风 - 博客园](https://www.cnblogs.com/RGogoing/p/5554086.html)
  [Android ListView_Android中高级开发 - SegmentFault 思否](https://segmentfault.com/a/1190000013260044)
  [Android控件RecyclerView的基本用法 - 中国人醒来了 - 博客园](https://www.cnblogs.com/it-tsz/p/11371336.html)
  
  ## 20 Systrace 学习使用
  ### 20.1 什么是Systrace 
  是Android中自带的一种性能数据采集和分析工具，通过收集Framework部分关键模块，I/O操作，CPU负载以及内核运行信息，可以帮助
  开发者直观的分析系统瓶颈，改进性能。
  
  ## 21. MMKV 学习使用
  ### 21.1 什么是MMKV
  MMKV腾讯开发的基于mmap内存映射的Key-value组件，底层序列化/反序列化使用protobuf实现，
  性能高，稳定性强，支持多进程。
  
  ### 21.2 MMKV导入依赖
  ```
  dependencies {
      implementation 'com.tencent:mmkv-static:1.2.7'
      // replace "1.2.7" with any available version
  }
  ```
  ### 21.3 MMKV初始化操作
  ```
  public void onCreate() {
      super.onCreate();
  
      String rootDir = MMKV.initialize(this); //初始化路径
      System.out.println("mmkv root: " + rootDir);
      //……
  }
  ```
  ### 21.4 MMKV使用
  ```
  import com.tencent.mmkv.MMKV; //全局的实例
  //……
  
  MMKV kv = MMKV.defaultMMKV(); //普通使用方式
  
  kv.encode("bool", true);
  boolean bValue = kv.decodeBool("bool");
  
  kv.encode("int", Integer.MIN_VALUE);
  int iValue = kv.decodeInt("int");
  
  kv.encode("string", "Hello from mmkv");
  String str = kv.decodeString("string");
  
  
  MMKV kv = MMKV.mmkvWithID("MyID"); //根据不同业务绑定ID使用
  kv.encode("bool", true);
  
  MMKV kv = MMKV.mmkvWithID("InterProcessKV", MMKV.MULTI_PROCESS_MODE); //多进程访问使用
  kv.encode("bool", true);
  
  ```
  ### 21.5 MMKV支持的数据类型
  - 支持Java语言基础类型:
    boolean、int、long、float、double、byte[]
  - 支持以下Java类和容器:
    String、Set<string!>任何实现了Parcelable的类型
  
  ### 21.6 MMKV原理
  mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程
  虚拟地址中一端虚拟地址的一一对应关系。实现这样的映射关系后，进程就可以采用指针的方法读写操作这一端内存。
  而系统会自动回写脏页面倒对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。
  ![2c962d8c0e03430298378a2c84779ff3_tplv-k3u1fbpfcp-watermark.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\88f45754.png)
  虚拟空间是某个进程对分配给它的所有物理地址的重新映射。mmap的作用，在应用的一层，是把文件的某一端，当作内存一样来访问。
  通过mmap内存映射文件，提供一段可供随时写入的内存块，App只管往里面写数据，由于操作系统负责将内存写到文件，不必担心crash导致数据丢失。
  
  ### 21.7 MMKV解决的问题
  - 单进程通信方面：
  MMKV可以解决SharedPreferences不能直接跨进程通信的问题，但SharedPreferences也可以通话ContentProvider或者文件锁等方式解决问题。MMKV的主要优势，一方面SharedPreferences可能导致Activity/Service等生命周期去做waitToFinish()导致ANR问题，而MMKV不存在这个问题，另一个优势是实时写入，性能高，速度快。
  
  - 跨进程通信方面：
  ContentProvider,socket,PIPE,message queue，等方式都要至少2次的内存拷贝。
  MMKV底层使用mmap实现，采用去中心化的架构，只需要将文件mmap到每个访问进程的内存空间，加上合适的进程锁，再处理好数据的通话，就能够实现多进程并发访问。
  
  ## 22. 注解学习使用 (★★★★)
  ### 22.1 什么是注解
  java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。
  Java 语言中的类、方法、变量、参数和包等都可以标注。Java标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。
  Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。
  
  ### 22.2 注解与注释的区别
  - 定义不同
    注解：元数据，它是一种描述数据的数据。
    注释：是对源代码说明的文字
  - 作用对象不同
    注解：是给编译器看的。
    注释：是给人看的。
  - 书写范围不同
    注解范围: 遵守一定的书写规范,以@开头,与工具一起使用。
    注释: 可以在代码的任何地方书写.
  - 运行范围不同
    注解: 可以参与编译器的任何阶段，对数据有一定的操作作用。
    注释：被编译器忽略，不参与编译。
  
  ### 22.3 标准注解
  - @Override，表示当前的方法定义将覆盖超类中的方法。
  - @Deprecated, 被此注解标记的元素表示被废弃。
  - @SuppressWarnings, 关闭不当的编译器警告信息。
  
  ### 22.4 元注解
  负责注解其它的注解。
  - @Target 表示该注解可以用在什么地方。
  ElementType.ANNOTATION_TYPE 可以应用于注释类型。
  ElementType.CONSTRUCTOR 可以应用于构造函数。
  ElementType.FIELD 可以应用于字段或属性。ElementType.LOCAL_VARIABLE 可以应用于局部变量。
  ElementType.METHOD 可以应用于方法级注释。
  ElementType.PACKAGE 可以应用于包声明。
  ElementType.PARAMETER 可以应用于方法的参数。ElementType.TYPE 可以应用于类的任何元素。
  
  - @Retention 表示需要在什么级别保存该注解信息
  SOURCE:在源文件中有效（即源文件保留）
  CLASS:在class文件中有效（即class保留）
  RUNTIME:在运行时有效（即运行时保留）
  
  - @Documented 表示将此注解包含在JavaDoc中
  
  - @Inherited 表示允许子类继承父类中的注解
  
  解释Retention三个阶段：
  第一阶段SOURCE,在AS等IDE开发时的Java源码时期.
  第二阶段CLASS,经过gradle或其它构建工具编译，变成了.Class文件，以及在Android apk中dex下的.class文件.
  第三阶段RUNTIME,当应用程序运行时，即JVM运行的RUNTIME时期。
  
  ### 22.5 自定义注解
  首先自定义注解InjectDIYLayout ， 这里为了简单示例用了运行时注解，并采用反射方法调用执行。
  ```
  @Target(ElementType.TYPE)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface InjectDIYLayout {
      int value();
  }
  ```
  然后写工具类，在BaseActivity中的onCreate中初始化。InjectDIYUtils .inject(this);
  ```
  public class InjectDIYUtils {
      private static final String TAG = "InjectDIYUtils";
  
      public static void inject(Object context){
          injectDIYLayout (context);
          }
  }
  ```
  之后就是注解的解释了，就是injectLayout的方法体。这里通过拿到参数activity的Context，并获取Activity的类，之后通过类getAnnotation得到此类注释的注解，经打印可以判断是否此注解。然后通过反射获取到setContentView,并用反射方法的invoke调用，传入注解中的layout值。
  ```
  private static void injectDIYLayout (Object context) {
          Class<?> aClass = context.getClass();
          InjectDIYLayout annotation = aClass.getAnnotation(InjectDIYLayout.class);
          Log.e(TAG, "injectLayout: annotation.value()="+annotation.value());
          try {
              Method contentView = aClass.getMethod("setContentView", int.class);
  
              try {
  
                  Object invoke = contentView.invoke(context, annotation.value());
              } catch (IllegalAccessException e) {
                  e.printStackTrace();
              } catch (InvocationTargetException e) {
                  e.printStackTrace();
              }
          } catch (NoSuchMethodException e) {
              e.printStackTrace();
          }
      }
  ```
  使用时的代码
  ```
  @InjectDIYLayout(R.layout.activity_main)
  public class MainActivity extends BaseActivity {
  ```
  然后在Activity的onCreate方法中注释setContentView。
  ```
   @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          //setContentView();
  ```
  
  
  ### 22.6 参考文献
  [Android的注解（Annotation）学习之路 - 走看看](http://t.zoukankan.com/hahayixiao-p-13772011.html#jieandshi)
  [Android 注解入门以及自定义注解 - 知乎](https://zhuanlan.zhihu.com/p/464896408)
  [Android注解-看这篇文章就够了_Zephyr Cai的博客-CSDN博客_android 注解](https://blog.csdn.net/caizehui/article/details/105003999)
  
  
  ## 23. 屏幕适配方案 (★★★★★)
  
  ### 23.1 dp与px的转换
  因为ui设计师给你的设计图是以px为单位的，Android开发则是使用dp作为单位的，那么需要进行转换：
  ![76aa4aff.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\76aa4aff.png)
  ```
  density=dpi/160
  dp= px/density
  ```
  
  ### 23.2 dimen 基于dp的适配（smallestWidth适配）
  这种适配依据的是最小宽度限定符。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。
  
  某手机的屏幕分辨率是 1080 * 1920，屏幕像素密度是 480 dpi，通过计算，
  
  它的最大宽度对应的 dp 值是：1080 / (480 / 160) = 360 dp,根据这个 360 dp 值，系统会去寻找 value-sw360dp 的文件夹以及对应的资源文件并使用它。
  
  如果没有 value-sw360dp 文件夹，系统会向下寻找，比如离 360 dp 最近的只有 value-sw350dp，那么Android就会选择 value-sw350dp 文件夹下面的资源文件。
  
  如下面我这里将会以 360 dp 作为基准.
  
  ![ba1d4f0e.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\ba1d4f0e.png)
  
  接下来，我们创建一个value-sw480dp 文件夹并在其中创建 dimens.xml 文件：
  ![9e2db153.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\9e2db153.png)
  
  在基准尺寸的基础上计算得
  ```
  dp_2 = (480 / 基准) x 2 = (480 / 360) x 2 = 2.6667 dp
  
  2为density
  ```
  
  ### 23.3 修改手机的设备密度 density
  
  ### 23.4 参考文献
  
  [Android屏幕适配和方案【整理】 - HaiyuKing - 博客园](https://www.cnblogs.com/whycxb/p/9755012.html)
  [Android 最全面的屏幕适配方案 - 简书](https://www.jianshu.com/p/746fa1ba313c)
  [【Android】之屏幕适配_一场雪ycx的博客-CSDN博客_android 屏幕适配](https://blog.csdn.net/yang553566463/article/details/127029556)
  [Android中px、dp、dpi、density解释和计算方式 - 简书](https://www.jianshu.com/p/e9125d51045f)
  
  ## 24.自定义View(★★★★★)
  ### 24.1 自定义View的分类
  1. 继承View或者ViewGroup类
  重写onDraw方法，调用invalidate方法重新绘制View
  2. 自定义组合控件
  几种控件组合起来形成一个新的控件，这个新的组合控件就会整合了原来每一个控件的功能
  3. 自定义扩展控件
  也就是继承现有的控件，在该控件的基础之上添加新的功能，如继承Button,tablayout
  
  ### 24.2 主要方法
  - 构造方法
  一般要写三个甚至四个，这样写的原因，在不同的情况下创建View的方式不同，可能需要从xml文件中填充布局，也可能不需要，或者也需要一样style之类的，因此不同情况下，使用的构造可能存在差异
  - onMeasure 用于测量子控件的宽高
  measureSpec: 在很大程度上决定了一个View的尺寸规格，其模式有三种模式。
  exactly(精确模式):在这种模式下，给定尺寸的值是多少，那么这个组件的长或宽就是多少。
  at_most(最大模式):这个也就是父组件，能够给出的最大的空间，当前组件的长或宽最大只能为这么大，当然也可以比这个小。
  unspecified(未指定模式):当前组件，可以随便用空间，不受限制。
  
  - onSizeChanged 測量View大小
  - onLayout 用于摆放子控件在父控件中的位置
  getMeasureWidth方法: 在measure过程结束后就可以获取到了。
  getWidth方法:要在layout过程结束后才能获取到。
  在ViewGroup中重写onLayout的目的:设置当前View与其所有的子View,在ViewGroup父布局当中的位置。
  - onDraw 用于绘制需要的图形
  绘制：主要通过canvas(画布),paint(画笔),matrix(变换矩阵)去绘制
  - invalidate 触发重新绘制，只能在主线程调用。
  - postInvalidate 直接调用去在子线程更新UI。
  - onAttachedToWindow 当View附加到窗体的时候调用该方法。
  - onDetachedFromWindow 当销毁View的时候调用该方法。
  - onFinishInflate 是当所有的孩子都解析完后的一个调用。
  - requestLayout 会触发measure过程和layout过程。
  
  注意：onMeasure和onLayout最后都要调用requestLayout才能让改变生效，onDraw要调用invalidate才能让在主线程生效。
  postinvalidate在子线程调用才能生效。
  
  ### 24.3 文献
  Android自定义View基础-自定义View进阶——自定义View基础
  Android自定义View基础-自定义View进阶——分类与流程
  [安卓面试题之---自定义View - 灰信网（软件开发博客聚合）](https://www.freesion.com/article/634078192/)
  
  
  ## 25. 安卓动画
  ### 25.1 Android 一共有多少种动画？(★★★)
  - 视图动画(View动画)
  - 帧动画(Drawable动画)
  - 属性动画
  - 触摸反馈动画
  - 揭露动画
  - 转场动画
  - 视图状态动画
  - 矢量图动画
  - 约束布局实现的关键帧动画
  
  #### 25.1.1 视图动画
  可以在一个视图容器里执行一系列简单变换(位置，大小，旋转，透明度)
  #### 25.1.2 帧动画
  每一帧代表一个画面动作，当快速逐帧显示时，速度到达人眼无法分辨每一帧时，就达到了动画的效果。一般用在设备开关机动画
  #### 25.1.3 属性动画
  属性动画与视图动画十分相似，原理上完全不同。
  
  视图动画：
  1. View 动画只能为 View 添加动画效果，且不能监听 View 相关属性的变化过程。
  2. View 动画提供的动画能力较为单一，目前只支持帧动画、缩放动画、位移动画、旋转动画、透明度动画以及这些动画的集合动画。
  3. View动画改变的是 View 的绘制效果，View 的真正位置和相关属性并不会改变，这也就造成了点击事件的触发区域是动画前的位置而不是动画后的位置的原因。
  
  属性动画:
  1. 属性动画作用对象不局限在 View 上，而是通过 Getter 和 Setter 方法作用在对象属性上。
  2. 属性动画没有直接改变 View 状态的能力，而是通过动态改变 View 相关属性的方式来改变 View 的显示效果。
  3. 属性动画使用更方便，可以用更简洁的代码实现相关的动画效果。
  
  #### 25.1.4 触摸反馈动画
  所谓触摸反馈动画就是一种点击效果，作用在可点击的 View 上时，当有点击事件时会有涟漪般的反馈效果
  
  #### 25.1.5 揭露动画
  揭露动画在系统中很常见，就是类似波纹的效果,从某一个点向四周展开或者从四周向某一点聚合起来。
  
  #### 25.1.6 转场动画
  1. 转场效果我们一般用在 Activity 切换时的动画效果上；
  2. 共享元素一般我们使用在转换的前后两个页面有共同元素时；
  3. 同时也可以在 Activity 布局发生场景变化时，让其中 View 产生相应的过渡动画。
  
  #### 25.1.7 视图状态动画
  所谓视图状态动画，就是 View 在状态改变时执行的动画效果。和之前我们通过 selector 选择器给 Button 设置不同状态下的背景效果是一样一样的。
  
  #### 25.1.8 矢量图动画
  在Android5.0 引入矢量图形既是大势所趋。矢量图有很多标准，Android 支持的是 SVG 标准（可缩放矢量图形 Scalable Vector Graphics）。但不是全量支持，准确的说 Android 支持的是 SVG 标准中 Path 相关的部分。
  
  AnimatedVectorDrawable　通过　ObjectAnimator　或　AnimatorSet　对　VectorDrawable　的某个属性作一个矢量资源的动画。
  
  #### 25.1.9 约束布局实现的关键帧动画
  通过 ConstraintLayout 实现的一种关键帧动画
  
  ### 25.2 文献
  [GitHub - OCNYang/Android-Animation-Set: Android 所有动画系列详尽教程。 Explain all animations in Android.](https://github.com/OCNYang/Android-Animation-Set)
  
  ## 26. MVVM架构解析
  
  ### 26.1 什么是MVVM
  1. MVVM，是Model-View-ViewModel的简写，是M-V-VM三部分组成。它本质上就是MVC 的改进 版。MVVM 就是将其中的View 的状态和行为抽象化，其中ViewModel将视图 UI 和业务逻辑分 开，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。
  
  2. MVVM采用双向数据绑定，view中数据变化将自动反映到viewmodel上，反之，model中数据变化 也将会自动展示在页面上。把Model和View关联起来的就是ViewModel。ViewModel负责把Model 的数据同步到View显示出来，还负责把View的修改同步回Model
  
  ![e7bc288b.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\e7bc288b.png)
  
  ### 26.2 Model,View,ViewModel三个部分
  Model: 数据层，包含数据实体和对数据实体的操作。
  View: 界面层，对应于Activity,XML,负责数据显示以及用户交互。
  ViewModel:关联层，作为中间桥梁去通知model数据层处理数据业务，并将结果回调给UI层处理UI逻辑。ViewModel中只有activity持有vm引用，vm是不持有view的引用的，所以vm的构造方 法中不能传入视图相关的对象。所以重点在于怎么通知view，可以通过观察者回调的方式。但是现 在一般是结合Jetpack来进行view的更新的。
  
  ### 26.3 MVVM核心构成
  DataBinding:数据和UI双向绑定
  LifeCycle:界面生命周期感知
  ViewModel:业务逻辑
  LiveData:可观察数据项
  
  ### 26.4 JetPack简介
  Jetpack 是一个丰富的组件库，它的组件库按类别分为 4 类，分别是架构（Architecture)、界面（UI)、行为（behavior）、基础（foundation）。每个组件都可以单独使用，也可以配合在一起使-用。每个组件都给用户提供了一个标准，能够帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者能够集中精力编写重要的业务代码。
  #### 26.4.1 架构
  Data Binding
  以声明的方式将可观察数据绑定到界面元素，通常和ViewModel配会使用。
  
  Lifecycle
  用于管理Activity和Fragment的生命周期，可以帮助开发者生成更易于维护的轻量级代码。
  
  LiveData
  在底层数据库更改时通知视图。它是一个可观察的数据持有者，与常规observable不同，LiveData是有生命周期感知的。
  
  Navigation
  用于处理应用内导航。
  
  Paging
  可以帮助开发者一次加载和显示小块数据，按需加载部分数据可减少网络带宽和系统资源的使用。
  
  Room
  友好、流畅的访问SQLite数据库。它在SQLite的基础上提供了一个抽象层，允许更强大的数据库访问。
  
  ViewModel
  以生命周期的方式管理与界面相关的数据，通常和Data Binding！配合使用。者实现MVVM架构提供了强有力的支持。
  
  WorkManager
  管理Android的后台作业，即使应用程序退出或设备重新启动也可以运延迟的异步任务。
  
  #### 26.4.2 界面
  Animation＆Transitions
  该框架包含用于常见效果的内置动画，并允许开发者定义动画和生命周期回调。
  
  Emoji Compatibility
  即便用户没有更新Android系统也可以获取最新的表情符号。
  
  Fragment
  组件化界面的基本单位。
  
  布局
  在XML中声明UI元素或者在代码中实例化U元素。
  
  调色板
  从调色板中提取出有用的信息。
  #### 26.4.3 行为
  Camerax
  帮助开发简化相机应用的开发工作。它提供一致且易于使用的界面，适于大多数Android i设备，并可向后兼容至Android5.0（API21）
  
  Download Manager
  处理长时间运行的HTTP下载的系统服务。
  
  媒体和播放
  用于媒体播放和路由（包括Google Cast）的向后兼容API。
  
  通知
  提供向后兼容的通知API，支持Wear和Auto
  
  权限
  用于检查和请求应用权限的兼容性API。
  
  设置
  创建交互式设置，建议使用AndroidX Preference Library库将用户可配置设置集成到应用中。
  
  分享操作
  可以更轻松地实现友好的用户分享操作。
  
  切片
  切片是一种U模板，创建可在应用外部显示应用数据的灵活界面元素。
  
  #### 26.4.4 基础
  Android KTX
  优化了Kotlin使用的Jetpack和Android平台API。帮助开发者以更简洁、更愉悦、更惯用的方式使用Kotlin进行Android开发。
  
  AppCompat
  帮助较低版本的Android系统进行兼容。
  
  Auto
  开发Android auto应用的组件，提供了适用于所有车辆的标准化界面和用户交互
  
  检测
  从Android studio中快速检测基于Kotlin或Java的代码。
  
  多Dex处理
  为具有多个Dex文件应用提供支持。
  
  安全
  用于检查和请求应用权限的兼容性API。
  
  测试
  用于单元和运行时界面测试的Android测试框架。
  
  TV
  构建可使用户在大屏幕上体验沉浸式内容的应用。
  
  Wear OS
  开发Wear应用的组件。
  
  
  ### 26.5 文献
  [Android MVVM架构_绵绵思远道～的博客-CSDN博客](https://blog.csdn.net/weixin_53431933/article/details/126372227)
  [Android JetPack简介_Cola可洛的博客-CSDN博客](https://blog.csdn.net/qq_35892584/article/details/125955640)
  
  ## 27. JNI 原理解析
  ### 27.1 JNI概述
  JNI（Java Native Interface，Java本地接口），用于打通Java层与Native(C/C++)层。这不是Android系统所独有的，而是Java所有。众所周知，Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C/C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。
  
  ### 27.2 JNI原理分析
  #### 27.2.1 动态库的加载loadLibrary
  1. System.loadLibrary和System.load都用于加载动态库，loadLibrary可以方便自动加载依赖库，load可以方便指定具体路径的动态库。
  2. 无论哪种方式加载最终都会调用到LoadNativeLibrary方法。
  - 通过dlopen打开动态共享库
  - 通过dlsym获取JNI_ONLoad符号所对应的方法。
  - 调用该加载库中的JNI_Onload方法，开始注册多个native方法。
  
  #### 27.2.2 静态注册与动态注册
  JVM查找Native方法有两种方式：
  1、当加载动态库到Jvm后当Native方法第一执行时根据其方法名去匹配对应C语言实现命名规则，这种方式叫静态注册。
  2、通过JNI_OnLoad调用JNI提供的RegisterNatives函数，将JNINativeMethod结构体中本地函数注册到JVM中，这种方式叫动态注册。
  
  #### 27.2.3 JavaVM和JNIEnv
  
  JavaVM：是指进程虚拟机环境，每个进程有且只有一个JavaVM实例
  
  JNIEnv：是指线程上下文环境，每个线程有且只有一个JNIEnv实例，
  
  #### 27.2.4 JNI加载过程
  1. 通过loadLibrary 调用相应库中的JNI_OnLoad()方法。
  2. 在JNI_OnLoad方法中，获取JNINativeMethod结构体中定义的Java函数。
  3. 通过registerNativeMethods方法，将JNINativeMethod结构体中定义的Java函数，注册到JVM中。
  
  ### 27.4 文献
  [Android JNI原理分析 - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2016/05/28/android-jni/)
  [JNI动态注册、静态注册实例及其实现原理分析 - 知乎](https://zhuanlan.zhihu.com/p/520523247)
  [【Android】JNI静态与动态注册介绍_android jni 动态注册_后端码匠的博客-CSDN博客](https://blog.csdn.net/weixin_43874301/article/details/128129892)
  [JNI静态注册与动态注册_jni动态注册_FlyerGo的博客-CSDN博客](https://blog.csdn.net/u012944685/article/details/124211418)
  [JNI 静态注册/动态注册 - 简书](https://www.jianshu.com/p/873fc6ee4e51)
  
  ## 28. 性能优化分析
  
  ### 28.1 稳定——内存优化
  
  Android中的内存优化总的来说就是开源和节流，开源就是扩大内存，节流就是避免内存泄漏。
  
  #### 28.1.1 扩大内存方式
  1. 清单文件中的Application下添加largeHeap="true"这个属性,让应用能申请使用更多的内存.
  2. 同一个应用下开启多个进程，如启动一个Service在另个进程，通过AIDL与客户端通信.
  
  #### 28.1.2 内存泄漏检测方式
  
  #### 28.1.1 Android Profiler工具
  Android Profiler分为三大模块： cpu、内存 、网络。其中Memory Profiler 是Android Profiler中的一个组件，它可以帮助您识别内存泄漏和内存溢出。
  
  #### 28.1.2 LeakCanary + MAT 工具
  LeakCanary专为Android设计的内存泄露检测库，首先将依赖引入项目中。其次运行APP，在遇到内存泄漏后，LeakCanary会有弹框提示，并且会将堆内存dump成hprof文件。
  然后将hprof文件导入MAT工具中进行分析。
  
  #### 28.1.3 Android Lint工具
  Android Lint是一个静态代码分析工具，它能够检测Android项目中的内存泄漏，还会检测代码是否规范、是否有没用到的导包、可能的bug、安全问题等等。
  
  它有个Lint Tool工具，它会把Android源代码和lint.xml配置文件打包成一个文件之后，输出成lint output，并展现出具体在哪行代码有问题。
  
  ### 28.2 流畅——卡顿优化
  UI问题的最大体现则是屏幕卡顿现象。造成卡顿的主要原因有以下两点：
  - 绘制耗时过长，绘制一帧内容耗时太长。
  - 主线程太忙，导致Vsync(Vertical Synchronization)信号到时还没准备好数据，导致丢帧。
  
  Android 4.1版本推出了Project Butter，其中VSYNC(垂直同步)则是解决刷新不同步的问题。可以简单地把它认为是一种定时中断，一旦收到VSYNC中断，CPU就开始处理各帧数据进行渲染。
  
  ### 28.2.1 绘制耗时过长
  - 界面布局层级过深:
  一个页面的Measure、Layout和draw过程都是通过递归来完成的，如果层级太深，每增加一层则会增加更多的页面显示时间。
  - 复杂的布局:
  对于View状态变化等情况的界面，当View发生变化时，都需要重新计算、创建、渲染，更新到屏幕上，如果布局很复杂，就很容易导致卡顿问题
  - 过渡绘制:
  有重叠的UI设置了多个背景，或者自定义View中draw方法在同一区域进行了重复绘制。
  
  ### 28.2.2 主线程繁忙
  主线主要负责的工作如下：
  - UI生命周期控制
  - 系统事件处理
  - 消息处理
  - 界面布局
  - 界面绘制
  - 界面刷新
  
  如果以上主线程工作中加入复杂的数据处理，网络请求等耗时操作。那么可能会导致主线程被阻塞而不能及时响应VSync信号，出现卡顿丢帧的情况。
  
  ### 28.2.3 分析工具
  
  
  ### 28.3 节省——耗电优化
  
  ### 28.4 安装包——APK瘦身
  
  ### 28.5 启动优化 
  
  
  ### 28.5 文献
  [Android性能优化总结 - 蜗牛攀爬 - 博客园](https://www.cnblogs.com/wnpp/p/16065525.html)
  [Android面试必会之性能优化 - 知乎](https://zhuanlan.zhihu.com/p/413283737)
  [Android内存泄露检测工具 LeakCanary 使用 及 MAT分析 - 简书](https://www.jianshu.com/p/b58390442a00)
  [Android性能优化大全_朽木成才的博客-CSDN博客](https://blog.csdn.net/wang_yong_hui_1234/article/details/74331408)
  [史上最全Android性能优化方案解析_android 性能优化_嘴巴吃糖了的博客-CSDN博客](https://blog.csdn.net/YoungOne2333/article/details/126909794)
  [Android 性能优化---绘制优化篇 - 知乎](https://zhuanlan.zhihu.com/p/455886476)
  
  ## 面试题参考文献
  [jeanboy_jeanboydev_CSDN博客-Android进阶,Java基础,Android进阶领域博主](https://blog.csdn.net/freekiteyu/article/list/1)
  [成功入职字节跳动的小姐姐告诉你，Android面试吃透这一篇就没有拿不到的offer！_Stay Hungry Stay Foolish-CSDN博客](https://blog.csdn.net/qq_29966203/article/details/105455615)
  [Android-MS/android at master · xiangjiana/Android-MS · GitHub](https://github.com/xiangjiana/Android-MS/tree/master/android)
  [【Android】_许佳佳233的博客-CSDN博客](https://blog.csdn.net/double2hao/category_6004761.html)
  
  
  
  
  
  
  
'''
linesHighlighted: [
  4335
  4408
]
isStarred: false
isTrashed: false
