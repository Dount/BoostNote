createdAt: "2019-09-26T02:02:22.087Z"
updatedAt: "2020-07-24T10:07:39.001Z"
type: "MARKDOWN_NOTE"
folder: "537068cf3ce988a4b28a"
title: "Android 面试题"
tags: []
content: '''
  # Android 面试题
  [toc]
  ## 1、Application 生命周期
  - Application和Activity,Service一样，是Android框架的一个系统组件。
  - 当Android程序启动时系统会创建一个application对象用来存储系统的一些信息。
  - Android系统会为每个程序运行时创建一个Application类的对象且只创建一个。
  
  ### 1.1 Application中五个公开的方法
  1）void  onConfigurationChanged(Configuration newConfig)
  配置被改变时触发 
  2）void  onCreate() 
  程序创建时创建
  3）void  onLowMemory()
  内存不够时触发
  4）void  onTerminate()
  当终止程序时调用 但是不能保证一定调用
  5）void onTrimMemory()
  内存清理时触发
  
  ### 1.2 实例展示
  ```
  /**
   * @author ljcheng
   * @date 2019/6/29
   */
  public class MyApplication extends Application {
  
      private static String TAG = "MyApplication";
  
      @Override
      public void onCreate() {
          // 程序创建的时候执行
          KLog.d(TAG, "onCreate");
          super.onCreate();
      }
  
      @Override
      public void onTerminate() {
          // 程序终止的时候执行
          //当终止应用程序对象时调用，不保证一定被调用，意思是当程序被内核终止以便为其他应用程序释放资源，那
          //么将不会提醒，并且不调用应用程序的对象的onTerminate方法而直接终止进程
          KLog.d(TAG, "onTerminate");
          super.onTerminate();
      }
  
      @Override
      public void onLowMemory() {
          // 当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必
          // 要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。
          KLog.d(TAG, "onLowMemory");
          super.onLowMemory();
      }
  
      @Override
      public void onTrimMemory(int level) {
          // 程序在内存清理的时候执行
          KLog.d(TAG, "onTrimMemory");
          super.onTrimMemory(level);
      }
  
      @Override
      //配置改变时触发这个方法
      public void onConfigurationChanged(Configuration newConfig) {
          KLog.d(TAG, "onConfigurationChanged");
          super.onConfigurationChanged(newConfig);
      }
  
  }
  ```
  
  ## 2、Service
  
  ### 2.1 Service 概述
  Service(服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。
  
  - 启动状态
  当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。
  
  - 绑定状态
  当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。
  
  ![ed2399e5.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\ed2399e5.png)
  
  ### 2.2 Service在清单文件中的声明
  Service在AndroidManifest.xml中的声明语法
  ```
  <service android:enabled=["true" | "false"]
      android:exported=["true" | "false"]
      android:icon="drawable resource"
      android:isolatedProcess=["true" | "false"]
      android:label="string resource"
      android:name="string"
      android:permission="string"
      android:process="string" >
      . . .
  </service>
  ```
  - android:exported：代表是否能被其他应用隐式调用，其默认值是由service中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。为false的情况下，即使有intent-filter匹配，也无法打开，即无法被其他应用隐式调用。
  
  - android:name：对应Service类名
  - android:permission：是权限声明
  - android:process：是否需要在单独的进程中运行,当设置为android:process=”:remote”时，代表Service在单独的进程中运行。注意“：”很重要，它的意思是指要在当前进程名称前面附加上当前的包名，所以“remote”和”:remote”不是同一个意思，前者的进程名称为：remote，而后者的进程名称为：App-packageName:remote。
  - android:isolatedProcess ：设置 true 意味着，服务会在一个特殊的进程下运行，这个进程与系统其他进程分开且没有自己的权限。与其通信的唯一途径是通过服务的API(bind and start)。
  - android:enabled：是否可以被系统实例化，默认为 true因为父标签 也有 enable 属性，所以必须两个都为默认值 true 的情况下服务才会被激活，否则不会激活。 
  
  ### 2.3 Service启动服务
  首先要创建服务，必须创建 Service 的子类（或使用它的一个现有子类如IntentService）。在实现中，我们需要重写一些回调方法，以处理服务生命周期的某些关键过程.
  ```
  package com.zejian.ipctest.service;
  
  import android.app.Service;
  import android.content.Intent;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  
  /**
   * Created by zejian
   * Time 2016/9/29.
   * Description:service simple demo
   */
  public class SimpleService extends Service {
  
      /**
       * 绑定服务时才会调用
       * 必须要实现的方法  
       * @param intent
       * @return
       */
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return null;
      }
  
      /**
       * 首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或 onBind() 之前）。
       * 如果服务已在运行，则不会调用此方法。该方法只被调用一次
       */
      @Override
      public void onCreate() {
          System.out.println("onCreate invoke");
          super.onCreate();
      }
  
      /**
       * 每次通过startService()方法启动Service时都会被回调。
       * @param intent
       * @param flags
       * @param startId
       * @return
       */
      @Override
      public int onStartCommand(Intent intent, int flags, int startId) {
          System.out.println("onStartCommand invoke");
          return super.onStartCommand(intent, flags, startId);
      }
  
      /**
       * 服务销毁时的回调
       */
      @Override
      public void onDestroy() {
          System.out.println("onDestroy invoke");
          super.onDestroy();
      }
  }
  ```
  从上面的代码我们可以看出SimpleService继承了Service类，并重写了onBind方法，该方法是必须重写的，但是由于此时是startService()的服务，则该方法无须实现，返回null即可，只有在bindService()的情况下才需要实现该方法并返回一个IBinder的实现类（这个后面会详细说），接着重写了onCreate、onStartCommand、onDestroy三个主要的生命周期方法，关于这几个方法说明如下:
  - onBind()
  当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须返回 一个IBinder 接口的实现类，供客户端用来与服务进行通信。无论是startService状态还是bindService状态，此方法必须重写，但在startService状态的情况下直接返回 null。
  - onCreate()
  首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法，该方法只调用一次
  - onStartCommand()
  当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。）
  - onDestroy()
  当服务不再使用且将被销毁时，系统将调用此方法。服务应该实现此方法来清理所有资源，如线程、注册的侦听器、接收器等，这是服务接收的最后一个调用。
  
  ### 2.4 StartService Demo 
  ```
  package com.zejian.ipctest;
  
  import android.content.Intent;
  import android.os.Bundle;
  import android.support.v7.app.AppCompatActivity;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.service.SimpleService;
  
  public class MainActivity extends AppCompatActivity implements View.OnClickListener {
  
      private Button startBtn;
      private Button stopBtn;
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          startBtn= (Button) findViewById(R.id.startService);
          stopBtn= (Button) findViewById(R.id.stopService);
          startBtn.setOnClickListener(this);
          assert stopBtn != null;
          stopBtn.setOnClickListener(this);
      }
  
      @Override
      public void onClick(View v) {
          Intent it=new Intent(this, SimpleService.class);
          switch (v.getId()){
              case R.id.startService:
                  startService(it);
                  break;
              case R.id.stopService:
                  stopService(it);
                  break;
          }
      }
  }
  ```
  ```
  <manifest ... >
    ...
    <application ... >
        <service android:name=".service.SimpleService" />
        ...
    </application>
  </manifest>
  ```
  
  从代码看出，启动服务使用startService(Intent intent)方法，仅需要传递一个Intent对象即可，在Intent对象中指定需要启动的服务。而使用startService()方法启动的服务，在服务的外部，必须使用stopService()方法停止，在服务的内部可以调用stopSelf()方法停止当前服务。如果使用startService()或者stopSelf()方法请求停止服务，系统会就会尽快销毁这个服务。**值得注意的是对于启动服务，一旦启动将与访问它的组件无任何关联，即使访问它的组件被销毁了，这个服务也一直运行下去，直到手动调用停止服务才被销毁。**
  
  ![20160930094006623.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\2d4a81e4.png)
  
  从Log可以看出，第一次调用startService方法时，onCreate方法、onStartCommand方法将依次被调用，**而多次调用startService时，只有onStartCommand方法被调用，最后我们调用stopService方法停止服务时onDestory方法被回调，这就是启动状态下Service的执行周期**。接着我们重新回过头来进一步分析onStartCommand（Intent intent, int flags, int startId），这个方法有3个传入参数，它们的含义如下：
  
  ### 2.5 onStartCommand 中参数的意义
  - intent 
  启动时，启动组件传递过来的Intent，如Activity可利用Intent封装所需要的参数并传递给Service
  - flags
  表示启动请求时是否有额外数据，可选值有 0，START_FLAG_REDELIVERY，START_FLAG_RETRY，0代表没有
    - START_FLAG_REDELIVERY 
    这个值代表了onStartCommand方法的返回值为 START_REDELIVER_INTENT，而且在上一次服务被杀死前会去调用stopSelf方法停止服务。其中START_REDELIVER_INTENT意味着当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，此时Intent时有值的。
    - START_FLAG_RETRY 
    该flag代表当onStartCommand调用后一直没有返回值时，会尝试重新去调用onStartCommand()。
  
  - startId
  指明当前服务的唯一ID，与stopSelfResult (int startId)配合使用，stopSelfResult 可以更安全地根据ID停止服务。
  实际上onStartCommand的返回值int类型才是最最值得注意的，它有三种可选值， START_STICKY，START_NOT_STICKY，START_REDELIVER_INTENT
    - START_STICKY 
    当Service因内存不足而被系统kill后，一段时间后内存再次空闲时，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand方法，但其中的Intent将是null，除非有挂起的Intent，如pendingintent，这个状态下比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。
    - START_NOT_STICKY
    当Service因内存不足而被系统kill后，即使系统内存再次空闲时，系统也不会尝试重新创建此Service。除非程序中再次调用startService启动此Service，这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务
    - START_REDELIVER_INTENT
    当Service因内存不足而被系统kill后，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()，任何挂起 Intent均依次传递。与START_STICKY不同的是，其中的传递的Intent将是非空，是最后一次调用startService中的intent。这个值适用于主动执行应该立即恢复的作业（例如下载文件）的服务。
  
  
  ### 2.6 Service绑定服务
  绑定服务是Service的另一种变形，当Service处于绑定状态时，其代表着“客户端-服务器”中的服务器。
      情况1：需要从Activity组建中去调用Service中的方法。当其他组件（如 Activity）绑定到服务时，此时Activity以绑定的方式挂靠到Service后，就可以得到Service中的指定方法。
      情况2：组件（如Activity）可以向Service（也就是服务端）发送请求，或者调用Service（服务端）的方法，此时被绑定的Service（服务端）会接收信息并响应。
      情况3：可以通过绑定服务进行执行进程间通信 (即IPC，这个后面再单独分析)。
      **注意**
      与StartService不同的是BinderService的生命周期通常只在为其他应用组件(如Activity)服务时处于活动状态，不会无限期在后台运行，也就是说宿主(如Activity)销毁后，绑定服务就会被销毁。
  
  - 扩展Binder类
  如果服务是提供给自有应用专用的，并且Service(服务端)与客户端相同的进程中运行（常见情况），则应通过扩展 Binder 类并从 onBind() 返回它的一个实例来创建接口。客户端收到 Binder 后，可利用它直接访问 Binder 实现中以及Service 中可用的公共方法。如果我们的服务只是自有应用的后台工作线程，则优先采用这种方法。 不采用该方式创建接口的唯一原因是，服务被其他应用或不同的进程调用。
  - 使用Message
  Messenger可以翻译为信使，通过它可以在不同的进程中共传递Message对象(Handler中的Messager，因此 Handler 是 Messenger 的基础)，在Message中可以存放我们需要传递的数据，然后在进程间传递。如果需要让接口跨不同的进程工作，则可使用 Messenger 为服务创建接口，客户端就可利用 Message 对象向服务发送命令。同时客户端也可定义自有 Messenger，以便服务回传消息。这是执行进程间通信 (IPC) 的最简单方法，因为 Messenger 会在单一线程中创建包含所有请求的队列，也就是说Messenger是以串行的方式处理客户端发来的消息，这样我们就不必对服务进行线程安全设计了。
  - 使用AIDL
  由于Messenger是以串行的方式处理客户端发来的消息，如果当前有大量消息同时发送到Service(服务端)，Service仍然只能一个个处理，这也就是Messenger跨进程通信的缺点了，因此如果有大量并发请求，Messenger就会显得力不从心了，这时AIDL（Android 接口定义语言）就派上用场了， 但实际上Messenger 的跨进程方式其底层实现 就是AIDL，只不过android系统帮我们封装成透明的Messenger罢了，因此，如果我们想让服务同时处理多个请求，则应该使用 AIDL。
  
  ### 2.7 扩展Binder类
  如果我们的服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让客户端通过该类直接访问服务中的公共方法。其使用开发步骤如下
  - 创建BindService服务端，继承自Service并在类中，创建一个实现IBinder 接口的实例对象并提供公共方法给客户端调用
  - 从 onBind() 回调方法返回此 Binder 实例。
  - 在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。
  **注意**
  此方式只有在客户端和服务位于同一应用和进程内才有效，如对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方式非常有效。
  另一点之所以要求服务和客户端必须在同一应用内，是为了便于客户端转换返回的对象和正确调用其 API。服务和客户端还必须在同一进程内，因为此方式不执行任何跨进程编组。 
  
  ### 2.8 扩展Binder类Demo
  ```
  package com.zejian.ipctest.service;
  
  import android.app.Service;
  import android.content.Intent;
  import android.os.Binder;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  import android.util.Log;
  
  /**
   * Created by zejian
   * Time 2016/10/2.
   * Description:绑定服务简单实例--服务端
   */
  public class LocalService extends Service{
      private final static String TAG = "wzj";
      private int count;
      private boolean quit;
      private Thread thread;
      private LocalBinder binder = new LocalBinder();
  
      /**
       * 创建Binder对象，返回给客户端即Activity使用，提供数据交换的接口
       */
      public class LocalBinder extends Binder {
          // 声明一个方法，getService。（提供给客户端调用）
          LocalService getService() {
              // 返回当前对象LocalService,这样我们就可在客户端端调用Service的公共方法了
              return LocalService.this;
          }
      }
  
      /**
       * 把Binder类返回给客户端
       */
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return binder;
      }
  
  
      @Override
      public void onCreate() {
          super.onCreate();
          Log.i(TAG, "Service is invoke Created");
          thread = new Thread(new Runnable() {
              @Override
              public void run() {
                  // 每间隔一秒count加1 ，直到quit为true。
                  while (!quit) {
                      try {
                          Thread.sleep(1000);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      count++;
                  }
              }
          });
          thread.start();
      }
  
      /**
       * 公共方法
       * @return
       */
      public int getCount(){
          return count;
      }
      /**
       * 解除绑定时调用
       * @return
       */
       @Override
      public boolean onUnbind(Intent intent) {
          Log.i(TAG, "Service is invoke onUnbind");
          return super.onUnbind(intent);
      }
  
      @Override
      public void onDestroy() {
          Log.i(TAG, "Service is invoke Destroyed");
          this.quit = true;
          super.onDestroy();
      }
  }
  ```
  BindService类继承自Service，在该类中创建了一个LocalBinder继承自Binder类，LocalBinder中声明了一个getService方法，客户端可访问该方法获取LocalService对象的实例，只要客户端获取到LocalService对象的实例就可调用LocalService服务端的公共方法，如getCount方法，值得注意的是，我们在onBind方法中返回了binder对象，该对象便是LocalBinder的具体实例，而binder对象最终会返回给客户端，客户端通过返回的binder对象便可以与服务端实现交互。接着看看客户端BindActivity的实现：
  ```
  package com.zejian.ipctest.service;
  
  import android.app.Activity;
  import android.app.Service;
  import android.content.ComponentName;
  import android.content.Intent;
  import android.content.ServiceConnection;
  import android.os.Bundle;
  import android.os.IBinder;
  import android.util.Log;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.R;
  
  /**
   * Created by zejian
   * Time 2016/10/2.
   * Description:绑定服务实例--客户端
   */
  public class BindActivity extends Activity {
      protected static final String TAG = "wzj";
      Button btnBind;
      Button btnUnBind;
      Button btnGetDatas;
      /**
       * ServiceConnection代表与服务的连接，它只有两个方法，
       * onServiceConnected和onServiceDisconnected，
       * 前者是在操作者在连接一个服务成功时被调用，而后者是在服务崩溃或被杀死导致的连接中断时被调用
       */
      private ServiceConnection conn;
      private LocalService mService;
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_bind);
          btnBind = (Button) findViewById(R.id.BindService);
          btnUnBind = (Button) findViewById(R.id.unBindService);
          btnGetDatas = (Button) findViewById(R.id.getServiceDatas);
          //创建绑定对象
          final Intent intent = new Intent(this, LocalService.class);
  
          // 开启绑定
          btnBind.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  Log.d(TAG, "绑定调用：bindService");
                  //调用绑定方法
                  bindService(intent, conn, Service.BIND_AUTO_CREATE);
              }
          });
          // 解除绑定
          btnUnBind.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  Log.d(TAG, "解除绑定调用：unbindService");
                  // 解除绑定
                  if(mService!=null) {
                      mService = null;
                      unbindService(conn);
                  }
              }
          });
  
          // 获取数据
          btnGetDatas.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  if (mService != null) {
                      // 通过绑定服务传递的Binder对象，获取Service暴露出来的数据
  
                      Log.d(TAG, "从服务端获取数据：" + mService.getCount());
                  } else {
  
                      Log.d(TAG, "还没绑定呢，先绑定,无法从服务端获取数据");
                  }
              }
          });
  
  
          conn = new ServiceConnection() {
              /**
               * 与服务器端交互的接口方法 绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，
               * 通过这个IBinder对象，实现宿主和Service的交互。
               */
              @Override
              public void onServiceConnected(ComponentName name, IBinder service) {
                  Log.d(TAG, "绑定成功调用：onServiceConnected");
                  // 获取Binder
                  LocalService.LocalBinder binder = (LocalService.LocalBinder) service;
                  mService = binder.getService();
              }
              /**
               * 当取消绑定的时候被回调。但正常情况下是不被调用的，它的调用时机是当Service服务被意外销毁时，
               * 例如内存的资源不足时这个方法才被自动调用。
               */
              @Override
              public void onServiceDisconnected(ComponentName name) {
                  mService=null;
              }
          };
      }
  }
  ```
  在客户端中我们创建了一个ServiceConnection对象，该代表与服务的连接，它只有两个方法， onServiceConnected和onServiceDisconnected.
  - onServiceConnected(ComponentName name, IBinder service) 
  系统会调用该方法以传递服务的　onBind() 方法返回的 IBinder。其中service便是服务端返回的IBinder实现类对象，通过该对象我们便可以调用获取LocalService实例对象，进而调用服务端的公共方法。而ComponentName是一个封装了组件(Activity, Service, BroadcastReceiver, or ContentProvider)信息的类，如包名，组件描述等信息，较少使用该参数。
  
  - onServiceDisconnected(ComponentName name) 
  **Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。注意:当客户端取消绑定时，系统“绝对不会”调用该方法。**
  
  在onServiceConnected()被回调前，我们还需先把当前Activity绑定到服务LocalService上，绑定服务是通过通过bindService()方法，解绑服务则使用unbindService()方法，
  - bindService(Intent service, ServiceConnection conn, int flags) 
  该方法执行绑定服务操作，其中Intent是我们要绑定的服务(也就是LocalService)的意图，而ServiceConnection代表与服务的连接，它只有两个方法，前面已分析过，flags则是指定绑定时是否自动创建Service。0代表不自动创建、BIND_AUTO_CREATE则代表自动创建。
  - unbindService(ServiceConnection conn) 
  该方法执行解除绑定的操作，其中ServiceConnection代表与服务的连接，它只有两个方法，前面已分析过。
  
  Activity通过bindService()绑定到LocalService后，ServiceConnection#onServiceConnected()便会被回调并可以获取到LocalService实例对象mService，之后我们就可以调用LocalService服务端的公共方法了，最后还需要在清单文件中声明该Service。
  
  运行程序，点击绑定服务并多次点击绑定服务接着多次调用LocalService中的getCount()获取数据，最后调用解除绑定的方法移除服务，其结果如下： 
  ![20161003123125076.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\cc9b396a.png)
  
   通过Log可知，当我们第一次点击绑定服务时，LocalService服务端的onCreate()、onBind方法会依次被调用，此时客户端的ServiceConnection中onServiceConnected()被调用并返回LocalBinder对象，接着调用LocalBinder#getService方法返回LocalService实例对象，此时客户端便持有了LocalService的实例对象，也就可以任意调用LocalService类中的声明公共方法了。**更值得注意的是，我们多次调用bindService方法绑定LocalService服务端，而LocalService得onBind方法只调用了一次，那就是在第一次调用bindService时才会回调onBind方法。**接着我们点击获取服务端的数据，从Log中看出我们点击了3次通过getCount()获取了服务端的3个不同数据，最后点击解除绑定，此时LocalService的onUnBind、onDestroy方法依次被回调，并且多次绑定只需一次解绑即可。此情景也就说明了绑定状态下的Service生命周期方法的调用依次为onCreate()、onBind、onUnBind、onDestroy。
  
  ### Bind使用总结
  - onBind只会调用一次.
  - onServiceDisconnected,系统在与服务的连接意外中断时调用该方法。注意:当客户端取消绑定时，系统“绝对不会”调用该方法。
  - BinderService会随着宿主的销毁而销毁。
  
  ### 2.9 使用Messenger
  前面了解了如何使用IBinder应用内同一进程的通信后，我们接着来了解服务与远程进程（即不同进程间）通信，而不同进程间的通信，最简单的方式就是使用 Messenger 服务提供通信接口，利用此方式，我们无需使用 AIDL 便可执行进程间通信 (IPC)。以下是 Messenger 使用的主要步骤：
  - 服务实现一个 Handler，由其接收来自客户端的每个调用的回调
  - Handler 用于创建 Messenger 对象（对 Handler 的引用）
  - Messenger 创建一个 IBinder，服务通过 onBind() 使其返回客户端
  - 客户端使用 IBinder 将 Messenger（引用服务的 Handler）实例化，然后使用Messenger将 Message 对象发送给服务
  - 服务在其 Handler 中（在 handleMessage() 方法中）接收每个 Message
  
  ### 2.10 使用Messenger接口Demo
  ```
  package com.zejian.ipctest.messenger;
  
  import android.app.Service;
  import android.content.Intent;
  import android.os.Handler;
  import android.os.IBinder;
  import android.os.Message;
  import android.os.Messenger;
  import android.util.Log;
  
  /**
   * Created by zejian
   * Time 2016/10/3.
   * Description:Messenger服务端简单实例,服务端进程
   */
  public class MessengerService extends Service {
  
      /** Command to the service to display a message */
      static final int MSG_SAY_HELLO = 1;
      private static final String TAG ="wzj" ;
  
      /**
       * 用于接收从客户端传递过来的数据
       */
      class IncomingHandler extends Handler {
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  case MSG_SAY_HELLO:
                      Log.i(TAG, "thanks,Service had receiver message from client!");
                      break;
                  default:
                      super.handleMessage(msg);
              }
          }
      }
  
      /**
       * 创建Messenger并传入Handler实例对象
       */
      final Messenger mMessenger = new Messenger(new IncomingHandler());
  
      /**
       * 当绑定Service时,该方法被调用,将通过mMessenger返回一个实现
       * IBinder接口的实例对象
       */
      @Override
      public IBinder onBind(Intent intent) {
          Log.i(TAG, "Service is invoke onBind");
          return mMessenger.getBinder();
      }
  }
  ```
  
  首先我们同样需要创建一个服务类MessengerService继承自Service，同时创建一个继承自Handler的IncomingHandler对象来接收客户端进程发送过来的消息并通过其handleMessage(Message msg)进行消息处理。接着通过IncomingHandler对象创建一个Messenger对象，该对象是与客户端交互的特殊对象，然后在Service的onBind中返回这个Messenger对象的底层Binder即可。
  ```
  package com.zejian.ipctest.messenger;
  
  import android.app.Activity;
  import android.content.ComponentName;
  import android.content.Context;
  import android.content.Intent;
  import android.content.ServiceConnection;
  import android.os.Bundle;
  import android.os.IBinder;
  import android.os.Message;
  import android.os.Messenger;
  import android.os.RemoteException;
  import android.util.Log;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.R;
  
  /**
   * Created by zejian
   * Time 2016/10/3.
   * Description: 与服务器交互的客户端
   */
  public class ActivityMessenger extends Activity {
      /**
       * 与服务端交互的Messenger
       */
      Messenger mService = null;
  
      /** Flag indicating whether we have called bind on the service. */
      boolean mBound;
  
      /**
       * 实现与服务端链接的对象
       */
      private ServiceConnection mConnection = new ServiceConnection() {
          public void onServiceConnected(ComponentName className, IBinder service) {
              /**
               * 通过服务端传递的IBinder对象,创建相应的Messenger
               * 通过该Messenger对象与服务端进行交互
               */
              mService = new Messenger(service);
              mBound = true;
          }
  
          public void onServiceDisconnected(ComponentName className) {
              // This is called when the connection with the service has been
              // unexpectedly disconnected -- that is, its process crashed.
              mService = null;
              mBound = false;
          }
      };
  
      public void sayHello(View v) {
          if (!mBound) return;
          // 创建与服务交互的消息实体Message
          Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
          try {
              //发送消息
              mService.send(msg);
          } catch (RemoteException e) {
              e.printStackTrace();
          }
      }
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_messenager);
          Button bindService= (Button) findViewById(R.id.bindService);
          Button unbindService= (Button) findViewById(R.id.unbindService);
          Button sendMsg= (Button) findViewById(R.id.sendMsgToService);
  
          bindService.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  Log.d("zj","onClick-->bindService");
                  //当前Activity绑定服务端
                  bindService(new Intent(ActivityMessenger.this, MessengerService.class), mConnection,
                          Context.BIND_AUTO_CREATE);
              }
          });
  
          //发送消息给服务端
          sendMsg.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  sayHello(v);
              }
          });
  
  
          unbindService.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  // Unbind from the service
                  if (mBound) {
                      Log.d("zj","onClick-->unbindService");
                      unbindService(mConnection);
                      mBound = false;
                  }
              }
          });
      }
  
  }
  ```
  在客户端进程中，我们需要创建一个ServiceConnection对象，该对象代表与服务端的链接，当调用bindService方法将当前Activity绑定到MessengerService时，onServiceConnected方法被调用，利用服务端传递给来的底层Binder对象构造出与服务端交互的Messenger对象，接着创建与服务交互的消息实体Message，将要发生的信息封装在Message中并通过Messenger实例对象发送给服务端。关于ServiceConnection、bindService方法、unbindService方法，前面已分析过，这里就不重复了，最后我们需要在清单文件声明Service和Activity，由于要测试不同进程的交互，则需要将Service放在单独的进程中，因此Service声明如下
  ```
  <service android:name=".messenger.MessengerService"
           android:process=":remote"
          />
  ```
  其中android:process=":remote"代表该Service在单独的进程中创建。
  接着多次点击绑定服务，然后发送信息给服务端，最后解除绑定，
  ![20161003162626563.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\1bd63ebb.png)
  
  通过上述例子可知Service服务端确实收到了客户端发送的信息，而且在Messenger中进行数据传递必须将数据封装到Message中，**因为Message和Messenger都实现了Parcelable接口，可以轻松跨进程传递数据，而Message可以传递的信息载体有，what,arg1,arg2,Bundle以及replyTo，至于object字段，对于同一进程中的数据传递确实很实用，但对于进程间的通信，则显得相当尴尬，在android2.2前，object不支持跨进程传输，但即便是android2.2之后也只能传递android系统提供的实现了Parcelable接口的对象，也就是说我们通过自定义实现Parcelable接口的对象无法通过object字段来传递，因此object字段的实用性在跨进程中也变得相当低了。不过所幸我们还有Bundle对象，Bundle可以支持大量的数据类型**。接着从Log我们也看出无论是使用拓展Binder类的实现方式还是使用Messenger的实现方式，它们的生命周期方法的调用顺序基本是一样的，即onCreate()、onBind、onUnBind、onDestroy，而且多次绑定中也只有第一次时才调用onBind()。
  
  ### 2.11 使用Message双向传递消息Demo
  在服务端，我们只需修改IncomingHandler，收到消息后，给客户端回复一条信息。
  ```
    /**
       * 用于接收从客户端传递过来的数据
       */
      class IncomingHandler extends Handler {
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  case MSG_SAY_HELLO:
                      Log.i(TAG, "thanks,Service had receiver message from client!");
                      //回复客户端信息,该对象由客户端传递过来
                      Messenger client=msg.replyTo;
                      //获取回复信息的消息实体
                      Message replyMsg=Message.obtain(null,MessengerService.MSG_SAY_HELLO);
                      Bundle bundle=new Bundle();
                      bundle.putString("reply","ok~,I had receiver message from you! ");
                      replyMsg.setData(bundle);
                      //向客户端发送消息
                      try {
                          client.send(replyMsg);
                      } catch (RemoteException e) {
                          e.printStackTrace();
                      }
  
                      break;
                  default:
                      super.handleMessage(msg);
              }
          }
      }
  ```
  接着修改客户端，为了接收服务端的回复，客户端也需要一个接收消息的Messenger和Handler，其实现如下：
  ```
    /**
       * 用于接收服务器返回的信息
       */
      private Messenger mRecevierReplyMsg= new Messenger(new ReceiverReplyMsgHandler());
  
  
      private static class ReceiverReplyMsgHandler extends Handler{
          private static final String TAG = "zj";
  
          @Override
          public void handleMessage(Message msg) {
              switch (msg.what) {
                  //接收服务端回复
                  case MessengerService.MSG_SAY_HELLO:
                      Log.i(TAG, "receiver message from service:"+msg.getData().getString("reply"));
                      break;
                  default:
                      super.handleMessage(msg);
              }
          }
      }
  ```
  除了添加以上代码，还需要在发送信息时把接收服务器端的回复的Messenger通过Message的replyTo参数传递给服务端，以便作为同学桥梁，
  ```
   public void sayHello(View v) {
          if (!mBound) return;
          // 创建与服务交互的消息实体Message
          Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
          //把接收服务器端的回复的Messenger通过Message的replyTo参数传递给服务端
          msg.replyTo=mRecevierReplyMsg;
          try {
              //发送消息
              mService.send(msg);
          } catch (RemoteException e) {
              e.printStackTrace();
          }
      }
  ```
  ![20161003173153947.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\239f7197.png)
  
  ### 2.12 关于绑定服务的注意点
  1. 多个客户端可同时连接到一个服务。不过，只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。当最后一个客户端取消与服务的绑定时，系统会将服务销毁（除非 startService() 也启动了该服务）。
  
  2. 通常情况下我们应该在客户端生命周期（如Activity的生命周期）的引入 (bring-up) 和退出 (tear-down) 时刻设置绑定和取消绑定操作，以便控制绑定状态下的Service，一般有以下两种情况：
    - 如果只需要在 Activity 可见时与服务交互，则应在 onStart() 期间绑定，在 onStop() 期间取消绑定。
    - 如果希望 Activity 在后台停止运行状态下仍可接收响应，则可在 onCreate() 期间绑定，在 onDestroy() 期间取消绑定。需要注意的是，这意味着 Activity 在其整个运行过程中（甚至包括后台运行期间）都需要使用服务，因此如果服务位于其他进程内，那么当提高该进程的权重时，系统很可能会终止该进程。
  
  3. **通常情况下(注意)，切勿在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每一次生命周期转换都会发生这些回调，这样反复绑定与解绑是不合理的。此外，如果应用内的多个 Activity 绑定到同一服务，并且其中两个 Activity 之间发生了转换，则如果当前 Activity 在下一次绑定（恢复期间）之前取消绑定（暂停期间），系统可能会销毁服务并重建服务，因此服务的绑定不应该发生在 Activity 的 onResume() 和 onPause()中。**
  
  4. 应用组件（客户端）可通过调用 bindService() 绑定到服务,Android 系统随后调用服务的 onBind() 方法，该方法返回用于与服务交互的 IBinder，而该绑定是异步执行的。
  
  
  ### 2.13 关于启动服务与绑定服务间的转换问题
  虽然服务的状态有启动和绑定两种，但实际上一个服务可以同时是这两种状态，也就是说，它既可以是启动服务（以无限期运行），也可以是绑定服务。有点需要注意的是Android系统仅会为一个Service创建一个实例对象，所以不管是启动服务还是绑定服务，操作的是同一个Service实例，而且由于绑定服务或者启动服务执行顺序问题将会出现以下两种情况：
  
  - 先绑定服务后启动服务
  如果当前Service实例先以绑定状态运行，然后再以启动状态运行，那么绑定服务将会转为启动服务运行，这时如果之前绑定的宿主（Activity）被销毁了，也不会影响服务的运行，服务还是会一直运行下去，指定收到调用停止服务或者内存不足时才会销毁该服务。
  
  - 先启动服务后绑定服务
  如果当前Service实例先以启动状态运行，然后再以绑定状态运行，当前启动服务并不会转为绑定服务，但是还是会与宿主绑定，只是即使宿主解除绑定后，服务依然按启动服务的生命周期在后台运行，直到有Context调用了stopService()或是服务本身调用了stopSelf()方法抑或内存不足时才会销毁服务。
  
  以上两种情况显示出启动服务的优先级确实比绑定服务高一些。不过无论Service是处于启动状态还是绑定状态，或处于启动并且绑定状态，我们都可以像使用Activity那样通过调用 Intent 来使用服务(即使此服务来自另一应用)。 当然，我们也可以通过清单文件将服务声明为私有服务，阻止其他应用访问。最后这里有点需要特殊说明一下的，由于服务在其托管进程的主线程中运行（UI线程），它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。 这意味着，如果服务将执行任何耗时事件或阻止性操作（例如 MP3 播放或联网）时，则应在服务内创建新线程来完成这项工作，简而言之，耗时操作应该另起线程执行。只有通过使用单独的线程，才可以降低发生“应用无响应”(ANR) 错误的风险，这样应用的主线程才能专注于用户与 Activity 之间的交互， 以达到更好的用户体验。
  
  
  ### 2.14 前台服务以及通知发送
  前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，状态栏位于“正在进行”标题下方，这意味着除非服务停止或从前台删除，否则不能清除通知。例如将从服务播放音乐的音乐播放器设置为在前台运行，这是因为用户明确意识到其操作。 状态栏中的通知可能表示正在播放的歌曲，并允许用户启动 Activity 来与音乐播放器进行交互。如果需要设置服务运行于前台，Android官方给我们提供了两个方法，分别是startForeground()和stopForeground()。
  - startForeground(int id, Notification notification) 
  该方法的作用是把当前服务设置为前台服务，其中id参数代表唯一标识通知的整型数，需要注意的是提供给 startForeground() 的整型 ID 不得为 0，而notification是一个状态栏的通知。
  
  - stopForeground(boolean removeNotification) 
  该方法是用来从前台删除服务，此方法传入一个布尔值，指示是否也删除状态栏通知，true为删除。 注意该方法并不会停止服务。 
  但是，如果在服务正在前台运行时将其停止，则通知也会被删除。
  
  ### 2.15 前台服务通知Demo (Android8.0以后兼容有问题)
  [Android 8通过startService引起crash问题 - 王强博客 - 博客园](https://www.cnblogs.com/wangqiang9/p/10595417.html)
  ForegroundService代码实现:
  
  ```
  package com.zejian.ipctest.foregroundService;
  
  import android.app.Notification;
  import android.app.Service;
  import android.content.Intent;
  import android.graphics.BitmapFactory;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  import android.support.v4.app.NotificationCompat;
  
  import com.zejian.ipctest.R;
  
  /**
   * Created by zejian
   * Time 2016/10/4.
   * Description:启动前台服务Demo
   */
  public class ForegroundService extends Service {
  
      /**
       * id不可设置为0,否则不能设置为前台service
       */
      private static final int NOTIFICATION_DOWNLOAD_PROGRESS_ID = 0x0001;
  
      private boolean isRemove=false;//是否需要移除
  
      /**
       * Notification
       */
      public void createNotification(){
          //使用兼容版本
          NotificationCompat.Builder builder=new NotificationCompat.Builder(this);
          //设置状态栏的通知图标
          builder.setSmallIcon(R.mipmap.ic_launcher);
          //设置通知栏横条的图标
          builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.screenflash_logo));
          //禁止用户点击删除按钮删除
          builder.setAutoCancel(false);
          //禁止滑动删除
          builder.setOngoing(true);
          //右上角的时间显示
          builder.setShowWhen(true);
          //设置通知栏的标题内容
          builder.setContentTitle("I am Foreground Service!!!");
          //创建通知
          Notification notification = builder.build();
          //设置为前台服务
          startForeground(NOTIFICATION_DOWNLOAD_PROGRESS_ID,notification);
      }
  
  
      @Override
      public int onStartCommand(Intent intent, int flags, int startId) {
          int i=intent.getExtras().getInt("cmd");
          if(i==0){
              if(!isRemove) {
                  createNotification();
              }
              isRemove=true;
          }else {
              //移除前台服务
              if (isRemove) {
                  stopForeground(true);
              }
              isRemove=false;
          }
  
          return super.onStartCommand(intent, flags, startId);
      }
  
      @Override
      public void onDestroy() {
          //移除前台服务
          if (isRemove) {
              stopForeground(true);
          }
          isRemove=false;
          super.onDestroy();
      }
  
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return null;
      }
  }
  ```
  在ForegroundService类中，创建了一个notification的通知，并通过启动Service时传递过来的参数判断是启动前台服务还是关闭前台服务，最后在onDestroy方法被调用时，也应该移除前台服务。以下是ForegroundActivity的实现：
  
  ```
  package com.zejian.ipctest.foregroundService;
  
  import android.app.Activity;
  import android.content.Intent;
  import android.os.Bundle;
  import android.view.View;
  import android.widget.Button;
  
  import com.zejian.ipctest.R;
  
  /**
   * Created by zejian
   * Time 2016/10/4.
   * Description:
   */
  public class ForegroundActivity extends Activity {
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_foreground);
          Button btnStart= (Button) findViewById(R.id.startForeground);
          Button btnStop= (Button) findViewById(R.id.stopForeground);
          final Intent intent = new Intent(this,ForegroundService.class);
  
  
          btnStart.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  intent.putExtra("cmd",0);//0,开启前台服务,1,关闭前台服务
                  startService(intent);
              }
          });
  
  
          btnStop.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  intent.putExtra("cmd",1);//0,开启前台服务,1,关闭前台服务
                  startService(intent);
              }
          });
      }
  }
  
  ```
  ### 2.16 保证服务不被杀死
  - 因内存资源不足而杀死Service 
  这种情况比较容易处理，可将onStartCommand() 方法的返回值设为 START_STICKY或START_REDELIVER_INTENT ，该值表示服务在内存资源紧张时被杀死后，在内存资源足够时再恢复。也可将Service设置为前台服务，这样就有比较高的优先级，在内存资源紧张时也不会被杀掉。
  
  - 用户通过 settings -> Apps -> Running -> Stop 方式杀死Service 
  这种情况是用户手动干预的，不过幸运的是这个过程会执行Service的生命周期，也就是onDestory方法会被调用，这时便可以在 onDestory() 中发送广播重新启动。这样杀死服务后会立即启动。这种方案是行得通的，但为程序更健全，我们可开启两个服务，相互监听，相互启动。服务A监听B的广播来启动B，服务B监听A的广播来启动A。
  ```
  package com.zejian.ipctest.neverKilledService;
  
  import android.app.Service;
  import android.content.BroadcastReceiver;
  import android.content.Context;
  import android.content.Intent;
  import android.content.IntentFilter;
  import android.os.IBinder;
  import android.support.annotation.Nullable;
  
  /**
   * Created by zejian
   * Time 2016/10/4.
   * Description:用户通过 settings -> Apps -> Running -> Stop 方式杀死Service
   */
  public class ServiceKilledByAppStop extends Service{
  
      private BroadcastReceiver mReceiver;
      private IntentFilter mIF;
  
      @Nullable
      @Override
      public IBinder onBind(Intent intent) {
          return null;
      }
  
      @Override
      public void onCreate() {
          super.onCreate();
          mReceiver = new BroadcastReceiver() {
              @Override
              public void onReceive(Context context, Intent intent) {
                  Intent a = new Intent(ServiceKilledByAppStop.this, ServiceKilledByAppStop.class);
                  startService(a);
              }
          };
          mIF = new IntentFilter();
          //自定义action
          mIF.addAction("com.restart.service");
          //注册广播接者
          registerReceiver(mReceiver, mIF);
      }
  
      @Override
      public void onDestroy() {
          super.onDestroy();
  
          Intent intent = new Intent();
          intent.setAction("com.restart.service");
          //发送广播
          sendBroadcast(intent);
  
          unregisterReceiver(mReceiver);
      }
  }
  ```
  - 用户通过 settings -> Apps -> Downloaded -> Force Stop 方式强制性杀死Service 
  
  ### 2.17 服务Service与线程Thread的区别
  - 两者概念的迥异
    - Thread 是程序执行的最小单元，它是分配CPU的基本单位，android系统中UI线程也是线程的一种，当然Thread还可以用于执行一些耗时异步的操作。
    - **Service是Android的一种机制**，**服务是运行在主线程上的，它是由系统进程托管**。它与其他组件之间的通信类似于client和server，是一种轻量级的IPC通信，**这种通信的载体是binder**，它是在linux层交换信息的一种IPC，而所谓的后台Service只不过是指没有UI的组件罢了。(把 Service 想象成一种消息服务)
  - 两者的执行任务迥异
    - 在android系统中，线程一般指的是工作线程(即后台线程)，而主线程是一种特殊的工作线程，它负责将事件分派给相应的用户界面小工具，如绘图事件及事件响应，因此为了保证应用 UI 的响应能力主线程上不可执行耗时操作。如果执行的操作不能很快完成，则应确保它们在单独的工作线程执行。
    - Service 则是android系统中的组件，一般情况下它运行于主线程中，因此在Service中是不可以执行耗时操作的，否则系统会报ANR异常，之所以称Service为后台服务，大部分原因是它本身没有UI，用户无法感知(当然也可以利用某些手段让用户知道)，但如果需要让Service执行耗时任务，可在Service中开启单独线程去执行。
  - 两者使用场景
    - 当要执行耗时的网络或者数据库查询以及其他阻塞UI线程或密集使用CPU的任务时，都应该使用工作线程(Thread)，这样才能保证UI线程不被占用而影响用户体验。
    - 在应用程序中，如果需要长时间的在后台运行，而且不需要交互的情况下，使用服务。比如播放音乐，通过Service+Notification方式在后台执行同时在通知栏显示着。
  - 两者的最佳使用方式
    在大部分情况下，Thread和Service都会结合着使用，比如下载文件，一般会通过Service在后台执行+Notification在通知栏显示+Thread异步下载，再如应用程序会维持一个Service来从网络中获取推送服务。在Android官方看来也是如此，所以官网提供了一个Thread与Service的结合来方便我们执行后台耗时任务，它就是IntentService，当然 IntentService并不适用于所有的场景，但它的优点是使用方便、代码简洁，**不需要我们创建Service实例并同时也创建线程**。
  
  ### 2.18 IntentService
  IntentService是一个抽象类，继承自Service，内部存在一个ServiceHandler（Handler）和HandlerThread（Thread）。
  IntentService是处理异步请求的一个类，在IntentService中有一个工作线程（HandlerThread）来处理耗时操作，启动IntentService的方式和普通的一样，不过当执行完任务之后，IntentService会自动停止。
  另外可以多次启动IntentService，每一个耗时操作都会以工作队列的形式在IntentService的onHandleIntent回调中执行，并且每次执行一个工作线程。
  **IntentService的本质是：封装了一个HandlerThread和Handler的异步框架**。
  
  **参考**
  [关于Android Service真正的完全详解，你需要知道的一切_zejian的博客-CSDN博客_android service](https://blog.csdn.net/javazejian/article/details/52709857)
  [](https://mp.weixin.qq.com/s/w1xiDiaOJTmxdcmQlCt0bg?)
  [【Android】Service前台服务的使用 - 简书](https://www.jianshu.com/p/5505390503fa)
  
  ## 3、Fragment
  [Android-ReadTheFuckingSourceCode/02_fragment.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/basic/02_fragment.md)
  ### 3.1 Activity与Fragment生命周期
  
  ![0d0a189d.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\88518779.png)
  
  Activity 直接影响它所包含的 Fragment 的生命周期，所以对 Activity 的某个生命周期方法的调用也会产生对Fragment 相同方法的调用。例如：当 Activity 的 onPause() 方法被调用时，它所包含的所有的 Fragment 的onPause() 方法都会被调用。
  
  Fragment 比 Activity 还要多出几个生命周期回调方法，这些额外的方法是为了与 Activity 的交互，如下：
  - onAttach()
  当 Fragment 被加入到 Activity 时调用（在这个方法中可以获得所在的 Activity）。
  - onCreateView()
  当 Activity 要得到 Fragment 的 layout 时，调用此方法，Fragment 在其中创建自己的 layout (界面)。
  - onActivityCreated()
  当 Activity 的 onCreated() 方法返回后调用此方法。
  - onDestroyView()
  当 Fragment 的 layout 被销毁时被调用。
  - onDetach()
  当 Fragment 被从 Activity 中删掉时被调用。
  
  一旦 Activity 进入 resumed 状态（也就是 running 状态），你就可以自由地添加和删除 Fragment 了。因此，只有当 Activity 在 resumed 状态时，Fragment 的生命周期才能独立的运转，其它时候是依赖于 Activity 的生命周期变化的。
  
  ### 3.2 创建方式
  
  ####  3.2.1 静态创建(静态加载)
  首先我们需要创建一个xml文件，然后创建与之对应的java文件，通过onCreatView()的返回方法进行关联，最后我们需要在Activity中进行配置相关参数即在Activity的xml文件中放上fragment的位置。
  ```
   <fragment
          android:name="xxx.BlankFragment"
          android:layout_width="match_parent"
          android:layout_height="match_parent">
      </fragment>
  ```
  #### 3.2.2 动态创建(动态加载)
  动态创建Fragment 主要有以下几个步骤：
  1. 创建待添加的fragment示例。
  2. 获取FragmentManager,在Activity中可以直接通过调用getSupportFramentManager()方法得到。
  3. 开启一个实务，通过调用beginTransaction()方法开启。
  4. 向内容内add fragment，需要传入容器的id和待添加的fragment实例。
  ```
  FragmentTransaction fragmentTransaction=fragmentManager.beginTransaction();
          hide(fragmentTransaction);
          if(i==0){
              if(fragment1==null){
                  fragment1=new Fragment1();
                  fragmentTransaction.add(R.id.framelayout,fragment1);
              }else {
                  fragmentTransaction.show(fragment1);
              }
          }
          if(i==1){
              if(fragment2==null){
                  fragment2=new Fragment2();
                  fragmentTransaction.add(R.id.framelayout,fragment2);
              }
              else {
                  fragmentTransaction.show(fragment2);
              }
          }
          fragmentTransaction.commit();
  
  ```
  5. 提交事务，调用commit()方法来完成。
  
  ### 3.3 Adapter对比 (ViewPage与Adapter使用)
  FragmentPageAdapter
  在每次切换页面时，只是将Fragment进行分离，适合页面较少的Fragment使用以保存一些内存，对系统内存不会多大影响。
  FragmentPageStateAdapter
  继承子 pager。该 PagerAdapter 的实现将只保留当前页面，当页面不在当前显示的时候，页面会清理，释放其资源。而在页面需要显示时，生成新的页面，重新生成数据。这么实现的好处就是当拥有大量的页面时，不必在内存中占用大量的内存。
  
  ### 3.4 Fragment与Activity通信
  
  #### 3.4.1 Activity向Fragment传值
  1. 第一种 handle方案
  activity响应事件，发送msg，到fragment中，而fragment中用来接收msg，所以用注册Handler对象，activity中发送msg的对象与fragment中handler对象必须为同一个（handler，msgqueen和looper相互唯一绑定），所以要在activity中暴露pubilic方法让fragment的acttch周期中传递handler。
  
  activity的响应事件发送msg：
  ```
  tvMain.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  //如果是activity相应事件，发送msg
                  if(handler == null){
                      return;
                  }
                  Message message = new Message();
                  Bundle bundle = new Bundle();
                  bundle.putString("hehe","我是activity发送的msg");
                  message.setData(bundle);
                  handler.sendMessage(message);
              }
          });
  ```
  activity中暴露的setHandler方法：
  ```
   //activity暴露方法来给fragment来设置
      public void setHandler(Handler handler){
          this.handler = handler;
      }
  ```
  fragment中传递handler：
  ```
  @Override
      public void onAttach(Context context) {
          super.onAttach(context);
          MainActivity activity = (MainActivity) getActivity();
          activity.setHandler(mHandler);
      }
  ```
  fragment注册handler用来接收msg：
  ```
  private Handler mHandler = new Handler(){
  
          @Override
          public void handleMessage(Message msg) {
              super.handleMessage(msg);
  
              Bundle bundle = msg.getData();
              strHandler = bundle.getString("hehe");
              textView.setText(strHandler+TwoFragment.class.getName());
          }
      };
  ```
  - fragment向activity传递消息同样可以利用此方法
  - Fragment对具体的activity存在耦合比较高，不利于Fragment复用，不利于维护。
  
  2. 第二种 Bundle方案
    1) Fragment动态加载的状态
    (Fragment是动态加载的)在activity中建一个bundle，把要传的值存入bundle，然后通过fragment的setArguments（bundle）传到fragment，在fragment中，用getArguments接收
  Activity:
  ```
  MyFragment fragment = new MyFragment();
  	Bundle bundle=new Bundle();
      bundle.putString("one","要传的值");
      fragment.setArguments(bundle);
      FragmentManager fm = getFragmentManager();
  	FragmentTransaction ft=fm.beginTransaction();
  	ft.add(R.id.frame,myFragment,"myFragment");
      ft.commit();
  ```
  Fragment:
  ```
  Bundle bundle=getArguments();
  String s=bundle.getString("one");
  ```
    2) Fragment静态加载的状态
  (Fragment是静态加载的)在Fragment中设置set,get方法，在activity中获取Fragment对象，fragment.setValue(),Fragment中getValue()
  注：静态加载Fragment的时候，一定要给Fragment设置一个唯一标识，id/tag
  
  activity：
  ```
  FragmentManager fm = getFragmentManager();
  MyFragment myFragment = (MyFragment)fm.findFragmentById(R.id.fragment);
  myFragment.setValue("传值");
  ```
  Fragment：
  ```
  	private String value;
  
  	private void setValue(String value){
  		this.value = value;
  	}
  
  	private String getValue(){
  		return this.value;
  	}
  
  //在需要获取的地方调用getValue()
  	@Nullable
      @Override
      public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
          View v=inflater.inflate(R.layout.fragment,null);
          // 给fragment上的按钮添加点击事件
          text = v.findViewById(R.id.tv_show);
          btn = v.findViewById(R.id.btn_get);
          btn.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
  				 text.setText(getValue());
              }
          });
          return v;
      }
  ```
  #### 3.4.2 Fragment向Activity传值
  1. 第一种 广播 方案
  在fragment中发送广播，在activity中注册广播接收者，并作出相应逻辑。
  在fragment中发送广播信息：
  ```
  button.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  //发送广播
                  Intent intent = new Intent();
                  intent.setAction("co.daggertest.fragment.ThreeFragment");
                  intent.putExtra("heihei","fragment发送广播");
                  //使用的本地广播，用于单个app内通信，性能和安全性好点
                  LocalBroadcastManager.getInstance(getActivity()).sendBroadcast(intent);
              }
          });
  ```
  在activity中注册广播：
  ```
    //注册本地广播接收者
          myBroadcast = new MyBroadcast();
          IntentFilter intentFilter = new IntentFilter();
          intentFilter.addAction("co.daggertest.fragment.ThreeFragment");
          LocalBroadcastManager.getInstance(this).registerReceiver(myBroadcast,intentFilter);
  ```
  ```
      内部类创建实例
   class MyBroadcast extends BroadcastReceiver{
  
          @Override
          public void onReceive(Context context, Intent intent) {
              heihei = intent.getStringExtra("heihei");
              tvMain.setText(heihei+MainActivity.class.getName());
  
          }
      }
  ```
  在activity的onDestory中注销广播：
  ```
  @Override
      protected void onDestroy() {
          super.onDestroy();
          LocalBroadcastManager.getInstance(this).unregisterReceiver(myBroadcast);
      }
  ```
  2. 第二种 回调接口 方案
  在fragment中创建接口，activity实现接口中方法，完成回调和参数传递。
  创建接口：
  ```
  public interface FourMainActivity{
          void changerSomething(String msg);
      }
  ```
  绑定activity：
  ```
   @Override
      public void onAttach(Context context) {
          super.onAttach(context);
          fourMainActivity = (FourMainActivity) context;
      }
  ```
  设置监听回调：
  ```
  button.setOnClickListener(new View.OnClickListener() {
              @Override
              public void onClick(View v) {
                  fourMainActivity.changerSomething("我是通过接口传递到MainActivity中");
              }
          });
  ```
  activity实现接口：
  ```
  public class MainActivity extends AppCompatActivity implements FourFragment.FourMainActivity
  ```
  实现接口方法：
  ```
  @Override
      public void changerSomething(String msg) {
          tvMain.setText(msg);
      }
  ```
  
  #### 3.4.3 Fragment与Fragment 之间是如何传值的
  
  1. 第一种 实现接口（中间依赖Activity） 方案
  [A_activity_Two_fragment· GitHub](https://github.com/wanglianghai/A_activity_Two_fragment/commit/3d591c6286bc57667d341f7a96d46bd2f2f8a3fb?diff=unified)
  [同一个Activity托管的两个Fragment之间的数据交互 - 简书](https://www.jianshu.com/p/dd6376cf1f9d)
  [在同一个Activity下实现两个Fragment之间的通信 - 简书](https://www.jianshu.com/p/bf923a23358c)
  
  2. 第二种 EventBus 方案 
  [EventBus使用详解_cyc的专栏-CSDN博客_eventbus](https://blog.csdn.net/u012317510/article/details/78935720)
  
  **参考**
  [Fragment与Activity之间的传值_Silence_Sep的博客-CSDN博客_fragment向activity传递数据](https://blog.csdn.net/Silence_Sep/article/details/86572297)
  [fragment通信的几种方式（接口框架）_HUandroid的博客-CSDN博客_fragmeng通信](https://blog.csdn.net/HUandroid/article/details/79481363)
  
  ### 3.5 API的区别
  1. add
  一种是add方式来进行show和add,这种方式你切换fragment不会让frament重新刷新，只会调用onHiddenChange(boolean isHidden)
  2. replace
  而用replace方式会使fragment重新刷新，因为add方式是将fragment隐藏了而不是销毁再创建，replace方式每次都是重新重建。
  3. commit/commitAllowingStateLoss 
  [Android commit 和 commitAllowingStateLoss 的区别 - 简书](https://www.jianshu.com/p/83e673c453f9)
  两者都可以提交fragment的操作，唯一的不同是第二种方法，在Activity和FragmentActivity内的onSaveInstanceState方法保存了fragment的状态。在onSaveInstanceState方法后调用commit和commitAllowingStateLoss会引起一种问题：因内存不足而把不显示在前台的activity(带有 fragment)销毁，之后用户再回到此 activity 页面时，是会丢失在onSaveInstanceState后调用commit方法提交的页面状态信息!不同的只是调用commit会报错，调用commitAllowingStateLoss不报错
  
  ### 3.6 懒加载(解决预加载问题)
  经常在使用fragment时，常常会结合着viewpager使用，那么就会遇到一个问题，就是初始化fragment的时候，会连同网络请求一起执行，这样非常消耗性能，最理想的方式是，只有用户点开或滑动到当前fragment时，才进行请求网络的操作。因此，我们就产生了懒加载这样一个说法。
  
  在Viewpager与fragment使用时，默认加载前两个fragment。这样很容易造成网络丢包，阻塞等问题。
  
  最好的解决的问题的方法，重写Fragment的setUserVisibleHint()方法，实现Fragment内部的懒加载机制。
  
  由于setUserVisibleHint这个方法优于onCreate()，onCreateView()方法，它会通过isVisiBleToUser告诉我们当前Fragment我们是否可见，当可见时候再进行网络加载。但是如果在setUserVisibleHint()要实现懒加载的话，就必须要确保View 以及其他变量都已经初始化结束，避免空指针。
  
  [Fragment的懒加载](https://blog.csdn.net/u011315960/article/details/71404177)
  
  ## 4、Activity
  ### 4.1 点击Launcher图标来启动Activity
  用户从Launcher程序点击应用图标可启动应用的入口Activity，Activity启动时需要多个进程之间的交互，Android系统中有一个zygote进程专用于孵化Android框架层和应用层程序的进程。还有一个system_server进程，该进程里运行了很多binder service。例如ActivityManagerService，PackageManagerService，WindowManagerService，这些binder service分别运行在不同的线程中，其中ActivityManagerService负责管理Activity栈，应用进程，task。
  
  用户在Launcher程序里点击应用图标时，会通知ActivityManagerService启动应用的入口Activity，ActivityManagerService发现这个应用还未启动，则会通知Zygote进程孵化出应用进程，然后在这个dalvik应用进程里执行ActivityThread的main方法。应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法。
  
  ### 4.2 Activity生命周期
  ![16bff4353c5b177c.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\51da952a.png)
  
  #### 4.2.1 Activity的形态
  **Active/Running:** 
  Activity处于活动状态，此时Activity处于栈顶，是可见状态，可与用户进行交互
  
  **Paused:**
  当Activity失去焦点时，或被一个新的非全屏的Activity，或被一个透明的Activity放置在栈顶时，Activity就转化为Paused状态。但我们需要明白，此时Activity只是失去了与用户交互的能力，其所有的状态信息及其成员变量都还存在，只有在系统内存紧张的情况下，才有可能被系统回收掉。
  
  **Stopped:**
  当一个Activity被另一个Activity完全覆盖时，被覆盖的Activity就会进入Stopped状态，此时它不再可见，但是跟Paused状态一样保持着其所有状态信息及其成员变量。
  
  **Killed:**
  当Activity被系统回收掉时，Activity就处于Killed状态。
  
  #### 4.2.2 Activity的生命周期
  所谓的典型的生命周期就是在有用户参与的情况下，Activity经历从创建，运行，停止，销毁等正常的生命周期过程。
  
  **onCreate**
  该方法是在Activity被创建时回调，它是生命周期第一个调用的方法，我们在创建Activity时一般都需要重写该方法，然后在该方法中做一些初始化的操作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。
  
  **onStart**
  此方法被回调时表示Activity正在启动，此时Activity已处于可见状态，只是还没有在前台显示，因此无法与用户进行交互。可以简单理解为Activity已显示而我们无法看见摆了。
  
  **onResume**
  当此方法回调时，则说明Activity已在前台可见，可与用户交互了（处于前面所说的Active/Running形态），onResume方法与onStart的相同点是两者都表示Activity可见，只不过onStart回调时Activity还是后台无法与用户交互，而onResume则已显示在前台，可与用户交互。从流程图可以看出当Activity停止后（onPause方法和onStop方法被调用），重新回到前台时也会调用onResume方法，因此在onResume方法中初始化一些资源，然后在onPause或者onStop方法中释放的资源。
  
  **onPause**
  此方法被回调时则表示Activity正在停止（Paused形态），一般情况下onStop方法会紧接着被回调。但通过流程图看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象，这可能是用户操作使当前Activity退居后台后又迅速地再回到到当前的Activity，此时onResume方法就会被回调。
  当然，在onPause方法中可以做一些数据存储或者动画停止或者资源回收的操作，但是不能太耗时，因为这可能会影响到新的Activity的显示,而onPause方法执行完成后，新Activity的onResume方法才会被执行。
  
  **onStop**
  一般在onPause方法执行完成直接执行，表示Activity即将停止或者完全被覆盖（Stopped形态），此时Activity不可见，仅在后台运行。同样地，在onStop方法可以做一些资源释放的操作（不能太耗时）。
  
  **onRestart**
  表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。
  
  **onDestroy**
  此时Activity正在被销毁，也是生命周期最后一个执行的方法，一般我们可以在此方法中做一些回收工作和最终的资源释放。
  
  1) 当Activity启动时，依次会调用onCreate(),onStart(),onResume()，
  2) 当Activity退居后台时（不可见，点击Home或者被新的Activity完全覆盖），onPause()和onStop()会依次被调用。
  3) 当Activity退居后台且系统内存不足， 系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走onCreate()-->onStart()--->onResume()
  4) 当Activity返回前台（从桌面回到原Activity或者被覆盖后又回到原Activity）时，onRestart()，onStart()，onResume()会依次被调用。
  5) 当Activity退出销毁时（点击back键），onPause()，onStop()，onDestroy()会依次被调用，到此Activity的整个生命周期方法回调完成。
  6) 锁定屏与解锁屏幕 只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()
  7) 两个Activity之间切换: Activity A 启动另一个Activity B，回调如下:Activity A 的onPause() → Activity B的onCreate() → onStart() → onResume() → Activity A的onStop();如果B是透明主题又或则是个DialogActivity，则不会回调A的onStop；
  
  **注意**
  1. 透明主题对生命周期的影响
    当A-Activity启动B-Activity时，并且启动之后A-Activity还处于部分可见状态，当启动完B之后并不回调A的onStop()方法。
  [Activity A启动Activity B它们的生命周期变化（及设置Activity的透明度）_YoungForYou-CSDN博客_activitya启动activityb生命周期](https://blog.csdn.net/weixin_43589682/article/details/97030740)
  2. 屏幕旋转,屏幕大小改,键盘发生了改变,键盘的可用性发生了改变对生命周期的影响
  
  没有配置 configChanges：
  ```
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onResume()
  A: ==> onPause()
  A: ==> onSaveInstanceState()
  A: ==> onStop()
  A: ==> onDestroy()
  屏幕旋转后
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onRestoreInstanceState()
  A: ==> onResume()
  ```
  配置 configChanges 后：android:configChanges="keyboard|orientation|screenSize|keyboardHidden"
  ```
  A: ==> onCreate()
  A: ==> onStart()
  A: ==> onResume()
  A: ==> onConfigurationChanged()
  ```
  
  #### 4.2.3 保存与恢复 onSaveInstanceState() onRestoreInstanceState()
  1. onSaveInstanceState()
  (1)、当用户按下HOME键时。会调用 onSaveInstanceState() 方法
  (2)、长按HOME键，选择运行其他的程序时。会调用 onSaveInstanceState() 方法 
  (3)、按下电源按键（关闭屏幕显示）时。会调用 onSaveInstanceState() 方法
  (4)、从activity A中启动一个新的activity时。会调用 onSaveInstanceState() 方法
  (5)、屏幕方向切换时，例如从竖屏切换到横屏时。会调用 onSaveInstanceState() ,onRestoreInstanceState()方法
  
  2. onRestoreInstanceState()
  onRestoreInstanceState()被调用的前提是，activity A“确实”被系统销毁了。
  
  3. 屏幕旋转测试
  android:screenOrientation="portrait"
  去掉，支持转屏。然后就一定会触发onSaveInstanceState()和onRestoreInstanceState()。
  因为当 Activity 横竖屏切换的时候会重新走一遍生命周期，所以 Activity 会被销毁创建，由此会执行 onRestoreInstanceState() 方法。
  
  4. 保存Activity状态
  当Activity开始停止时，系统会调用，onSaveInstanceState()以便您的Activity可以使用一组键值对来保存状态信息。此方法的默认实现保存有关Activity视图层次结构状态的信息，例如EditText小部件中的文本或ListView的滚动位置。
  为了保存Activity的附加状态信息，您必须实现onSaveInstanceState()并向对象添加键值对Bundle
  ```
  static final String STATE_SCORE = "playerScore";
  static final String STATE_LEVEL = "playerLevel";
  ...
  
  @Override
  public void onSaveInstanceState(Bundle savedInstanceState) {
      // 保存用户自定义的状态
      savedInstanceState.putInt(STATE_SCORE, mCurrentScore);
      savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);
      
      // 调用父类交给系统处理，这样系统能保存视图层次结构状态
      super.onSaveInstanceState(savedInstanceState);
  }
  ```
  
  5. 恢复Activity状态
  当Activity在之前被破坏后重新创建时，您可以从Bundle系统通过您的Activity中恢复您的保存状态。这两个方法onCreate()和onRestoreInstanceState()回调方法都会收到Bundle包含实例状态信息的相同方法。
  
  因为onCreate()调用该方法是否系统正在创建一个新的Activity实例或重新创建一个以前的实例，所以必须Bundle在尝试读取之前检查该状态是否为空。如果它为空，那么系统正在创建一个Activity的新实例，而不是恢复之前被销毁的实例。
  ```
  @Override
  protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState); // 记得总是调用父类
     
      // 检查是否正在重新创建一个以前销毁的实例
      if (savedInstanceState != null) {
          // 从已保存状态恢复成员的值
          mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
          mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
      } else {
          // 可能初始化一个新实例的默认值的成员
      }
      ...
  }
  ```
  onCreate()可以选择执行onRestoreInstanceState()，而不是在系统调用onStart()方法之后恢复状态。系统onRestoreInstanceState()只有在存在保存状态的情况下才会恢复，因此您不需要检查是否Bundle为空：
  ```
  public void onRestoreInstanceState(Bundle savedInstanceState) {
      // 总是调用超类，以便它可以恢复视图层次超级
      super.onRestoreInstanceState(savedInstanceState);
     
      // 从已保存的实例中恢复状态成员
      mCurrentScore = savedInstanceState.getInt(STATE_SCORE);
      mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
  }
  ```
  
  ### 4.3 启动模式
  #### 4.3.1 standard
  默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加。
  
  #### 4.3.2 singleTop
  可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，**启动相同的Activity**，不会创建新的实例，而会调用其onNewIntent方法。
  
  #### 4.3.3 singleTask
  只有一个实例。在同一个应用程序中启动他的时候，若Activity不存在，则会在当前task创建一个新的实例，若存在，则会把task中在其之上的其它Activity destory掉并调用它的onNewIntent方法。
  
  如果是在别的应用程序中启动它，则会新建一个task，并在该task中启动这个Activity，singleTask允许别的Activity与其在一个task中共存，也就是说，如果我在这个singleTask的实例中再打开新的Activity，这个新的Activity还是会在singleTask的实例的task中。
  
  个人理解：启动顺序A->B->C->D->B ,这时候B由于是singleTask,会把C D destory掉。task里只剩A B.
  [singleTask启动模式引发的问题和感悟 - 简书](https://www.jianshu.com/p/fe98ae8e3fb4)
  
  #### 4.3.4 singleInstance
  只有一个实例，并且这个实例独立运行在一个task中，这个task只有这个实例，不允许有别的Activity存在。
  [Activity SingleInstance启动模式 - javakam - 博客园](https://www.cnblogs.com/jooy/p/9494165.html)
  [SingleTask和SingleInstance详解_ywj2167917的专栏-CSDN博客_singletask和singleinstance](https://blog.csdn.net/ywj2167917/article/details/8827830)
  
  #### 4.3.5 task
  我们知道，一个应用中可能有多个 Activity，而这些 Activity 被以栈的形式管理。当我们新打开 Activity 或者按返回时，会导致 Activity 的入栈/出栈。
  Task 是指在执行特定任务时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈中。
  
  ### 4.4 ActivityThread类
  1. 在Android中它就代表了Android的主线程，注意是代表而不是说它就是一个Thread类
  2. 它是创建完新进程之后（肯定是在一个线程中啊），main函数被加载，然后执行一个loop的循环使当前线程进入消息循环，并且作为主线程。
  3. 接下来还会初始化很多必要的属性. 它的很多成员变量和内部类十分的重要，深入理解这些成员变量有助于我们进一步的认识Android系统的各个组件的交互。
  
  ### 4.5 Intent类
  Intent 分两种，显式 Intent 和隐式 Intent。 
  #### 4.5.1 显式Intent
  如果一个 Intent 明确指定了要启动的组件的完整类名，那么这个 Intent 就是显式 Intent.
  ```
  Intent intent = new Intent(this, xxx.class);
  startActivity(intent);
  ```
  
  #### 4.5.2 隐式Intent
  [Android的进阶学习(三)--Intent和IntentFilter - 简书](https://www.jianshu.com/p/a2f826064e29)
  [IntentFilter匹配规则详解 - 天涯海角路 - 博客园](https://www.cnblogs.com/aademeng/articles/11026731.html)
  IntentFilter(意图过滤器),当隐式启动系统组件的时候，就会根据IntentFilter来筛选出合适的进行启动。
  在Intent启动的时候对应设置Action、Category、DataAndType，这里设置的是为了过滤的时候对应IntentFilter匹配action、category、data。
  除过滤广播的的IntentFilter可以在代码中创建外，其它的IntentFilter都得在AndroidManifest.xml中给设置。
  
  ```
  Intent  intent = new Intent();
  intent.addAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.addDataType("video/mpeg");
  ```
  AndroidManifest.xml 设置
  ```
  <activity  android:name=".Activity_B"    
             android:label="@string/title_activity_activity__b"
             android:launchMode="singleInstance">  
    <intent-filter> 
      <action android:name="android.intent.action.ANSWER" />    
      <category android:name="android.intent.category.APP_EMAIL" />        
      <data  android:host="www.mathiasluo.com"   
             android:scheme="http" />  
    </intent-filter>
  </activity>
  ```
  一个组件可以有多个IntentFilter，在过滤的时候只要有一组符合要求的，就会被视为过滤通过。
  
  1) action匹配
  action的匹配要求Intent中的action存在且必须和过滤规则中的其中一个action相同
  2) category匹配
  如果Intent中的存在category那么所有的category都必须和IntentFilter中的category相同。才能和这个Activity匹配。
  Intent中的category数量可能少于IntentFilter中的category数量，但是Intent中category必须和IntentFilter中的category相同才能匹配。
  3) data匹配
  如果IntentFilter中有定义data，那么Intent中也必须也要定义date
  4) 隐式启动的判断
  判断隐式启动的Intent是否能找到相应的组件方法
  <一>
  ```
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.setDataAndType(Uri.EMPTY, "video/mpeg");
  PackageManager packageManager = getPackageManager();
  List<ResolveInfo> infoList = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
  Log.i(TAG, infoList.size() + "");
  if (infoList.size() != 0) {  
    startActivity(intent);
  } else { 
     Log.e(TAG, "没有匹配到Activity");
  }
  ```
  <二>
  ```
  Intent intent = new Intent();
  intent.setAction(Intent.ACTION_BATTERY_LOW);
  intent.addCategory(Intent.CATEGORY_APP_EMAIL);
  intent.setDataAndType(Uri.EMPTY, "video/mpeg");
  ComponentName name =  intent.resolveActivity(getPackageManager());
  if (name != null){
      startActivity(intent);
  }else {
      Log.e(TAG,"没有匹配到Activity");
  }
  ```
  
  **注意**
  1. 如果 intent-filter 中没有包含任何Action类型，那么无论什么Intent请求都无法和这条 nintent-filter 匹配。
  2. 如果Intent请求中没有设定Action类型，那么只要 intent-filter 中包含有Action类型，这个Intent请求就将顺利地通过 intent-filter 的行为测试。
  3. intent中可以不存在category，但如果存在就必须匹配intent-filter其中一个
  4. 系统在startActivity或者startActivityForResult的时候默认为Intent加上一个android.intent.category.DEAFAULT，所以必须在intent-filter中加上android.intent.category.DEFAULT这个category
  
  ### 4.6 URL Scheme
  Android 中的 Scheme 是一种页面内跳转协议，是一种非常好的实现机制。通过定义自己的 Scheme 协议，可以非常方便跳转 App 中的各个页面。
  #### 4.6.1 使用场景
  通过小程序，利用 Scheme 协议打开原生 App。
  - H5 页面点击锚点，根据锚点具体跳转路径 App 端跳转具体的页面。
  - App 端收到服务器端下发的 Push 通知栏消息，根据消息的点击跳转路径跳转相关页面。
  - App 根据URL跳转到另外一个 App 指定页面。
  - 通过短信息中的 URL 打开原生 App。
  
  #### 4.6.2 Scheme 路径的规则
  ```
  <scheme> :// <host> : <port> [<path>|<pathPrefix>|<pathPattern>]
  ```
  #### 4.6.3 设置Scheme
  在 AndroidManifest.xml 中对标签增加设置 Scheme。
  ```
  <activity
      android:name=".ui.activity.SchemeActivity"
      android:screenOrientation="portrait">
      <!--Android 接收外部跳转过滤器-->
      <!--要想在别的 App 上能成功调起 App，必须添加 intent 过滤器-->
      <intent-filter>
          <!--协议部分配置，注意需要跟 web 配置相同-->
          <!--协议部分，随便设置 aa://bb:1024/from?type=jeanboy-->
          <data android:scheme="aa"
              android:host="bb"
              android:port="1024"
              android:path="/from"/>
          <!--下面这几行也必须得设置-->
          <category android:name="android.intent.category.DEFAULT" />
          <!--表示 Activity 允许通过网络浏览器启动，以显示链接方式引用，如图像或电子邮件-->
          <category android:name="android.intent.category.BROWSABLE" />
          <action android:name="android.intent.action.VIEW" />
      </intent-filter>
  </activity>
  ```
  #### 4.6.4 原生调用
  ```
  Uri uri = Uri.parse("aa://bb:1024/from?type=jeanboy");
  Intent intent = new Intent(Intent.ACTION_VIEW, uri);
  startActivity(intent);
  ```
  #### 网页调用
  ```
  <a href="aa://bb:1024/from?type=jeanboy">打开 App</a>
  ```
  #### 在Activity中处理Scheme跳转
  ```
  public class SchemeActivity extends AppCompatActivity {
  
      @Override
      protected void onCreate(@Nullable Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          Uri uri = getIntent().getData();
          if (uri != null) {
              //获取指定参数值
              String type = uri.getQueryParameter("type");
              Log.e("SchemeActivity", "type:" + type);
  
              if(type.equals("jeanboy")){
                  ActivityUtils.startActivity(XXXActivity.class);
              }else if(type.equals("main")){
                  ActivityUtils.startActivity(MainActivity.class);
              }
          }
          finish();
      }
  }
  ```
  
  ### 4.x 拓展
  #### 4.x.1 ActivityManagerService[AMS]
  AMS是系统的引导服务，应用进程的启动、切换和调度、四大组件的启动和管理都需要AMS的支持。
  [ActivityManagerService 你了解多少？ - Android - 掘金](https://juejin.im/entry/582d319e0ce463006ce68110)
  
  #### 4.x.2 ActivityStarter
  ActivityStarter是加载Activity的控制类，收集所有的逻辑来决定如何将Intent和Flags转为Activity并将其与Task和Stack关联。
  
  #### 4.x.3 ActivityStackSupervisor
  AMS 通过操作ActivityStackSupervisor来管理Activity
  
  #### 4.x.4 ActivityStack
  ActivityStack从名称来看是跟栈相关的类，其实它是一个管理类，用来管理系统所有Activity的各种状态。它由ActivityStackSupervisor来进行管理的，而ActivityStackSupervisor在AMS中的构造方法中被创建。
  
  #### 4.x.5 ApplicationThread
  它是ActivityThread的私有内部类，也是一个Binder对象。在此处它是作为IApplicationThread对象的server端等待client端 的请求然后进行处理，最大的client就是AMS.
  
  #### 4.x.6 Context,Activity,Application的关系
  相同：Activity和Application都是Context的子关系
  不同：
     1.维护的生命周期不同
     2.Context维护的是当前Activity的生命周期
     3.Application维护的是整个项目的周期
  
  ### 4.6 Context
  1.描述的一个应用程序环境的信息即上下文的意思，在实际应用中它也确实是起到了管理 上下文环境中各个参数和变量的总用,方便我们可以简单的访问到各种资源。
  2.Context是一个接口，实现该接口的具体实现类Contextlml
  3.通过它我们可以获取应用程序的资源和类，也包括一些应用级别软件，例如，启动一个Activity,发送广播，接受intent信息等。
  ![16dfd0c7a29d65e6.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\cca26d9c.png)
  
  ## 5、Broadcast
  ### 5.1 简介
  Broadcast（广播） 是 Android 的四大组件之一，用于进程/线程间通信。
  
  广播最大的特点就是发送方并不关心接收方是否接到数据，也不关心接收方是如何处理数据的，它只负责「说」而不管你「听不听」。
  
  广播可以来之系统，例如，Android 系统在发生各种系统事件时发送广播（系统启动或者设备开始充电时）。
  
  也可以来自于其他应用程序，例如，应用程序也可以发送自定义广播，来通知其他应用程序接受他们可能感兴趣的内容（更新数据）。
  
  ### 5.2 广播的分类
  #### 5.2.1 按发送方式分类
  - 标准广播
  是一种「完全异步执行」的广播，没有任何先后顺序，所有的广播接收器几乎同一时刻接收到这条广播消息，效率高，无法被截断。
  - 有序广播
  是一种「同步执行」的广播，有先后顺序，同一时刻只有一个接收器可以接收这个广播消息，优先级高的广播接收器可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法接收广播消息了。
  
  #### 5.2.2 按注册方式分类
  - 静态广播
  不管应用程序是否处于活动状态，都会进行监听。每次触发都会建立新的 Receiver 对象。
  - 动态广播
  在代码中进行注册，注意动态注册的广播一定要取消注册才行，通常是在 onDestroy() 方法中调用 unregisterReceiver() 方法来实现。
  从开始创建直到其被解除注册会使用同一个 Receiver，无论这个广播被触发几次。
  
  #### 5.2.3 按定义方式分类
  - 系统广播
  Android 系统中内置了多个系统广播，每个系统广播都具有特定的 IntentFilter，其中主要包括具体的 Action，系统广播发出后，将被相应的 BroadcastReceiver 接收。系统广播在系统内部当特定事件发生时，由系统自动发出。
  
  - 自定义广播
  由应用程序开发者自己定义的广播。
  
  #### 5.2.4 按范围方式分类
  - 全局广播
  发出的广播可以被其他任意的应用程序接收，或者可以接收来自其他任意应用程序的广播。
  - 本地广播
  只能在应用程序的内部进行传递的广播，广播接收器也只能接收内部的广播，不能接受其他应用程序的广播。
  
  ### 5.3 广播的使用
  #### 5.3.1 创建广播接收器
  使用广播我们需要先创建 BroadcastReceiver（广播接收器） ，直接继承 BroadcastReceiver 创建子类并实现父类的 onReceive() 方法即可
  ```
  public class MyReceiver extends BroadcastReceiver {
    // 自定义 action
    private static final String ACTION = "com.jeanboy.broadcast.MyReceiverFilter";
    
    @Override
    public void onReceive(Context context, Intent intent) {
      //TODO: 接收到广播进行处理
    }
  }
  ```
  #### 5.3.2 静态广播
  在使用广播时还需要在 AndroidMainfest 文件中定义，也就是注册静态广播。
  ```
  <receiver android:name=".ui.broadcast.MyReceiver"
            android:enabled="true"
            android:exported="true">
      <intent-filter>
          <!-- 例如：接收系统开机广播 -->
          <action android:name="android.intent.action.BOOT_COMPLETED" />
          <!-- 例如：接收自定义的广播 -->
          <action android:name="com.jeanboy.broadcast.MyReceiverFilter" />
      </intent-filter>
  </receiver>
  ```
  上面的 enabled 设置为 true 意味着能够接受到广播信息。exported 为 true 意味着能够接收到外部 APK 发送的广播信息。
  
  #### 5.3.3 动态广播
  使用动态广播不需要在 AndroidMainfest 文件中定义，只需在代码中注册即可。
  ```
  // 创建广播
  MyReceiver myReceiver = new MyReceiver();
  // 创建 IntentFilter
  IntentFilter intentFilter = new IntentFilter();
  // 例如：添加系统广播 action 接受网络变化
  intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
  // 例如：添加自定义的 action
  intentFilter.addAction(MyReceiver.ACTION);
  // 注册广播
  registerReceiver(myReceiver, intentFilter);
  // 注销广播
  unregisterReceiver(myReceiver);
  ```
  #### 5.3.4 发送广播
  发送广播比较简单，无论静态广播还是动态广播，都是如下方式（系统广播 Android 系统会自动发送，不在本文讨论范围）。
  ```
  // 创建 Intent
  Intent intent = new Intent();
  // 例如：添加自定义的 action
  intent.setAction(MyReceiver.ACTION);
  // 发送广播
  sendBroadcast(intent);
  ```
  ### 5.4 带权限的广播
  使用广播可能引发的安全问题：
  - 如果别的应用程序监听我们的广播，那么会造成我们应用程序的数据泄露；
  - 如果别的应用程序冒充我们的应用发送广播，那么就会频繁的启动我们的广播接收程序，造成我们应用的混乱，甚至崩溃。
  为了避免以上安全问题，Android 为我们提供了权限机制。
  首先在注册静态广播时可以在 AndroidMainfest 文件中添加权限。
  ```
  <manifest ...>
    <!-- 自定义一个自己的权限 -->
    <permission android:name="com.jeanboy.permissions.MY_BROADCAST"/>
    <!-- 使用自定义的权限 -->
    <uses-permission android:name="com.jeanboy.permissions.MY_BROADCAST"/>
  
    <application ...>
      <!-- 添加权限 -->
      <receiver android:name=".ui.broadcast.MyReceiver"
                android:permission="com.jeanboy.broadcast.MY_BROADCAST"
                android:enabled="true"
                android:exported="true">
        <intent-filter>
          <!-- 例如：接收自定义的广播 -->
          <action android:name="com.jeanboy.broadcast.MyReceiverFilter" />
        </intent-filter>
      </receiver>
    </application>
  </manifest>
  ```
  然后在我们发送广播时，可以为它指定一个权限，只有具有该权限的应用才能接收到广播，如下所示：
  ```
  // 创建 Intent
  Intent intent = new Intent();
  // 例如：添加自定义的 action
  intent.setAction(MyReceiver.ACTION);
  // 发送广播，添加权限
  sendBroadcast(intent, "com.jeanboy.permissions.MY_BROADCAST");
  ```
  ### 5.5 本地广播
  上面介绍的 Broadcast 用于应用之间的传递消息，本质上它是跨进程的，还有可能被其他应用拦截。
  
  而 LocalBroadcast（本地广播）用于应用内部传递消息，比 跨进程Broadcast 更加高效，它只在应用内部有效，不需要考虑安全问题。
  
  本地广播的创建仍然是继承 BroadcastReceiver 创建子类，并实现父类的 onReceive() 方法。在注册、发送、注销广播时使用 LocalBroadcastManager 来进行相关操作。
  ```
  // 创建广播
  MyReceiver myReceiver = new MyReceiver();
  // 创建 IntentFilter
  IntentFilter intentFilter = new IntentFilter();
  // 例如：添加自定义的 action
  intentFilter.addAction(MyReceiver.ACTION);
  // 注册本地广播
  LocalBroadcastManager.getInstance(this)
                  .registerReceiver(myReceiver, intentFilter);
  
  // 发送广播
  Intent intent = new Intent(MyReceiver.ACTION));
  LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
  
  // 注销本地广播
  LocalBroadcastManager.getInstance(this).unregisterReceiver(myReceiver);
  ```
  
  ## 6、ContentProvider
  ### 6.1 ContentProvider 作用与原理
  作用：进程间进行数据交互与共享，即跨进程通信。
  ![944365-3c4339c5f1d4a0fd.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\931e58bc.png)
  
  原理：Android中的Binder机制。
  
  ### 6.2 ContentProvice 具体使用
  
  #### 6.2.1 统一资源标识符（URL）
  外界通过URL来获取ContentProvider其中的数据，再进行数据操作。
  ![944365-96019a2054eb27cf.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\b1ee5396.png)
  
  - 设置URI
  Uri uri = Uri.parse("content://com.carson.provider/User/1") 
  上述URI指向的资源是：名为 `com.carson.provider`的`ContentProvider` 中表名 为`User` 中的 `id`为1的数据
  
  - URI模式存在匹配通配符* & ＃
  ```
  // *：匹配任意长度的任何有效字符的字符串
  // 以下的URI 表示 匹配provider的任何内容
  content://com.example.app.provider/* 
  // ＃：匹配任意长度的数字字符的字符串
  // 以下的URI 表示 匹配provider中的table表的所有行
  content://com.example.app.provider/table/# 
  ```
  #### 6.2.2 MIME数据类型
  作用：指定某个扩展名的文件用某种应用程序来打开
  如指定.html文件采用text应用程序打开、指定.pdf文件采用flash应用程序打开
  
  #### 6.2.3 MIME具体使用
  1. ContentProvider根据 URI 返回MIME类型
  ```
  ContentProvider.geType(uri)
  ```
  2. MIME类型组成
  每种MIME类型 由2部分组成 = 类型 + 子类型
  ```
  text / html
  // 类型 = text、子类型 = html
  ```
  
  3. MIME类型形式
     1)单条记录 
  ```
   vnd.android.cursor.item/自定义
  ```
     2)多条记录
  ```
   vnd.android.cursor.dir/自定义 
  ```
  - vnd：表示父类型和子类型具有非标准的、特定的形式。
  - 父类型已固定好（即不能更改），只能区别是单条还是多条记录
  - 子类型可自定义
  
  ```
  <-- 单条记录 -->
    // 单个记录的MIME类型
    vnd.android.cursor.item/vnd.yourcompanyname.contenttype 
  
    // 若一个Uri如下
    content://com.example.transportationprovider/trains/122   
    // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型
    vnd.android.cursor.item/vnd.example.rail
  
  
  <-- 多条记录 -->
    // 多个记录的MIME类型
    vnd.android.cursor.dir/vnd.yourcompanyname.contenttype 
    // 若一个Uri如下
    content://com.example.transportationprovider/trains 
    // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型
    vnd.android.cursor.dir/vnd.example.rail
  
  ```
  
  ### 6.3 ContentProvice类
  
  #### 6.3.1 四个核心方法
  ```
    public Uri insert(Uri uri, ContentValues values) 
  ```
  外部进程向 ContentProvider 中添加数据
  ```
   public int delete(Uri uri, String selection, String[] selectionArgs) 
  ```
  外部进程 删除 ContentProvider 中的数据
  ```
  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
  ```
  外部进程更新 ContentProvider 中的数据
  
  ```
  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)　 
  ```
  外部应用 获取 ContentProvider 中的数据
  
  #### 6.3.2 两个其它方法
  ```
  public boolean onCreate() 
  ```
  ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用
  注：运行在ContentProvider进程的主线程，故不能做耗时操作
  
  ```
  public String getType(Uri uri)
  
  ```
  得到数据类型，即返回当前 Url 所代表数据的MIME类型
  
  ### 6.4 ContentResolver类
  
  1. 作用
     - 通过 URI 即可操作 不同的ContentProvider 中的数据
     - 外部进程通过 ContentResolver类 从而与ContentProvider类进行交互
  
  2. 具体使用
  ```
  public Uri insert(Uri uri, ContentValues values)　 
  ```
  外部进程向 ContentProvider 中添加数据
  ```
  public int delete(Uri uri, String selection, String[] selectionArgs)
  ```
  外部进程 删除 ContentProvider 中的数据
  
  ```
  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)
  ```
  外部进程更新 ContentProvider 中的数据
  
  ```
  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
  ```
  外部应用 获取 ContentProvider 中的数据
  
  3. 实例说明
  使用ContentResolver前，需要先获取ContentResolver
  可通过在所有继承Context的类中 通过调用getContentResolver()来获得ContentResolver
  ```
  ContentResolver resolver =  getContentResolver();  
  ```
  设置ContentProvider的URI
  ```
  Uri uri = Uri.parse("content://cn.scu.myprovider/user"); 
  ```
  根据URI 操作 ContentProvider中的数据
  ```
  Cursor cursor = resolver.query(uri, null, null, null, "userid desc"); 
  ```
  此处是获取ContentProvider中 user表的所有记录 
  
  ### 6.5 辅助工具类
  1. ContentUris类
  - 核心方法有两个：withAppendedId（） &parseId（）
  withAppendedId（）作用：向URI追加一个id
  ```
  Uri uri = Uri.parse("content://cn.scu.myprovider/user") 
  Uri resultUri = ContentUris.withAppendedId(uri, 7);  
  ```
  最终生成后的Uri为：content://cn.scu.myprovider/user/7
  
  parseId（）作用：从URL中获取ID
  ```
  Uri uri = Uri.parse("content://cn.scu.myprovider/user/7") 
  long personid = ContentUris.parseId(uri); 
  ```
  获取的结果为:7
  
  2. UriMatcher类
  - 在ContentProvider 中注册URI
  - 根据 URI 匹配 ContentProvider 中对应的数据表
  ```
  // 步骤1：初始化UriMatcher对象
      UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); 
      //常量UriMatcher.NO_MATCH  = 不匹配任何路径的返回码
      // 即初始化时不匹配任何东西
  
  // 步骤2：在ContentProvider 中注册URI（addURI（））
      int URI_CODE_a = 1；
      int URI_CODE_b = 2；
      matcher.addURI("cn.scu.myprovider", "user1", URI_CODE_a); 
      matcher.addURI("cn.scu.myprovider", "user2", URI_CODE_b); 
      // 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a
      // 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b
  
  // 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））
  
  @Override   
      public String getType(Uri uri) {   
        Uri uri = Uri.parse(" content://cn.scu.myprovider/user1");   
  
        switch(matcher.match(uri)){   
       // 根据URI匹配的返回码是URI_CODE_a
       // 即matcher.match(uri) == URI_CODE_a
        case URI_CODE_a:   
          return tableNameUser1;   
          // 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser1的表
        case URI_CODE_b:   
          return tableNameUser2;
          // 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameUser2的表
      }   
  }
  ```
  3. ContentObserver类
  - 当ContentProvider 中的数据发生变化（增、删 & 改）时，就会触发该 ContentObserver类
  ```
  // 步骤1：注册内容观察者ContentObserver
      getContentResolver().registerContentObserver（uri）；
      // 通过ContentResolver类进行注册，并指定需要观察的URI
  
  // 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）
      public class UserContentProvider extends ContentProvider { 
        public Uri insert(Uri uri, ContentValues values) { 
        db.insert("user", "userid", values); 
        getContext().getContentResolver().notifyChange(uri, null); 
        // 通知访问者
     } 
  }
  
  // 步骤3：解除观察者
   getContentResolver().unregisterContentObserver（uri）；
      // 同样需要通过ContentResolver类进行解除
  ```
  
  ### 6.6 进程内通信Demo
  
  
  ### 6.7 进程间通信Demo
  
  
  
  ### 文献
  [Android：关于ContentProvider的知识都在这里了！ - 简书](https://www.jianshu.com/p/ea8bc4aaf057)
  [Android 的这 13 道 ContentProvider 面试题，你都会了吗？ - 知乎](https://zhuanlan.zhihu.com/p/113619338)
  
  
  ## 7、 Android - 系统启动过程
  
  ### 7.1  启动流程图
  ![完整启动过程.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\2dc66a3e.png)
  
  ### 7.2 启动步骤
  Step1  Bootlloader —系统启动加载器
  
  Step2  Bootloader —会读取Boot ROM找到操作系统并将 Kernel(Linux内核) 加载到RAM中。
  
  Step3  当Kernel(Linux内核)启动后会初始化各种软硬环境，加载驱动程序，挂载根文件系统，最后Kernel会调用init.cpp中main()方法。——init是Linux系统中用户空间的第一个进程(pid=1).
  
  Step4  init.main() 首先初始化Kernel log ,创建一块共享的内存空间，加载/default.prop文件，解析init.rc文件。
  
  Step5  init.rc 脚本中配置了一些重要服务，init进程通过创建子进程来启动这些服务。（注意:在这个阶段可以看到 Android log 画面）
  
  Step6  Zygote进程用来孵化所有的Android 应用程序, 该进程的启动也标志着Framework框架初始化启动的开始。Zygote进程启动后，会执行App_main.cpp. 文件的main()方法。开始启动java 虚拟机. 
  
  Step7  在App_main.cpp中启动ZygoteInit.main()方法，启动预加载和资源，并启动system_server.
  
  Step8  system_server进程启动后将开启 引导服务，核心服务，其它服务。
  
  Step9  在Zygote中启动的服务都会注册到ServiceManager中。
  
  Step10 ActivityManagerService 服务启动完成后，会进入 ActivityManagerService.systemReady()，然后启动 SystemUI，WebViewFactory，Watchdog，最后启动桌面 Launcher App。
  
  ### 7.3 init.rc 进程中启动的服务
  1. service_manager： Binder IPC 通信过程中的守护进程，本身也是一个 Binder 服务。ServiceManager 进程主要是启动 Binder，提供服务的查询和注册。
  2. mountd：设备安装 Daemon，负责设备安装及状态通知
  3. debuggerd：启动 debug system，处理调试进程的请求
  4. rild：启动 radio interface layer daemon 服务，处理电话相关的事件和请求
  5. media_server：MediaServer 进程主要是启动 AudioFlinger 音频服务，CameraService 相机服务。负责处理音频解析播放，相机相关的处理。
  6. surface_flinger：负责图像绘制，是应用 UI 的核心，其功能是合成所有 Surface 并渲染到显示设备。SurfaceFlinger 进程主要是启动 FrameBuffer，初始化显示系统。
  7. zygote：进程孵化器，启动 Android Java VMRuntime 和启动 systemserver，负责 Android 应用进程的孵化工作 （重要）
  
  ### 7.4 system_server进程启动的服务
  1. 引导服务：
  ActivityManagerService，
  PowerManagerService，
  LightsService，
  DisplayManagerService，
  PackageManagerService，
  UserManagerService。
  
  2. 核心服务：
  BatteryService
  UsageStatsService
  
  3. 其它服务：
  InputManagerService，
  WindowManagerService
  
  ### 7.5 参考文献
  [Android-ReadTheFuckingSourceCode/Android-系统启动过程.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/Android-系统启动过程.md)
  
  
  ## 8、Android - Activity 启动过程
  
  ### 8.1 启动流程图
  ![Activity启动过程.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\6fab0b8b.png)
  
  ### 8.2 启动步骤
  Activity进程已存在的情况
  Step 1 : 点击App应用图标，通过Instrumention.execStartActivity方法获取ActivityManagerProxy对象.
  Step 2 : 调用ActivityManagerProxy对象调用startActivity()方法，通过Binder方式 发送START_ACTIVITY_TRANSACTION
  Step 3 : 在system_server 进程中的ActivityManagerService 收到 START_ACTIVITY_TRANSACTION 命令后进行处理，调用 startActivity() 方法。
  Step 4 : 在ActivityManagerService 服务中，调用ActivityStackSupervisor.startActivityLocked()方法获取调用者的进程信息。
  Step 5 : 通过ActivityStackSupervisor.startSpecificActivityLocked() 来判断该进程是否存在，存在的话直接设置Activity状态为 resumed，不存在则会创建新进程。
  
  Activity进程不已存在的情况
  Step1 : 如果应用没有启动过，会fork一个新进程。在创建进程时会对ActivityManagerService的ProcessRecord(其实是包名)进行判断。如果已经存在就不会新建进程。
  Step2 : 如果ProcessRecord不存在。调用ActivityManagerService.startProcessLocked()方法创建新进程。
  Step3 : 进入App进程后将ActivityThread类加载到新进程中，其中调用ActivityManagerProxy.attachApplication()方法，发送 ATTACH_APPLICATION_TRANSACTION 命令。
  (这个过程的目的是，将本地的 ApplicationThread 传递到 ActivityMangerService。然后 ActivityMangerService 就可以通过 ApplicationThread 的代理 ApplicationThreadProxy 来调用应用程序 ApplicationThread.bindApplication，通知应用程序的 ApplicationThread 已和 ActivityMangerService 绑定，可以不借助其他进程帮助直接通信了。)
  Step4 : 在 system_server 进程中的服务端 ActivityManagerService 收到 ATTACH_APPLICATION_TRANSACTION 命令后进行处理，调用 attachApplication()方法。将该进程设置为前台进程 PROCESS_STATE_TOP
  Step5 : ApplicationThreadProxy.scheduleLaunchActivity()发送SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION 命令来启动App。
  Step6 : ApplicationThreadProxy.bindApplication() 发送 BIND_APPLICATION_TRANSACTION 命令来创建 Application
  
  ### 8.3 参考文献
  [Android-ReadTheFuckingSourceCode/Android-Activity启动过程.md at master · jeanboydev/Android-ReadTheFuckingSourceCode · GitHub](https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode/blob/master/article/android/framework/Android-Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.md)
  
  
  ## 9、IPC(跨进程通信)
  
  ### 9.1 Android中实现IPC通信的8种方式
  1. 使用Bundle ----> 用于android四大组件间的进程间通信
  2. 使用SharePreference ---->用于单线程读写
  3. 使用Messenger ---->用于可存放在message中的数据的传递
  4. 使用AIDL ---->主要用于调用远程服务的方法的情况 还可以注册接口
  5. ContentProvider方式----> 实现对另一个应用进程开放provider数据的查询
  6. Socket方法----> 这种方式也可以实现 但是不常用
  7. BroadCase ----> 不关心何时发来广播，大多也不关心是谁发送的，只管接收特定类型的消息(应用场景比较单一)
  
  ### 9.2 AIDL 知识
  
  #### 9.2.1 序列化与反序列化的知识
  序列化
  - 将对象或数据结构转化为字节序列的过程
  反序列化
  - 将字节序列恢复为原始对象的过程
  
  #### 9.2.2 Serializable与Parcelable的区别
  
  - Serializable接口是在java中的序列化抽象类，而Parcelable接口则是android中特有的序列化接口
  - Serializable使用IO读写存储在硬盘上。序列化过程使用了反射技术，并且期间产生大量临时对象,从而引起频繁的GC。
  - Parcelable是直接在内存中读写，由于内存的读写速度肯定优于硬盘读写速度，所以Parcelable序列化方式性能上要优于Serializable方式很多。
  
  [序列化与反序列化之Parcelable和Serializable浅析_zejian的博客-CSDN博客_parcelable和serializable](https://blog.csdn.net/javazejian/article/details/52665164)
  #### 9.2.3 Parcelable 实现案例
  ```
  package com.zejian.ipctest;
  import android.os.Parcel;
  import android.os.Parcelable;
  
  public class NewClient implements Parcelable {
  
      public int id;
      public String name;
      public User user;
  
      /**
       * 当前对象的内容描述,一般返回0即可
       */
      @Override
      public int describeContents() {
          return 0;
      }
  
      /**
       * 将当前对象写入序列化结构中
       */
      @Override
      public void writeToParcel(Parcel dest, int flags) {
          dest.writeInt(this.id);
          dest.writeString(this.name);
          dest.writeParcelable(this.user,0);
      }
  
      public NewClient() {
      }
  
      /**
       * 从序列化后对象中创建原始对象
       */
      protected NewClient(Parcel in) {
          this.id = in.readInt();
          this.name = in.readString();
         //User是另一个序列化对象，此方法序列需要传递当前线程的上下文类加载器，否则会报无法找到类的错误
         this.user=in.readParcelable(Thread.currentThread().getContextClassLoader());
      }
  
      /**
       * public static final一个都不能少，内部对象CREATOR的名称也不能改变，必须全部大写。
       * 重写接口中的两个方法：
       * createFromParcel(Parcel in) 实现从Parcel容器中读取传递数据值,封装成Parcelable对象返回逻辑层，
       * newArray(int size) 创建一个类型为T，长度为size的数组，供外部类反序列化本类数组使用。
       */
      public static final Parcelable.Creator<NewClient> CREATOR = new Parcelable.Creator<NewClient>() {
          /**
           * 从序列化后的对象中创建原始对象
           */
          @Override
          public NewClient createFromParcel(Parcel source) {
              return new NewClient(source);
          }
  
          /**
           * 创建指定长度的原始对象数组
           * @param size
           * @return
           */
          @Override
          public NewClient[] newArray(int size) {
              return new NewClient[size];
          }
      };
  }
  ```
  从代码可知，通过writeToParcel将我们的对象映射成Parcel对象，再通过createFromParcel将Parcel对象映射成我们的对象。
  
  **Parcel是一个容器，它主要用于存储序列化数据，然后可以通过Binder在进程间传递这些数据**
  
  #### 9.2.4 AIDL的概述
  在Android系统中，每个进程都运行在一块独立的内存中，在其中完成自己的各项活动，与其他进程都分隔开来。可是有时候我们又有应用间进行互动的需求，比较传递数据或者任务委托等，AIDL就是为了满足这种需求而诞生的。
  **通过AIDL，可以在一个进程中获取另一个进程的数据和调用其暴露出来的方法，从而满足进程间通信的需求**。
  
  #### 9.2.5 AIDL的语法
  支持的数据类型:
  - 八种基本数据类型：byte、char、short、int、long、float、double、boolean
  - String，CharSequence
  - 实现了Parcelable接口的数据类型
  - List 类型。List承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象
  - Map类型。Map承载的数据必须是AIDL支持的类型，或者是其它声明的AIDL对象
  
  #### 9.2.6 AIDL文件构成
  1. 一类用来声明实现了Parcelable接口的数据类型，以供其他AIDL文件使用那些非默认支持的数据类型。
  2. 一类是用来定义接口方法，声明要暴露哪些接口给客户端调用，定向Tag就是用来标注这些方法的参数值。
  
  
  #### 9.2.7 AIDL定向Tag
  定向Tag表示在跨进程通信中数据的流向，用于标注方法的参数值，分为 in、out、inout 三种。
  in:表示数据只能由客户端流向服务端。
  out:表示数据只能由服务端流向客户端。
  inout:表示数据可在服务端与客户端之间双向流通。
  **注意**
  如果AIDL方法接口的参数值类型是：基本数据类型、String、CharSequence或者其他AIDL文件定义的方法接口，那么这些参数值的定向 Tag 默认是且只能是 in，所以除了这些类型外，其他参数值都需要明确标注使用哪种定向Tag。
  
  #### 9.2.8 使用AIDL的Demo
  [Android AIDL 使用 - 妖久 - 博客园](https://www.cnblogs.com/tangZH/p/10775848.html)
  
  #### 9.2.9 AIDL的工作原理
  [Android：学习AIDL，这一篇文章就够了(下) - 简书](https://www.jianshu.com/p/0cca211df63c)
  **在客户端与服务端通信的过程中，真正协助发挥作用的是通过AIDL编译出来的.java文件。AIDL文件的目的就是为了生成.java文件**。
  1. 客户端分析
  Proxy类是.java中的核心。其中transact是客户端和服务端通信的核心方法。调用这个方法之后，客户端将会挂起当前线程，等候服务端执行完相关任务后通知并接收返回的 reply 数据流。
    1) transact() 方法的第一个参数是一个方法 ID ，这个是客户端与服务端约定好的给方法的编码，彼此一一对应。在AIDL文件转化为 .java 文件的时候，系统将会自动给AIDL文件里面的每一个方法自动分配一个方法 ID。
    2) transact() 方法的第四个参数是一个 int 值，它的作用是设置进行 IPC 的模式，为 0 表示数据可以双向流通，即 reply 流可以正常的携带数据回来，如果为 1 的话那么数据将只能单向流通，从服务端回来的 reply 流将不携带任何数据。
  Proxy类的工作流程：
  - 1，生成 data 和 reply 数据流，并向 data 中存入客户端的数据。
  - 2，通过 transact() 方法将它们传递给服务端，并请求服务端调用指定方法。
  - 3，接收 reply 数据流，并从中取出服务端传回来的数据
  
  2. 服务端分析
  同样在.java文件中一个叫ontransact的方法是用来接收来客户端回传来的信息。
  服务端的工作流程:
  - 1，获取客户端传过来的数据，根据方法 ID 执行相应操作。
  - 2，将传过来的数据取出来，调用本地写好的对应方法。
  - 3，将需要回传的数据写入 reply 流，传回客户端。
  
  3. 客户端与服务端使用AIDL进行 IPC 的工作流程
  ![2491431-425990373820aaf6.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\4a0f8f69.png)
  
  
  ## 10、性能优化
  ### 10.1 内存优化
  #### 10.1.1 LeakCanary工具
  LeakCanary是Square公司基于MAT开发的一款监控Android内存泄漏的开源框架。其工作的原理是： 监测机制利用了Java的WeakReference和ReferenceQueue，通过将Activity包装到WeakReference中，被WeakReference包装过的Activity对象如果被回收，该WeakReference引用会被放到ReferenceQueue中，通过监测ReferenceQueue里面的内容就能检查到Activity是否能够被回收（在ReferenceQueue中说明可以被回收，不存在泄漏；否则，可能存在泄漏，LeakCanary是执行一遍GC，若还未在ReferenceQueue中，就会认定为泄漏）。
  
  如果Activity被认定为泄露了，就抓取内存dump文件(Debug.dumpHprofData)；之后通过HeapAnalyzerService.runAnalysis进行分析内存文件分析；接着通过HeapAnalyzer (checkForLeak—findLeakingReference---findLeakTrace)来进行内存泄漏分析。最后通过DisplayLeakService进行内存泄漏的展示。
  #### 10.1.2 Android Lint工具
  Android Lint Tool 是Android Sutido种集成的一个Android代码提示工具，它可以给你布局、代码提供非常强大的帮助。硬编码会提示以级别警告，例如：在布局文件中写了三层冗余的LinearLayout布局、直接在TextView中写要显示的文字、字体大小使用dp而不是sp为单位，就会在编辑器右边看到提示。
  
  ### 10.2 APK瘦身
  #### 10.2.1 安装包的组成
  assets文件夹 存放一些配置文件，资源文件，assets不会自动生成对应的ID,而是通过AssetManager类的接口获取
  
  res res是resource的缩写，这个目录存放资源文件，会自欧东生成对应的ID并映射到.R文件中，访问直接使用资源ID。
  
  META-INF. 保存应用的签名信息，签名信息可以炎症APK文件的完整性.
  
  AndroidManifes.xml, 这个文件用来描述Android应用的配置信息，一些组件的注册信息，可使用权限。
  
  classex.dex Dalvik字节码程序，让Dalvik虚拟机可执行，一般情况下，Android应用在打包时通过AndroidSDK中的dx工具将java字节码转换为Dalvik字节码
  
  resources.arsc 记录着资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。
  
  #### 10.2.2 减少安装包大小
  
  代码混淆：使用IDE 自带的 proGuard 代码混淆器工具 ，它包括压缩、优化、混淆等功能。 
  资源优化：使用 Android Lint 删除冗余资源，资源文件最少化等。 
  图片优化: 利用 PNG优化工具 对图片做压缩处理。推荐目前最先进的压缩工具Googlek开源库zopfli。如果应用在0版本以上，推荐使用 WebP图片格式。 
  
  ### 10.3 冷启动与热启动
  
  **冷启动** 
  在启动应用时，系统中没有该应用的进程，这时系统会创建一个新的进程分配给该应用；
  
  **热启动**
  在启动应用时，系统中已有该应用的进程（例：按back键、home键，应用虽然会退出，但是该应用的进程还是保留在后台）；
  
  **区别 冷启动**
  冷启动:系统没有该应用的进程，需要创建一个新的进程分配给应用，所以会先创建和初始化Application类，再创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。 
  热启动:从已有的进程中来启动，不会创建和初始化Application类，直接创建和初始化MainActivity类（包括一系列的测量、布局、绘制），最后显示在界面上。
  
  **冷启动流程** 
  Zygote进程中fork创建出一个新的进程； 创建和初始化Application类、创建MainActivity； inflate布局、当onCreate/onStart/onResume方法都走完； contentView的measure/layout/draw显示在界面上。
  
  **冷启动优化** 
  减少在Application和第一个Activity的onCreate()方法的工作量； 不要让Application参与业务的操作； 不要在Application进行耗时操作； 不要以静态变量的方式在Application中保存数据； 减少布局的复杂性和深度；
  
  
   
  ## 、Activity,PhoneWindow和DecorView 的关系
  ![16bff4353cd98658.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\37ed51f2.png)
  
  ###  DecorView 浅析
  ![16bff4356573308b.png](:storage\\40a9daea-a5ef-47a8-a24e-130b8a1640da\\03572325.png)
  如图所示，DecorView为整个Window界面的最顶层View，它只有一个子元素LinearLayout。代表整个Window界面，包含通知栏、标题栏、内容显示栏三块区域。其中LinearLayout中有两个FrameLayout子元素。
  
  ### DecorView 的作用
  DecorVuew是顶级View,本质是一个FrameLayout它包含两部分，标题栏和内容栏，都是FrameLayout,内容栏id是content,也就是Activity中设置setContentView的部分,最终将布局添加到id为content的FrameLayout中。获取content:
  ViewGroup content=findViewByld(android.id.content)获取设置的View :getChildAt(0);
  
  使用总结
  
  每个Activity都包含一个Window对象，Window对象通常是由PhoneWindow实现的。
  PhoneWindow:将DecorView设置为整个应用窗口的根View,是Window的实现类。它是Android中的基本的窗口系统，每个Activity均会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。
  DecorView:是顶层视图，将要呈现的具体内容呈现在PhoneWindow上，DecorView是当前Activity所有View的祖先，它并不会向用户呈现任何东西。
  
  
  ## 参考文献
  
  [jeanboy_jeanboydev_CSDN博客-Android进阶,Java基础,Android进阶领域博主](https://blog.csdn.net/freekiteyu/article/list/1)
  [成功入职字节跳动的小姐姐告诉你，Android面试吃透这一篇就没有拿不到的offer！ - 知乎](https://zhuanlan.zhihu.com/p/136796040)
  
  
'''
linesHighlighted: [
  1791
  1612
  1192
  1225
  2488
  2415
]
isStarred: false
isTrashed: false
