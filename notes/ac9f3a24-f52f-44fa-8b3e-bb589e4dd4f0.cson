createdAt: "2023-01-08T15:07:09.915Z"
updatedAt: "2023-03-01T16:27:00.734Z"
type: "MARKDOWN_NOTE"
folder: "c3bf24344ddc9bd2af22"
title: "ActivityManagerService"
tags: []
content: '''
  # ActivityManagerService
  
  ## 1.什么是ActivityManagerService
  ActivityManagerService承担了Android四大组件的启动、切换、调度以及进程的管理工作，掌握了所有应用的创建、启动、管理，是Android中最核心的服务。
  ![f28b35a4.png](:storage\\ac9f3a24-f52f-44fa-8b3e-bb589e4dd4f0\\f28b35a4.png)
  
  ## 2.AMS关联类
  - ActivityManager：主要对运行中的Activity进行管理。管理工作实际并不是由ActivityManager来处理的，而是交由AMS来处理的。
  - ActivityManagerNative ：简称AMN。是一个抽象类，其功能由他的子类AMS处理。其getDefault方法可得到ActivityManagerProxy（简称AMP）。ActivityManager通过AMP与AMN通信。
  - ActivityManagerProxy：AMN的内部类、AMS的代理类。
  - ActivityManagerService：系统服务，运行在SystemSever进程。AMS作为系统服务，很多API是不会暴露给ActivityManager的。
  
  ![1a871cc1.png](:storage\\ac9f3a24-f52f-44fa-8b3e-bb589e4dd4f0\\1a871cc1.png)
  
  1. AMS由ActivityManagerNative（以后简称AMN）类派生，而AMN由Binder派生，实现了IActivityManager接口。
  2. AMP是AMN的内部类，它们都实现了IActivityManager接口，这样它们就可以实现代理模式。具体来讲是远程代理。
  3. AMP和AMN是运行在两个进程中的，AMP是Client端，AMN则是Server端，而Server端中具体的功能都是由AMN的子类AMS来实现的，因此，AMP就是AMS在Client端的代理类。
  4. AMN又实现了Binder类，这样AMP和AMS就可以通过Binder来进行进程间通信。
  5. 客户端使用ActivityManager类。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。
  
  ## 3.AMS启动过程
  AMS的启动是在SystemServer进程中启动的。即AMS运行在SystemServer进程。
  在SystemServer中需要启动的服务有三种：
  - 引导服务(BootstrapServices),主要开启了ActivityManagerService、PowerManagerService、PackageManagerService等服
  - 核心服务(CoreServices),主要开启了DropBoxManagerService、BatteryService、UsageStatsService和WebViewUpdateService等服务
  - 其他服务(OtherServices),主要启动了CameraService、AlarmManagerService、VrManagerService等服务。
  ```
  public final class SystemServer {
      //zygote的主入口
      public static void main(String[] args) {
          new SystemServer().run();
      }
      public SystemServer() {
          // Check for factory test mode.
          mFactoryTestMode = FactoryTest.getMode();
      }
      private void run() {
          ......
          //加载本地系统服务库，并进行初始化
          System.loadLibrary("android_servers");
          nativeInit();
          // 1、创建系统上下文
          createSystemContext();
          //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class<T>)，这个方法通过反射来启动对应的服务
          mSystemServiceManager = new SystemServiceManager(mSystemContext);
          //开启服务
          try {
              startBootstrapServices();
              startCoreServices();
              startOtherServices();
          } catch (Throwable ex) {
              Slog.e("System", "******************************************");
              Slog.e("System", "************ Failure starting system services", ex);
              throw ex;
          }
          ......
      }
      /*初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。
      *调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，
      *并调用了Application.onCreate()。
      */
      private void createSystemContext() {
          ActivityThread activityThread = ActivityThread.systemMain();
          mSystemContext = activityThread.getSystemContext();
          mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);
      }
      //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。
      private void startBootstrapServices() {
          ......
          //初始化ActivityManagerService
          mActivityManagerService = mSystemServiceManager.startService(
                  ActivityManagerService.Lifecycle.class).getService();
          mActivityManagerService.setSystemServiceManager(mSystemServiceManager);
          //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化
          mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);
          // 初始化DisplayManagerService
          mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);
          // 2、systemServer进程加载到AMS中，并被它管理
          mActivityManagerService.setSystemProcess();
          ......
      }
      private void startOtherServices() {
          // 3、将SettingProvider放到SystemServer进程中来运行
          mActivityManagerService.installSystemProviders();
          // 4、AMS是系统的核心服务，只有它准备好了，才能调用其他服务的SystemReady
          mActivityManagerService.systemReady(new Runnable() {
              @Override
              public void run() {
                  try {
                      startSystemUi(context); // 启动systemUi，如此，状态栏就准备好了
                  } catch (Throwable e) {
                      reportWtf("starting System UI", e);
                  }
                  Watchdog.getInstance().start(); // 启动watchdog
              }
          });
      }
  }
  
  
  public static ActivityThread systemMain() {
      if (!ActivityManager.isHighEndGfx()) {
        HardwareRenderer.disable(true); // 禁止硬件加速
      } else {
        HardwareRenderer.enableForegroundTrimming();
      }
      // 创建一个ActivityThread对象
      ActivityThread thread = new ActivityThread();
      thread.attach(true); // 调用attach函数，参数为true
      return thread;
  }
  
  private void attach(boolean system) {
          sCurrentActivityThread = this;
          mSystemThread = system; // 判断是否为系统进程
          if (!system) { // 应用进程的处理流程
              ......
          } else { //系统进程的处理流程，该情况只在systemServer中处理
              // 设置DDMS时看到的systemserver进程名
              android.ddm.DdmHandleAppName.setAppName("system_process",
                      UserHandle.myUserId());
              try {
                  // Instrumentation类出现了
                  mInstrumentation = new Instrumentation();
                  // 初始化context，注意参数getSystemContext().mPackageInfo
                  ContextImpl context = ContextImpl.createAppContext(
                          this, getSystemContext().mPackageInfo);
                  //makeApplication 方法中创建Application对象，一个进程支持多个Application
                  // mInitialApplication用于保存Application对象
                  mInitialApplication = context.mPackageInfo.makeApplication(true, null);
                  mInitialApplication.onCreate(); //调用Application的Oncreate()
              } catch (Exception e) {
                  throw new RuntimeException(
                          "Unable to instantiate Application():" + e.toString(), e);
              }
          }
          // 注册Configuration变化时的回调通知
          ViewRootImpl.addConfigCallback(new ComponentCallbacks2() {
              @Override
              public void onConfigurationChanged(Configuration newConfig) {
              }
              @Override
              public void onLowMemory() {}
              @Override
              public void onTrimMemory(int level) {}
          });
      }
  ```
  ### 3.1 Attach中出现的重要成员类
  1. Instrumentrain
  Instrumentrain 是一个工具类，当他被启用时，系统先创建他，再通过他来创建其他组件。另外，系统和组件之间的交互也是通过Instrumentrain来传递，这样，Instrumentrain就能检测系统和这些组件的交互情况，在实际使用中，我们可以创建Instrumentrain的派生类来进行相应的处理。
  
  2. Application类
  - Application类保存了一个全局的application状态，Application由AndroidManifest.xml中的标签声明；
  - 在实际使用中需定义Application派生类；
  - Application是Android中的一个概念，可以理解为一种容器，其内部包含四大组件，一个进程可以运行多个Application
  
  3. Context类
  Context是一个接口，通过他可以获取并操作Application对应的资源、类，甚至包含于Application中的四大组件
  ![1111.png](:storage\\ac9f3a24-f52f-44fa-8b3e-bb589e4dd4f0\\aa1ee246.png)
  
  ### 3.2 zygote->SystemServer->AMS和ActivityThread->ActivityManager解释
  1. App(ActivityThread进程)和AMS(SystemServer进程)还有zygote进程属于三个独立的进程。
  2. App与AMS通过Binder进行IPC通信，AMS与zygote通过Socket进行IPC通信。
  3. AMS负责所有Activity的生命周期，若想打开一个App的话，需要AMS去通知zygote进程。
  4. 任何一个Activity的启动都是由AMS和应用程序进程相互配合来完成。AMS服务统一调用系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。
  
  ## 4 Activity 启动流程
  
  ![a06cf9cf.png](:storage\\ac9f3a24-f52f-44fa-8b3e-bb589e4dd4f0\\a06cf9cf.png)
  
  ### 4.1 启动 MainActivity 五个步骤
  一. Launcher通过AMP,以Binder进程间通信机制,通知ActivityManagerService,它要启动一个Activity。（1~11）
  
  二. ActivityManagerService 调用startActivity,经过ActivityStack一系列调用处理，最后通过Binder进程间通信机制通知Launcher让其它Activity进入Paused状态。（12~16）
  
  三. Launcher通过AMP,以Binder进程间通信机制,通知ActivityManagerService，它已经准备就绪进入Paused状态，于是ActivityManagerService就向zygote发送命令用来fork一个子进程，用来启动一个ActivityThread实例，即将要启动的Activity在这个ActivityThread实例中运行.（17~24）
  
  四. ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给ActivityManagerService,以便ActivityManagerService能够通过这个Binder对象与ActivityThread通信，其通信内容分为三个阶段。（25~27）
  
  五. ActivityManagerService通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。(28~35)
  
  ## 5 BroadCast 广播机制分析
  
  ### 5.1 概述
  接收方式分为两类：
  - 静态广播接收者：通过AndroidManifest.xml的标签来申明的BroadcastReceiver。
  - 动态广播接收者：通过AMS.registerReceiver()方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过unregisterReceiver()取消注册。
  
  发送方式可分为三类：
  - 普通广播：通过Context.sendBroadcast()发送，可并行处理
  - 有序广播：通过Context.sendOrderedBroadcast()发送，串行处理
  - Sticky广播：通过Context.sendStickyBroadcast()发送
  
  注册广播：
  广播注册registerReceiver():默认将当前进程的主线程设置为scheuler. 再向AMS注册该广播相应信息, 根据类型选择加入mParallelBroadcasts或mOrderedBroadcasts队列.
  
  广播发送processNextBroadcast():根据不同情况调用不同的处理过程:
  - 如果是动态广播接收者，则调用deliverToRegisteredReceiverLocked处理(并行处理);
  - 如果是静态广播接收者，且对应进程已经创建，则调用processCurBroadcastLocked处理(串行处理);
  - 如果是静态广播接收者，且对应进程尚未创建，则调用startProcessLocked创建进程()。
  
  ### 5.2 注册广播
  广播注册，对于应用开发来说，往往是在Activity/Service中调用registerReceiver()方法，而Activity或Service都间接继承于Context抽象类，真正干活是交给ContextImpl类。另外调用getOuterContext()可获取最外层的调用者Activity或Service。
  ![注册广播.png](:storage\\ac9f3a24-f52f-44fa-8b3e-bb589e4dd4f0\\ba26dd41.png)
  
  - 1:ContextImpI中广播注册接口
  - 1.1:获取主线程对象
  - 1.2:根据广播接收者，初始化一个广播分发者对象
  - 1.2.1:对广播接收者和分发者以ArrayMap的形式管理，同时返回新创建的广播分发者对象
  - 1.2.2:初始化一个ArrayMap
  - 1.2.3:将广播接收者和分发者放入ArrayMap中。
  - 1.3:通过AMP对象进一步调用注册接口 
  - 1.3.1: 获取AMP对象(ActivityManagerProxy,AMN中的内部类,实现代理模式)。
  - 1.3.1.1: 调用AMS中registerReciver的具体实现(AMS是AMN的具体实现)。
  - 1.3.1.1.1: 获取当前App的进程信息。
  - 1.3.1.1.2: 获取广播的action。
  - 1.3.1.1.3: 查询用户的Sticky广播。
  - 1.3.1.1.3.1: 根据action获取对应Sticky广播的Intent。
  - 1.3.1.1.3.1.1: 初始化Sticky,Intent列表。
  - 1.3.1.1.3.1.2: 将获取到的Sticky Intent，添加到列表中。
  - 1.3.1.1.4: 获取已注册广播接收者队列
  - 1.3.1.1.5: 若没有获取到，则新创建队列
  - 1.3.1.1.6: 将新的广播接收者加入到队列中
  - 1.3.1.1.7: 创建BroadcastFilter对象，并添加到接收者队列
  - 1.3.1.1.8: 将BroadcastFilter，添加到接收者队列
  - 1.3.1.1.9: 新BroadcastFilter，添加到ReceiverResolver队列
  - 1.3.1.1.10: 若存在sticky broadcast,根据intent返回前台或后台广播队列
  - 1.3.1.1.11: 创建新的BroadcastRecord
  - 1.3.1.1.12: 将该广播加入到并行广播队列
  - 1.3.1.1.13: 调度广播，发送BROADCAST_INTENT_MSG消息，触发处理下一个广播
  
  ### 5.2.3 广播发送和处理
  ![99d6d204.png](:storage\\ac9f3a24-f52f-44fa-8b3e-bb589e4dd4f0\\99d6d204.png)
  
  #### 5.2.3.1 普通广播
  
  - 广播发送端所在进程: 步骤1~2;
  - system_server的binder线程: 步骤3~5;
  - system_server的ActivityManager线程: 步骤6~11;
  - 广播接收端所在进程的binder线程: 步骤12~13;
  - 广播接收端所在进程的主线程: 步骤14~15,以及23;
  - system_server的binder线程: 步骤24~25.
  #### 5.2.3.2 串行广播
  
  - 广播发送端所在进程: 步骤1~2;
  - system_server的binder线程: 步骤3~5;
  - system_server的ActivityManager线程: 步骤6~11;
  - 广播接收端所在进程的binder线程: 步骤12~13;
  - 广播接收端所在进程的主线程: 步骤14~15,以及23;
  - system_server的binder线程: 步骤24~25.
  
  #### 5.2.3.3 广播处理
  1. 当发送串行广播(ordered=true)的情况下：
  - 静态注册的广播接收者(receivers)，采用串行处理；
  - 动态注册的广播接收者(registeredReceivers)，采用串行处理；
  2. 当发送并行广播(ordered=false)的情况下：
  - 静态注册的广播接收者(receivers)，依然采用串行处理；
  - 动态注册的广播接收者(registeredReceivers)，采用并行处理；
  
  静态注册的receivers始终采用串行方式来处理（processNextBroadcast）； 动态注册的registeredReceivers处理方式是串行还是并行方式, 取决于广播的发送方式(processNextBroadcast)。
  
  ## 6 startService启动过程
  
  ## 文献
  [Android-MS/ams.md at master · xiangjiana/Android-MS · GitHub](https://github.com/xiangjiana/Android-MS/blob/master/android/ams.md)
  [安卓的ActivityManagerService_dev晴天的博客-CSDN博客_activitymanagerservice](https://blog.csdn.net/qq_38350635/article/details/114785334)
  [Android 8.0 AMS分析的第一条线：SystemServer中的AMS的调用轨迹_yaoming168的博客-CSDN博客_systemserver进程和ams的关系](https://blog.csdn.net/yaoming168/article/details/51991570)
  [Android Activity的启动流程分析：以Launcher启动一个Activity为例，分析应用进程的创建、Activity的启动，以及他们和AMS之间的交互_yaoming168的博客-CSDN博客](https://blog.csdn.net/yaoming168/article/details/52402963)
  [Android Broadcast广播机制分析 - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2016/06/04/broadcast-receiver/)
  [startService启动过程分析 - Gityuan博客 \\| 袁辉辉的技术博客](http://gityuan.com/2016/03/06/start-service/)
  https://www.jianshu.com/p/52276d5a979c
  
  
'''
linesHighlighted: []
isStarred: false
isTrashed: false
