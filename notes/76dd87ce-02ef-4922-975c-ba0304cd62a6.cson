createdAt: "2022-10-24T05:28:37.339Z"
updatedAt: "2022-10-28T09:08:01.469Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "React Natvie 学习"
tags: []
content: '''
  # React Natvie 学习
  [TOC]
  
  ## 第一章 React Native 背景知识
  
  ## 1.1 React Native 的诞生和发展
  
  1. 在React框架的基础上，React Native框架前台的javaScript代码通过调用封装的Android和iOS原生平台的代码来实现界面的渲染操作。
  
  2. React Native 使用JSX语法替代JavaScript语法，JSX是一种XML和JavaScript结合的扩展语法。
  
  3. React Native 框架底层使用的是JavaScriptCore引擎。
  
  ## 1.2 阿里巴巴 Weex 框架原理
  
  作为一个前端跨平台技术框架，Weex建立了一套源码转换以及原生端与JavaScript通信的机制。Weex框架表面上是一个前端客户端框架，但实际上它串联起了从本地开发、云端部署到资源分发的整个链路。
  
  具体来说，在开发阶段编写一个.we文件，然后使用Weex提供的weex-toolkit转换工具将.we文件转换为Js bundle,并将生成的JS bundle上传部署到云端，最后通过网络请求或预下发的方法加载至用户的移动客户端应用中。同时，集成了WeexSDK 的客户端接收到JS bundle文件后，调用本地的JavaScript引擎执行环境执行相应的JS bundle,并将执行过程中产生的各种命令发送到原生端进行界面渲染，整个工作流程如图：
  
  ![f358f12a.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\f358f12a.png)
  
  Weex框架中最核心的部分就是JavaScript Runtime.当需要执行渲染操作时：在iOS环境下，使用基于JavaScriptCore内核的iOS系统提供的JSContext;在Android 环境下使用基于JavaScriptCore内核的JavaScript引擎。
  
  当JS bundle从服务器下载完成之后，Weex的Android、iOS和HTML5 会运行相应的JavaScript引擎来执行JS bundle,同时向终端的渲染层发送渲染指令，并调用客户端的渲染引擎进行视图渲染、事件绑定和处理用户交互等操作。
  
  ## 1.3 谷歌Flutter
  
  Flutter 直接选择2D绘图引擎库Skia来渲染界面，而React Native和Weex使用JavaScript作为编程语言，使用平台自身引擎渲染界面。性能上Flutter无限接近原生。
  
  ![443d8135.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\443d8135.png)
  
  Flutter框架主要由Framework层和Engine层组成，基于Framework开发的App最终会运行在Engine层上。其中Engine是Flutter提供的独立虚拟机，正是由于它的存在，Flutter程序才能运行在不同的平台上，实现跨平台运行。
  
  Flutter使用Engine来绘制Widget(部件)，即Flutter显示的单元，并且Dart代码会通过AOT编译为平台的原生代码，进而与平台直接通信，不需要JavaScript引擎的桥接，也不需要原生平台的Dalvik虚拟机。
  
  ![294d8c0b.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\294d8c0b.png)
  Flutter的Widget采用现代响应式框架构建，而Widget是不可变的，仅支持一帧，并且每一帧上的内容不能直接更新，需要通过Widget的状态来间接更新。在Flutter中，无状态和有状态Widget的核心特性是相同的，Flutter会重新构建视图的每一帧，通过State对象，Flutter就可以跨帧存储状态数据并恢复它。
  
  ## 1.4 对比与分析
  ![ad6cc2be.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\ad6cc2be.png)
  
  React Native,Weex采用的技术方案大体相同，它们都使用JavaScript作为编程语言，然后通过中间层转换为原生组件，再利用原生渲染引擎执行渲染操作。Flutter直接使用Skia来渲染视图，并且Flutter Widget使用现代响应式框架来构建，和平台没有直接的关系。
  
  ## 第二章 React Native 入门基础
  
  1. React Native 开发工具WebStorm
  
  2. npm与npx的区别
  - npm 侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令。
  - npm是一个node package安装工具。
  - npx是npm的高版本产物，安装npm时候就会安装npx
  - npx 侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。 
  - npx的作用是先检查本地有没有安装某个package，如果没有去远程registry找，找到的话直接使用，不用下载到本地node-modules包里面，
  
  3. 初始化工程命令(需要翻墙)
  - npx react-native init XXXXX
  
  4. 工程目录文件夹
  ![ebe5bcb8.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\ebe5bcb8.png)
  
  ## 第三章 React Native 基础语法
  ### 3.1 JSX语法
  在React和React Native应用开发中，不一定非要使用JSX,也可以使用JavaScript进行开发。不过，因为JSX在定义上类似HTML这种树形结构，所以使用JSX可以极大地提高阅读和开发效率，减少代码维护的成本。在React开发中，React的核心机制之一就是可以在内存中创建虚拟DOM元素，进而减少对实际DOM的操作从而提升性能。
  ```
  export default class App extends Component<Props> {
    render() {
      return (
        <View style={styles.container}>
          <Text style={styles.welcome}>
            你好，React-native
          </Text>
          <Text style={styles.instructions}>
            To get started, edit App.js
          </Text>
          <Text style={styles.instructions}>
            {instructions}
          </Text>
        </View>
      );
    }
  }
  ```
  在上述代码中，组件的render()方法主要用于页面的渲染操作，它返回的是一个视图对象，之所以没有看到创建对象和设置属性的代码，是因为JSX提供的JSXTransformer可以帮助我们把代码中的XML-Like语法编译转换成JavaScript代码。借助JSX语法，开发者不仅可以用它来创建视图对象、样式和布局，还可以用它构建视图的树形结构。并且JSX语法的可读性也非常好，非常适合前端页面开发。
  ### 3.2 语法基础
  #### 3.2.1 let和const命令
  ```
  {
  let a = 10;
  var b = 1;
  }
  ```
  1. let 声明的变量只在let命令所在的代码块内有效。
  2. let 声明的变量不允许在相同作用域内重复声明。
  3. const 用于声明一个只读的常量，一旦声明，常量的值不能改变。
  4. const 声明的常量不可以重复声明。
  
  #### 3.2.2 类
  在ES6添加了对类的支持，引入了class关键字，新的class写法让对象的创建和继承更加直观，也让父类方法的调用、实例化、静态方法和构造函数等概念更加具象。
  ```
  class App extends Component{
    render(){
      return()
      <view></view>
    }
  }
  ```
  在ES6语法中，属性类型和默认属性则统一使用static修饰。
  ```
  class App extends React.Component{
    static defaultProps = {
      autoPlay : false
    };
    static propTypes = {
      autoPlay : React.PropTypes.bool.isRequired
    };
  }
  ```
'''
linesHighlighted: []
isStarred: false
isTrashed: false
