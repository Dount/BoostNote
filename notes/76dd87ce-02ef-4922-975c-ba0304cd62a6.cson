createdAt: "2022-10-24T05:28:37.339Z"
updatedAt: "2022-11-21T09:15:45.135Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "React Natvie 学习"
tags: []
content: '''
  # React Natvie 学习
  [TOC]
  
  ## 第一章 React Native 背景知识
  
  ## 1.1 React Native 的诞生和发展
  
  1. 在React框架的基础上，React Native框架前台的javaScript代码通过调用封装的Android和iOS原生平台的代码来实现界面的渲染操作。
  
  2. React Native 使用JSX语法替代JavaScript语法，JSX是一种XML和JavaScript结合的扩展语法。
  
  3. React Native 框架底层使用的是JavaScriptCore引擎。
  
  ## 1.2 阿里巴巴 Weex 框架原理
  
  作为一个前端跨平台技术框架，Weex建立了一套源码转换以及原生端与JavaScript通信的机制。Weex框架表面上是一个前端客户端框架，但实际上它串联起了从本地开发、云端部署到资源分发的整个链路。
  
  具体来说，在开发阶段编写一个.we文件，然后使用Weex提供的weex-toolkit转换工具将.we文件转换为Js bundle,并将生成的JS bundle上传部署到云端，最后通过网络请求或预下发的方法加载至用户的移动客户端应用中。同时，集成了WeexSDK 的客户端接收到JS bundle文件后，调用本地的JavaScript引擎执行环境执行相应的JS bundle,并将执行过程中产生的各种命令发送到原生端进行界面渲染，整个工作流程如图：
  
  ![f358f12a.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\f358f12a.png)
  
  Weex框架中最核心的部分就是JavaScript Runtime.当需要执行渲染操作时：在iOS环境下，使用基于JavaScriptCore内核的iOS系统提供的JSContext;在Android 环境下使用基于JavaScriptCore内核的JavaScript引擎。
  
  当JS bundle从服务器下载完成之后，Weex的Android、iOS和HTML5 会运行相应的JavaScript引擎来执行JS bundle,同时向终端的渲染层发送渲染指令，并调用客户端的渲染引擎进行视图渲染、事件绑定和处理用户交互等操作。
  
  ## 1.3 谷歌Flutter
  
  Flutter 直接选择2D绘图引擎库Skia来渲染界面，而React Native和Weex使用JavaScript作为编程语言，使用平台自身引擎渲染界面。性能上Flutter无限接近原生。
  
  ![443d8135.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\443d8135.png)
  
  Flutter框架主要由Framework层和Engine层组成，基于Framework开发的App最终会运行在Engine层上。其中Engine是Flutter提供的独立虚拟机，正是由于它的存在，Flutter程序才能运行在不同的平台上，实现跨平台运行。
  
  Flutter使用Engine来绘制Widget(部件)，即Flutter显示的单元，并且Dart代码会通过AOT编译为平台的原生代码，进而与平台直接通信，不需要JavaScript引擎的桥接，也不需要原生平台的Dalvik虚拟机。
  
  ![c8a6f4d8.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\c8a6f4d8.png)
  Flutter的Widget采用现代响应式框架构建，而Widget是不可变的，仅支持一帧，并且每一帧上的内容不能直接更新，需要通过Widget的状态来间接更新。在Flutter中，无状态和有状态Widget的核心特性是相同的，Flutter会重新构建视图的每一帧，通过State对象，Flutter就可以跨帧存储状态数据并恢复它。
  
  ## 1.4 对比与分析
  ![ad6cc2be.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\ad6cc2be.png)
  
  React Native,Weex采用的技术方案大体相同，它们都使用JavaScript作为编程语言，然后通过中间层转换为原生组件，再利用原生渲染引擎执行渲染操作。Flutter直接使用Skia来渲染视图，并且Flutter Widget使用现代响应式框架来构建，和平台没有直接的关系。
  
  ## 第二章 React Native 入门基础
  
  1. React Native 开发工具WebStorm
  
  2. npm与npx的区别
  - npm 侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令。
  - npm是一个node package安装工具。
  - npx是npm的高版本产物，安装npm时候就会安装npx
  - npx 侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。 
  - npx的作用是先检查本地有没有安装某个package，如果没有去远程registry找，找到的话直接使用，不用下载到本地node-modules包里面，
  
  3. 初始化工程命令(需要翻墙)
  - npx react-native init XXXXX
  
  4. 工程目录文件夹
  ![ebe5bcb8.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\ebe5bcb8.png)
  
  ## 第三章 React Native 基础语法
  ### 3.1 React基础
  #### 3.1.1 组件
  在React中分为**函数式组件**,**Class组件**
  1. 在语法上区别：
  - 函数式组件是一个纯函数，它是需要接受props参数并且返回一个React元素就可以了。
  - 类组件是需要继承React.Component的，而且class组件需要创建render并且返回React元素，语法上来讲更复杂。
  
  2. 调用方式
  - 函数式组件可以直接调用，返回一个新的React元素；
  - 类组件在调用时是需要创建一个实例的，然后通过调用实例里的render方法来返回一个React元素。
  
  3. 状态管理
  - 函数式组件没有this,生命周期,state状态
  - 类组件有this,生命周期，有react hook作为状态
  
  4. 性能
  - 函数式组件不需要创建实例，渲染的时候就执行一下，得到返回的react元素后就直接把中间量全部都销毁。
  - 类组件需要创建类组件的实例，而且不能销毁。性能消耗比较大。
  
  函数式组件:
  ```
  import React from 'react';
  import { Text } from 'react-native';
  
  const Cat = () => {
    return (
      <Text>Hello, I am your cat!</Text>
    );
  }
  
  export default Cat;
  ```
  类组件
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  
  class Cat extends Component {
    render() {
      return (
        <Text>Hello, I am your cat!</Text>
      );
    }
  }
  
  export default Cat;
  ```
  
  #### 3.1.2 JSX 
  实际上，JSX仅仅只是React.createElement(component,props,.....children)函数的语法糖。
  ```
  <MyButton color="blue" shadowSize={2}>
    Click Me
  </MyButton>
  
  会编译为
  
  React.createElement(
    MyButton,
    {color: 'blue', shadowSize: 2},
    'Click Me'
  )
  ```
  1. React必须在作用域内
  由于JSX会编译为React.createElement调用形式，所以React库也必须包含在JSX代码作用域内。
  ```
  import React from 'react';
  import CustomButton from './CustomButton';
  ```
  
  2. 在JSX类型中使用点语法
  ```
  import React from 'react';
  
  const MyComponents = {
    DatePicker: function DatePicker(props) {
      return <div>Imagine a {props.color} datepicker here.</div>;
    }
  }
  
  function BlueDatePicker() {
    return <MyComponents.DatePicker color="blue" />;
  }
  
  ```
  3. 用户定义的组件必须以大写字母开头
  
  ```
  以小写字母开头的元素代表一个 HTML 内置组件，比如 <div>或者<span>会生成相应的字符串 'div' 或者 'span' 传递给 React.createElement（作为参数）。
  大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如<Foo/>会编译为 React.createElement(Foo)。
  
  import React from 'react';
  
  // 正确！组件需要以大写字母开头：
  function Hello(props) {
    // 正确！ 这种 <div> 的使用是合法的，因为 div 是一个有效的 HTML 标签：
    return <div>Hello {props.toWhat}</div>;
  }
  
  function HelloWorld() {
    // 正确！React 知道 <Hello /> 是一个组件，因为它是大写字母开头的：
    return <Hello toWhat="World" />;
  }
  ```
  4. 在运行时选择类型
  
  ```
  import React from 'react';
  import { PhotoStory, VideoStory } from './stories';
  
  const components = {
    photo: PhotoStory,
    video: VideoStory
  };
  
  function Story(props) {
    // 正确！JSX 类型可以是大写字母开头的变量。
    const SpecificStory = components[props.storyType];
    return <SpecificStory story={props.story} />;
  }
  ```
  #### 3.1.4 自定义组件
  我们把包含着其他组件的组件称为父组件或父容器。这里Cafe是一个父组件，而每个Cat则是子组件。
  ```
  import React from 'react';
  import { Text, TextInput, View } from 'react-native';
  
  const Cat = () => {
    return (
      <View>
        <Text>I am also a cat!</Text>
      </View>
    );
  }
  
  const Cafe = () => {
    return (
      <View>
        <Text>Welcome!</Text>
        <Cat />
        <Cat />
        <Cat />
      </View>
    );
  }
  
  export default Cafe;
  ```
  #### 3.1.5 props属性
  1. Props作为组件的参数可以实现定制的效果。
  ```
  import React from 'react';
  import { Text, View } from 'react-native';
  
  const Cat = (props) => {
    return (
      <View>
        <Text>Hello, I am {props.name}!</Text>
      </View>
    );
  }
  
  const Cafe = () => {
    return (
      <View>
        <Cat name="Maru" />
        <Cat name="Jellylorum" />
        <Cat name="Spot" />
      </View>
    );
  }
  
  export default Cafe;
  ```
  props作为父子组件沟通的桥梁，为组件之间的通信和传值提供了重要手段。
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import PropTypes from 'prop-types';
  
  class Child extends Component {
  
    constructor(props){
      super(props);
      this.state={
        counter:props.age||0
      }
    }
    render() {
      return (
        <Text>Hello, {this.props.name},{this.props.age}</Text>
      );
    }
  }
  Child.propTypes={
    name:PropTypes.string.isRequired,
    age:PropTypes.number
  }
  Child.defaultProps = {
    age:0
  }
  export default Child;
  ```
  如果父组件需要向子组件传递数据，只需要在组件中引入子组件，然后使用组件提供的props属性。
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import Child from './Child.js'
  
  class Cat extends Component {
  
    render() {
      return (
        <view>
        <Child name = "jack" age={30} />
        <Child name = "tom" age={20} />
        </view>
      );
    }
  }
  
  export default Cat;
  ```
  子组件props接收的数据格式由PropTypes进行检测，如果是必传参数，且还需要在组件之间进行数据传递时，props使用PropTypes来保证传递数据的类型和格式，当向props传入无效数据时，JavaScript的控制台会给出警告提示。
  
  2. if语句以及for循环不能在JSX中直接使用，但可以在JSX以外使用。
  ```
  function NumberDescriber(props) {
    let description;
    if (props.number % 2 == 0) {
      description = <strong>even</strong>;
    } else {
      description = <i>odd</i>;
    }
    return <div>{props.number} is an {description} number</div>;
  }
  ```
  3. Props默认值为True
  
  #### 3.1.6 state状态
  1. 函数式组件
  使用React的useState Hook来为组件添加状态。
  ```
  import React, { useState } from "react";
  import { Button, Text, View } from "react-native";
  
  const Cat = (props) => {
    const [isHungry, setIsHungry] = useState(true);
  
    return (
      <View>
        <Text>
          I am {props.name}, and I am {isHungry ? "hungry" : "full"}!
        </Text>
        <Button
          onPress={() => {
            setIsHungry(false);
          }}
          disabled={!isHungry}
          title={isHungry ? "Pour me some milk, please!" : "Thank you!"}
        />
      </View>
    );
  }
  
  const Cafe = () => {
    return (
      <>
        <Cat name="Munkustrap" />
        <Cat name="Spot" />
      </>
    );
  }
  
  export default Cafe;
  ```
  
  2. Class组件
  ```
  import React, { Component } from "react";
  import { Button, Text, View } from "react-native";
  
  class Cat extends Component {
    state = { isHungry: true };
  
    render() {
      return (
        <View>
          <Text>
            I am {this.props.name}, and I am
            {this.state.isHungry ? " hungry" : " full"}!
          </Text>
          <Button
            onPress={() => {
              this.setState({ isHungry: false });
            }}
            disabled={!this.state.isHungry}
            title={
              this.state.isHungry ? "Pour me some milk, please!" : "Thank you!"
            }
          />
        </View>
      );
    }
  }
  
  class Cafe extends Component {
    render() {
      return (
        <>
          <Cat name="Munkustrap" />
          <Cat name="Spot" />
        </>
      );
    }
  }
  
  export default  Cafe;
  ```
  
  ### 3.2 语法基础
  #### 3.2.1 let和const命令
  ```
  {
  let a = 10;
  var b = 1;
  }
  ```
  1. let 声明的变量只在let命令所在的代码块内有效。
  2. let 声明的变量不允许在相同作用域内重复声明。
  3. const 用于声明一个只读的常量，一旦声明，常量的值不能改变。
  4. const 声明的常量不可以重复声明。
  
  #### 3.2.2 类
  在ES6添加了对类的支持，引入了class关键字，新的class写法让对象的创建和继承更加直观，也让父类方法的调用、实例化、静态方法和构造函数等概念更加具象。
  ```
  class App extends Component{
    render(){
      return()
      <view></view>
    }
  }
  ```
  在ES6语法中，属性类型和默认属性则统一使用static修饰。
  ```
  class App extends React.Component{
    static defaultProps = {
      autoPlay : false
    };
    static propTypes = {
      autoPlay : React.PropTypes.bool.isRequired
    };
  }
  ```
  ### 3.3 Flexbox布局
  #### 3.3.1 Flexbox布局简介
  Flexbox布局的主要思想是让容器有能力使其子项目改变其宽度，高度，并以最佳方式填充可用空间。
  Flexbox布局属性分为**决定子组件属性**和**决定组件自身属性**
  决定子组件属性：flexwrap,alignltems,flexDirection
  决定组件自身属性:alignSelf和flex
  
  #### 3.3.2 Flex属性
  flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex 属性值被分割成多个部分。
  ```
  import React from "react";
  import { StyleSheet, Text, View } from "react-native";
  
  const Flex = () => {
    return (
      <View style={[styles.container, {
        // Try setting `flexDirection` to `"row"`.
        flexDirection: "column"
      }]}>
        <View style={[styles.style1]} />
        <View style={[styles.style2]} />
        <View style={[styles.style3]} />
      </View>
    );
  };
  
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      padding: 20,
    },
    style1:{
      flex: 1,
      backgroundColor: "red",
    },
    style2:{
      flex: 2,
      backgroundColor: "darkorange",
    },
    style3:{
      flex: 3,
      backgroundColor: "green",
    },
      
  });
  
  export default Flex;
  ```
  #### FlexDirection属性
  FlexDirection属性表示布局中子组件的排列方向，取值包括column,column-reverse,row,row-reverse,默认值为column.
  ```
  import React, { useState } from "react";
  import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
  
  const FlexDirectionBasics = () => {
    
    return (
      <View style={styles.container}>
          <Text style={styles.view_one}>视图1</Text>
          <Text style={styles.view_two}>视图2</Text>
      </View>
    );
  };
  
  
  const styles = StyleSheet.create({
    container: {
      flexDirection :'column',
      flex:1,
      justifyContent:'center',
      alignItems:'center',
      backgroundColord:'#F5FCFF',
    },
    view_one:{
      height:200,
      width:200,
      textAlign:'center',
      fontSize:28,
      backgroundColor:'red',
    },
    view_two:{
      height:200,
      width:200,
      textAlign:'center',
      fontSize:28,
      backgroundColor:'green',
    },
    
  });
  
  export default FlexDirectionBasics;
  ```
  #### FlexWrap属性
  FlexWrap属性主要用于控制子组件是单行还是多行显示。取值包括wrap,nowrap,wrap-reverse.
  ```
  import React, { useState } from "react";
  import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
  
  const FlexDirectionBasics = () => {
    
    return (
      <View style={styles.container}>
          <Text style={styles.view}>视图1</Text>
          <Text style={styles.view}>视图2</Text>
          <Text style={styles.view}>视图3</Text>
      </View>
    );
  };
  
  
  const styles = StyleSheet.create({
    container: {
      flex:1,
      paddingTop:200,
      justifyContent:'center',
      alignItems:'center',
      backgroundColor:'#F5FCFF',
      flexDirection:'row',
      flexWrap:'wrap'
    },
    view:{
      height:150,
      width:150,
      alignSelf:'center',
      alignItems:'center',
      fontSize:28,
      backgroundColor:'red'
    },
    
  });
  
  export default FlexDirectionBasics;
  ```
  #### justify Content属性
  justifyContent定义在容器内部主轴方向上如何排布子组件
  
  - flex-start: 默认值，从容器主轴起始位置开始排布
  - flex-end: 从容器主轴末尾位置开始排布
  - center: 子组件居中排布
  - space-between: 子组件之间等间距，不会在主轴两端设置额外的边距
  - space-around: 子组件之间等间距，且主轴两边各留出1/2间距值
  - space-evenly: 子组件与主轴两边的边距均相等
  ```
  import React, { useState } from "react";
  import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
  
  const FlexDirectionBasics = () => {
    
    return (
      <View style={styles.container}>
          <Text style={styles.view}>视图1</Text>
      </View>
    );
  };
  const styles = StyleSheet.create({
    container: {
      flex:1,
      backgroundColor:'#F5FCFF',
      justifyContent:'center',
      alignItems:'center',
      flexWrap:'wrap'
    },
    view:{
      height:150,
      width:150,
      textAlign:'center',
      fontSize:28,
      backgroundColor:'red'
    },
    
  });
  
  export default FlexDirectionBasics;
  ```
  #### Align Item属性
  alignItems定义在容器副轴(主轴交叉轴)方向上如何排布子组件。该效果与justifyContent是类似的。
  
  - stretch: 默认值，组件副轴方向尺寸，取该行整体的最大尺寸。此属性生效，对应组件在容器副轴方向不可设置固定尺寸值
  - flex-start: 从组件所在行的副轴方向起点开始布局
  - flex-end: 从组件所在行的副轴方向终点开始布局
  - center: 在组件所在行副轴方向居中
  - baseline: 在组件所在行的副轴方向基线对齐。每个子组件可以设置自身基线以便父容器用于布局
  
  #### Align Self属性
  alignItems定义可以让子组件在父容器中在副轴方向独立于整体的排布方式而拥有单独的排布方式。 取值与AlignItem 类似
  
  #### Align Content属性
  当子组件排布支持换行(flexWrap: true)时，通过alignContent属性定义多行内容在副轴方向上的排布方式。
  
  - flex-start: 副轴方向起点对齐
  - flex-end: 副轴方向终点对齐(终点指该行子组件最大的尺寸位置)
  - stretch: 副轴方向铺满整行(副轴方向设置固定尺寸，则此属性不生效)
  - center: 副轴方向居中排布
  - space-between: 贴紧两边，等行间距排布
  - space-around: 两边留白，等行间距。留白为行间距一半。
  
  ## 第四章 React技术详解
  ### 4.1 React简介
  ![51fb59e2.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\51fb59e2.png)
  在React框架中，为了解决页面元素的更新问题，React底层设计了一个虚拟DOM,此虚拟DOM与页面真是DOM进行映射，当数据变化时，React就会重新构建整个DOM树，并通过底层的diff算法找到DOM的差异部分，然后浏览器只需要更新变化的部分即可。虚拟DOM是React框架中一个比较核心的内容，是React出色性能的根本。
  
  在React框架中，有一个比较重要的概念，即数据的单向流动，数据默认从父节点传递到子节点。具体来说，父节点数据通过props传递到子节点，如果父节点的props值发生改变，那么其所有的子节点也会执行重新渲染操作。
  
  ### 4.2 高阶组件
  #### 4.2.1 定义和实现
  高阶组件，就是一个接收React组件作为参数，并返回一个新的React组件的组件。也就是说，高阶组件通过包裹被传入的React组件，经过一系列处理，最终返回一个相对增强的React组件。
  #### 4.2.2 分类
  #### 4.2.3 命名与参数
  
  ### 4.3 组件通信
  #### 4.4.1 父子组件通信
  - 父组件向子组件通信
  父组件通过props将值传递给子组件，子组件则通过this.props得到父组件传递的数据，当子组件接收到父组件传递的数据后再进行相应的处理。
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import Child from './Child.js'
  class Cat extends Component {
  constructor(props){
      super(props);
      this.state={
        parms:'fater send msg to child'
      }
    }
    render() {
      return (
        <view>
        <Child parms={this.state.parms} />
        </view>
      );
    }
  }
  export default Cat;
  ```
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  
  class Child extends Component {
  
    render() {
      return (
        <Text>{this.props.parms}</Text>
      );
    }
  }
  
  export default Child;
  ```
  - 子组件向父组件传递数据，可以使用回调函数和自定义时间两种方式，
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import Child from './Child.js'
  
  class Cat extends Component {
  
  constructor(props){
      super(props);
      this.state={}
    }
  
    onClickSon = (msgFromSon) =>{
       console.log(msgFromSon)
    }
    
    render() {
      return (
        <view>
        <Child onClickSon={this.onClickSon} />
        </view>
      );
    }
  }
  
  export default Cat;
  ```
  ```
  import React, { Component } from 'react';
  import { Text,TouchableOpacity} from 'react-native';
  
  class Child extends Component {
  
  render() {
      return (
        <TouchableOpacity onPress={()=>this.props.onClickSon('I am you son')}>
          <Text>david</Text>
        </TouchableOpacity>
      );
    }
  }
  
  export default Child;
  ```
  #### 4.4.2 跨级组件通信
  #### 4.4.3 非嵌套组件通信
  
  ### 4.5 事件处理
  #### 4.5.1 事件监听与处理
  #### 4.5.2 event事件与this关键字
  #### 4.5.3 EventEmitter在React Native中的应用
  
  ## 第五章 React Native组件详解
  ### 5.1 基础组件
  #### 5.1.1 Text
  - selectable:用户是否可以长按选择文本实现复制和粘贴操作，默认为false.
  - adjustisFontSizeToFit: 字体是否随着样式的限制而自动缩放，**仅对IOS有效**。
  - allowFontScaling:控制字体是否要根据系统的字体大小来缩放。
  - minimumFontScale:当adjustisFontSizeToFit为true时，可以使用此属性指定字体的最小缩放比，**仅对IOS有效**。
  - onLayout:当挂载或者布局发生变化后执行此函数。
  - onLongPress:当文本组件被长按以后触发此函数。
  - onPress:当文本组件被点击后调用此函数。
  - numberOfLines:用于设置文本最大显示行数，文本过长时会裁剪文本。
  - ellipsizeMode:当文本组件无法全部显示所需要显示的字符串时，此属性会指定省略号显示的位置。
  - selectionColor:文本被选择时的高亮颜色，**仅对Android有效**
  - suppressHighlighting:文本被按下时是否显示视觉效果，**仅对iOS有效**。
  - textShadowOffset: 字体阴影效果。
  - fontSize: 字体大小。
  - fontStyle: 字体样式，常见的取值有normal,itallic.
  - fontWeight: 字体粗细，支持normal,bold和100~900的取值。
  - lineHeight:文本行高度。
  - textAlign: 文本对齐方式，支持auto,left,right,center和justify取值。
  - textDecorationLine: 文本横线样式，支持的取值有none、underline、line-through和underline line-through样式。
  - textDecorationColor: 文本装饰线条的颜色。
  - textDecorationStyle: 文本装饰线条的自定义样式。
  - writingDirection: 文字显示的方向。
  - textAlignVertical:垂直方向上文本对齐的方式，支持auto,top,bottom和center方式。
  - letterSpacing:每个字符之间的距离。
  
  **Text组件默认使用的特有的文件布局，如果想要文本内容居中显示，还需要在Text组件外面再套一层View组件**
  #### 5.1.2 TextInput
  - allowFontScaling:控制字体是否需要根据系统的字体大小进行缩放。
  - autoCapitalize:控制是否需要将输入的字符切换为大写。
  - autoCorrect:是否关闭拼写自动修正。
  - autoFocus:是否自动获得焦点。
  - blurOnSubmit: 是否在文本框内容提交的时候失去焦点，单行输入框默认情况下为true，多行则为false.
  - caretHidden:是否隐藏光标。
  - clearButtonMode: 是否要在文本框右侧显示清除按钮，**仅在iOS的单行输入模式下有效**。
  - clearTextOnFocus: 是否在每次开始输入的时候清除文本框的内容。**仅对IOS有效** 
  - dataDetectorTypes: 将输入的内容转换为指定的数据类型，可选值有phoneNumber,link,address,calendarEvent,none和all.
  - defaultValue: 定义TextInput组件中的字符串默认值。
  - disableFullScreenUI:是否开启全屏文本输入模式，默认为false.
  - editable:控制文本框是否可编辑。
  - inlineImageLeft: 指定一个图片放之在输入框的左侧，**仅对Android有效**.图片必须放置在/android/app/src/main/res/drawable目录下。
  - inlineImagePadding: 给左侧的图片设置padding样式，**仅对Android有效**。
  - keyboardAppearance: 指定软键盘的颜色，**仅对iOS有效**。
  - keyboardType:指定弹出软键盘的类型，支持number-pad,decimal-pad,numeric,email-address和phone-pad等键盘类型。
  - maxLength:限制文本框中的字符个数。
  - multiline:控制文本框是否可以输入多行文字。
  - numberOfLines:输入框的行数，需要multiline属性为true时才有效。
  - onBlur:文本框失去焦点时的回调函数。
  - onChange:文本框内容发生变化时的回调函数，它的回调接收一个event参数，可以通过event.nativeEvent.text获取用户输入的内容。
  - onChangeText:文本框内容发生变化时的回调函数，onChangeText的回调函数返回的内容和onChange类型，不过onChangesText可以直接返回用户输入的内容。
  - onContentSizeChange:文本框内容长度发生变化时调用此函数。
  - onEndEditing:文本输入结束后的回调函数。
  - onFocus:文本输入框获取焦点时的回调函数。
  - onKeyPress:当指定的键被按下时的回调函数。
  - onLayout:当组件加载或者布局发生变化时调用。
  - onSelectionChange:长按选择文本内容，选择范围发生变化调用此函数。
  - onSubmitEditing:当软键盘的确定/提交按钮被按下时调用此函数。
  - placeholder:文本输入框的默认占位字符串。
  - placeholderTextColor:文本输入框占位字符串显示的文字颜色。
  - returnKeyLabel:是否显示软键盘的确认按钮，**仅对Android有效**。
  - returnKeyType:决定确定按钮显示的内容，支持done,go,next,search和send等取值。
  - secureTextEntry:是否显示文本框输入的文字，如果为true,可以实现类似密码的显示效果。
  - selection:设置选中文字的范围。
  - selectionColor:设备输入框高亮时的颜色，包括光标的颜色。
  - selectTextOnFocus:如果为true,获取焦时所有文字都会被选中。
  - spellCheck:是否禁用拼写检查的样式，**仅对iOS有效**
  
  #### 5.1.3 Image
  使用Image组件加载图片时只需要设置source属性即可，如果加载的是网络图片需要添加uri标识。
  
  Image组件的图片宽和高都为0，使用Image组件加载图片时需要为图片指定宽和高，否则图片无法显示。
  
  resizeMode 取值有5种，cover,contain,stretch,repeat,center.
  - cover 在保持图片宽度比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸。
  - contain 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸。
  - strectch 拉伸图片且不维持图片的宽高比，直到宽度和高度都刚好填满容器。
  - repeat 在维持原始尺寸的前提下，重复平铺图片直到填满容器。
  - center 居中且不拉伸的显示图片。
  
  除了支持一些常用的style样式外，image组件还支持以下常用属性。
  - blurRadius 为图片添加一个指定半径的模糊滤镜。
  - onLayout 当元素加载或者布局改变的时候调用此函数。
  - onLoad 图片加载成功后调用此回调函数。
  - onLoadEnd 图片加载结束后调用此回调函数，不论成功还是失败。
  - onLoadStart 开始加载图片时调用此函数。
  - source: 图片源数据，支持本地图片和网络图片。
  - onError:加载错误时的回调函数。
  - accessibilityLabel: 设置一段文字，当用户与图片交互时，读屏器会朗读设置的文字，**仅对IOS有效**.
  - accessible: 当此属性为true时，标识图片是一个启用了无障碍功能的元素，**仅对IOS有效**。
  - defaultSource: 默认显示的图片，仅对iOS有效。
  - onPartialLoad: 如果图片支持逐步加载，则在逐步加载的过程种会调用此方法,**仅对IOS有效**。
  
  #### 5.1.4 ActivityIndicator
  - animating: 是否需要显示指示器。默认为true.
  - color: 加载指示器的前景颜色。默认为灰色.
  - size: 指示器的大小。支持small和large两种值，对于Android来说还支持设定具体的数值。
  - hidesWhenStopped: 在animating为false的时候，决定是否隐藏指示器。
  
  #### 5.1.5 Switch
  - disabled 是否禁用此组件的交互。
  - onValueChange 当值发生改变时调用此回调函数。
  - ios_backgroundColor 当Switch组件为false或禁用切换时的默认背景颜色，**仅对iOS有效**。
  - thumbColor 开关按钮上图形按钮的背景颜色。
  - tintColor 开关按钮关闭时的边框颜色。
  - value 开关按钮是否被打开，默认为false。
  
  ### 5.2 容器组件
  #### 5.2.1 View组件
  - onStartShouldSetReponder: 设置视图是否需要响应touch start事件。
  - accessibilityHint: 可访问的提示内容，帮助用户进行正常操作。
  - accessible: 视图是否启用无障碍功能，默认情况下，所有可触摸操作的元素都是无障碍功能元素。
  - accessibilityLabel: 设置当用户与此元素交互时读屏器阅读的文字，这是针对视力障碍人士的辅助功能。
  - hitSlop:定义触摸事件在距离视图有多远以内可以触发。
  - onAccessibilityTap: 当accessible属性未true时，如果用户对一个已选中的无障碍元素做了一个双击手势，系统会调用此函数。
  - onLayout:当组件挂载或者布局发生变化时调用。
  - onMagicTap:当accessible属性为true时，如果用户做了一个双指轻触手势，系统会调用此函数。
  - onMoveShouldSetResponder:当视图发生滑动响应事件时就会调用此函数。
  - onMoveShouldSetResponderCapture:如果父视图想要阻止子视图响应滑动触摸事件，就可以设置此方法并返回true.
  - onResponderGrant:视图响应触摸事件时会执行此函数。
  - onResponderMode:当用户正在屏幕上移动手指时调用这个函数。
  - onResponderReject:一个响应器处于活跃状态时，将不会响应另一个视图的请求。
  - onResponderRelease:触摸事件结束时调用此函数。
  - onResponderTerminate:请求当前视图成为事件的响应者。
  - onResponderTerminationRequest:其他某个视图想要成为事件的响应者，并要求当前视图放弃对事件的响应时就会调用此函数，如果允许使放响应就返回true。
  - pointerEvents:控制当前视图是否可以作为触控事件的目标，取值有auto,none,box-none和box-only.
  - collapsable:如果一个View只用于布局它的子组件，则它可能从原生磨具树移除。将此属性设为false可以禁用这个优化，以确保对应视图在原生结构中存在。
  
  #### 5.2.2 ScrollView组件
  作为一个容器组件，ScrollView必须有一个确定的高度才能正常工作。如果不知道容器的准确高度，可以将ScrollView组件的样式设置为{flex:1},让其自动填充父容器的空余空间。
  - keyboardDismissMode: 控制用户拖拽滚动视图时是否需要隐藏软键盘，取值有none,on-drag和interactive。interactive仅对iOS有效。
  
  - keyboardShouldPersistTaps: 控制当界面有软键盘时点击Scrollview后是否需要收起软键盘，取值有never,always和handled。
  - onContentSizeChange: 在ScrollView内部可滚动内容发生变化时调用。
  - onMomentumScrollBegin: 滚动动画开始时调用此函数。
  - onMomentumScrollEnd:滚动动画结束时调用此函数。
  - onScroll：滚动过程中调用此函数，每帧最多调用一次。
  - onScrollBeginDrag:开始拖动视图时调用此函数。
  - onScrollEngDrag:停止拖动视图时调用此函数。
  - paginEnabled:当值为true时，滚动条会停在滚动视图指定的位置上，可以用于水平分页。
  - refreshControl: 用于垂直视图时提供下拉刷新功能。
  - scrollEnabled:控制内容是否可滚动。
  - showsHorizontalScrollIndicator:是否显示水平方向上的滚动条。
  - showsVerticalScrollIndicator:是否显示垂直方向上的滚动条。
  - stickyHeaderIndices:决定某个成员会在滚动之后固定在屏幕顶端。
  - overScrollMode:覆盖默认的overScroll模式，支持的取值有auto,always和never.
  - horizontal:设置ScrollView组件横向显示。
  - decelerationRate:设置视图滚动的速度。
  - directionalLockEnabled:锁定视图滚动的方向。
  - indicatorStyle:设置滚动条的样式，支持的取值有default、black和white.
  - scrollsToTop:点击状态栏的时候视图会滚动到顶部。
  - snapToAlignment:定义停驻点与滚动视图之间的关系，支持的取值有start,center和end.
  
  在React Native官方提供的组件中，FlatList组件也能够实现滚动效果。不同的是，FlatList只是惰性的渲染子元素，即子元素只在将要出现在屏幕中时才开始渲染，而ScrollView会把所有子元素一次性全部渲染出来，开发时可以根据需要合理地进行选取。
  
  #### 5.2.3 WebView组件
  #### 5.2.4 TouchableOpacity组件
  在React Native应用开发中，点击和触摸都是比较常见的交互行为，不过并不是所有的组件都支持点击事件。
  为了给这些不具备点击响应的组件绑定点击事件，React Native提供了Touchable系列组件。事实上，Touchable系列组件并不单指某一个组件，而是由TouchableWithoutFeedback,TouchableOpacity,TouchableHighlight和
  TouchableNativeFeedback组件组成。
  
  其中，TouchableWithoutFeedback不带反馈效果，其他3个组件都是带有触摸反馈效果的，可以理解为其他3个组件是TouchableWithoutFeedback组件的扩展，它们的具体含义和作用如下。
  - TouchableWithoutFeedback: 无反馈性触摸，用户点击时页面无任何视觉效果。
  - TouchableHighlight: 高亮触摸，在用户点击组件时产生高亮效果。
  - TouchableOpacity: 透明触摸，在用户点击组件时产生透明效果。
  - TouchableNativeFeedback: 仅适用于Android平台的触摸响应组件，会在用户点击后产生水波纹的视觉效果。
  
  TouchableOpacity组件提供了很多有用的属性和方法。
  - activeOpacity:设置用户点击组件时透明度值，取值范围为0到1，默认为0.2.
  - tvParallaxProperties: **此属性仅对AppleTV 有效**，主要用于控制Apple TV的视差的效果。
  - hasTVPreferredFocus: **此属性仅对AppleTV 有效**，判断是否获取焦点。
  - setOpacityTo(): 设置组件的不透明度值，伴随由过度动画。
  
  ### 5.3 列表组件
  #### 5.3.1 VirtualizedList组件
  #### 5.3.2 FlatList组件
  FlatList组件使用非常简单，FlatList组件适用于加载长列表数据，只需要给FlatList组件提供data和renderItem两个属性即可。data表示数据源，renderItem表示每行的绘制方法。
  - ItemSeparatorComponent:行与行之间的分割线，不会出现在第一行之间和最后一行之后。
  - ListEmptyComponent:列表的尾部组件，通常用于上拉加在操作。
  - ListHeaderComponent:列表的头部组件，通常用于下拉刷新操作。
  - columnWrapperStyle: 多列布局，如果设置此属性，则可以在每行容器上设置单独的样式。
  - data: data属性表示FlatList的数据源，目前只支持普通数组。如果需要使用其他特殊数据，则可以使用VirtualizedList组件。
  - extraData: 如果列表需要有除data以外的数据源，请在此属性中指定。
  - getItem: 获取每个Item对象。
  - getItemCount: 获取Item的数量
  - getItemLayout: 可选优化，用于避免动态测量内容尺寸带来的开销，不够前提是可以提前知道被包裹内容的高度。
  - horizontal:设置为true则变为水平布局模式，默认为垂直布局。
  - initialNumToRender:指定开始渲染的元素数量，最好刚刚够填满一个屏幕，这样可以保证用最短的时间将视图可见的内容呈现给用户。同时，首次渲染的元素不会再滑动过程中被卸载，从而保证用户在执行返回顶部的操作时，不需要重新渲染首批元素，提高渲染的效率。
  - initialScrollIndex:指定渲染开始的index.
  - keyExtractor:此函数用于为给定的item生成一个不重复的key.key的作用是使React能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。
  - legacylmplementation:设置为true,则使用旧的ListView方式实现。
  - numColumns:多列布局样式，只能在非水平模式下使用。组件内元素必须使等高的，并且暂时还无法支持瀑布流布局。
  - onEndReached: 当列表滚动到距离内容最底部、不足设定的距离时触发。
  - onEndReachedThreshold: 用于决定当内容距离容器的最底不还有设定的距离时触发此函数。
  - onRefresh: 设置此属性后，FlatList组件会在列表头部添加一个标准的RefreshControl控件，以便实现下拉刷新功能。
  - renderItem: 根据行数据data 渲染每一行的视图。
  - onViewableItemsChanged:在可见行元素变化时调用，可见范围和变化频率等参数的配置需要设置viewabilityconfig属性。
  - scrollToEnd: 滚动到底部，如果不设置getItemLayout属性，页面可能会比较卡顿。
  - scrollToIndex: 滚动到指定的列表位置，如果不设置getItemLayout属性，则无法跳转到当前可视区域以外的位置。
  - scrollToItem: 滚动到指定item的位置，如果不设置getItemLayout属性，页面可能会比较卡顿。
  - scrollToOffset: 滚动指定距离的位置。
  
  #### 5.3.3 SectionList组件
  SectionList是一个列表组件，不同于FlatList组件，SectionList组件主要用于开发列表分组，吸顶悬浮等功能。只需要提供renderItem、renderSectionHeader和sections等必要的属性。
  
  - ItemSeparatorComponent: 行与行之间的分隔线组件，不会出现第一行之前和最后一行之后。
  - ListEmptyComponent: 当列表为空时渲染，可以是一个React组件类，也可以是一个渲染函数或是一个已经渲染的某个元素。
  - SectionSeparatorComponent: 在每个section的顶部和底部渲染，有别于ItemSeparator Component,它仅在列表项之间渲染。
  - renderItem: 用来渲染每一个section中的每一个列表项视图。
  - renderSectionHeader: 用来渲染每个section的头部视图，再iOS设备上，headers元素默认会粘连在ScrollView视图的顶部。
  - sections:用来渲染视图的数据源，类似于FlatList中的data属性。
  - stickySectionHeadersEnabled：当section把它的前一个section的可视区推离
  
  核心函数：
  - scrollToLocation():将可视区内位于特定sectionIndex或itemIndex位置的列表项，滚动到可视区的指定位置。
  - recordInteraction():通知列表发生了某个事件，以便使列表重新计算可视区域。比如，当用户点击某个列表项或触发一个导航动作时，就可以调用这个方法。
  - flashScrollIndicators(): 只在滚动的时候短暂地显示滚动指示器。
  
  ### 5.4 平台组件
  #### 5.4.1 ViewPagerAndroid组件
  #### 5.4.2 SafeAreaView组件
  #### 5.4.3 segmentedControlIOS
  
  
  ## 第六章 React Native API
  ### 6.1 基础API
  #### 6.1.1 AppRegistry
  AppRegistry使应用程序JavaScript代码的运行入口，是最基本的API。
  通常，运行一个React Native应用大致会经历如下过程：应用程序的根组件使用AppRegistry.registerComponent()注册自己，然后原生系统加载应用的代码及资源包，并在加载完成之后调用AppRegistry.runApplication()来真正运行应用。
  
  除了registerComponent()方法外，AppRegistry还提供以下常用方法。
  - registerConfig():注册指定的配置。
  - registerRunnable(): 注册进程。
  - registerSection():注册一个切片。
  - getAppKeys():获取所有注册的线程。
  - getRegistry():获取所有注册的信息。
  - runApplication():启动React Native应用。
  - unmountAppLicationComponentAtRootTag():销毁应用。
  
  #### 6.1.2 AppState
  在React Native开发中，经常会遇到前后台状态切换的场景。为了监控应用的运行状态，React Native提供了AppState.通过AppState开发者可以很容易地获取应用的当前状态。
  
  在AppState中，应用的状态被分为active,background和inactive.
  - active 表示应用处于前台运行状态。
  - background 表示应用处于后台运行中。
  - inactive 表示应用处于前后台切换过程中或处在系统的多任务视图中。
  
  AppState还支持事件监听，事件监听需要用到addEventLiatener()和removeEventListener两个方法。
  
  #### 6.1.3 NetInfo
  
  #### 6.1.4 AsyncStorage
  AsyncStorage是一个异步、持久化的数据存储API,它以键值对的方式保存数据，其作用等价于iOS的NSUserDefaluts或Android的SharedPreferences.由于AsyncStorage的操作是全局的，所以官方建议开发者先对AsyncStorage进行封装后再使用，而不是直接使用。方法如下：
  - getItem(): 根据键值来获取结果，并将获取的结果返回给回调函数。
  - setItem(): 根据键值来保存value的值，完成后调用回调函数。
  - removeItem():根据键值删除某个值，并将结果返回给回调函数。
  - mergeItem():将已有的值和新的值进行合并，合并的结果会返回给回调函数。
  - clear():清除所有的AsyncStorage保存的数据。
  - getAllKeys(): 获取所有本应该用可以访问的数据，并将结果返回给回调函数。
  - flushGetRequests():清除所有进行中的查询操作。
  - multiGet():获取key所包含的所有字段的值，并将结果以回调函数的方式传递给一个键值数组。
  - multiRemove(): 删除所有key字段名数组中的数据，并将结果返回给回调函数。
  - multiMerge():将输入的值和已有的值合并，合并的对象要求是数组格式，合并的结果会返回给回调函数。
  
  #### 6.1.5 DeviceEventEmitter
  在移动应用开发中，如果两个相互独立的组件或进程之间要进行通信，最简单的方式就是使用广播。DeviceEventEmitter是React Native官方提供的用以实现事件发送和接收的API,其作用类似于原生系统的广播
  
  DeviceEventEmitter.addlistener()方法注册需要监听的事件，而事件发送方则使用DevcieEventEmitter.emit函数发送事件。DeviceEventEmitter.remove()方法用来移除监听事件。
  
  ### 6.2 屏幕相关API
  #### 6.2.1 Dimensions
  Dimensions是官方提供的一个用于获取屏幕尺寸的API,主要用于帮助开发者获取屏幕的宽和高的信息。Dimensions的使用比较简单，只需要使用get()方法即可获取宽和高的信息。
  除了get()方法外，Dimensions还提供了如下几个方法。
  - set():设置屏幕的宽高数据。
  - addEventListener():添加屏幕事件监听处理，当Dimensions对象内的属性改变时触发。
  - removeEventListener():移除屏幕事件监听处理。
  
  #### 6.2.2 PixelRatio
  PixelRatio是一个用于获取设备像素密度的API.所谓设备像素，指的是物理像素和设备独立像素之间的比值。事实上，React Native中，使用PixelRatio.get()方法即可获取设备的像素密度。
  
  | 设备像素密度 | 设备|
  | ---- | ------- |
  | 1    | mdpi Android 设备     | 
  | 1.5   | hdpi Android 设备    | 
  | 2  | iPhone4/5s/5c/5s/6/7/8以及xhdpi Android设备    |
  | 3    | 6Plus/6sPlus/7Plus/X/XS/Max 以及xxhdpi Android设备| 
  | 3.5    | Nexus 6/Pixel XL,2XL Android设备 | 
  
  为了让一个图片在不同分辨率的设备上显示相同的效果，就需要使用PixelRatio.getPixelSizeForLayoutSize()方法对图片进行适配。
  除getPixelSizeForLayoutSize()方法外，还提供了如下几个方法。
  - get():获取设备的像素密度。
  - getFontScale():返回字体大小缩放比例。
  - roundToNearestPixel():将布局代下设置为与整数想
  
  ### 6.3 动画API
  #### 6.3.1 requestAnimationFrame
  #### 6.3.2 LayoutAnimation
  #### 6.3.3 Animated
  
  ### 6.4 平台API
  #### 6.4.1 BackHandler
  BackHandler 用于监听Android设备返回事件的API。
  通过addEventListener方法添加事件监听和使用，removeEventListener方法移除事件监听。对于Android环境来说，如果要退出应用，还可以使用BackHandler提供的exitApp()方法。
  
  #### 6.4.2 PermissionsAndroid
  PermissionsAndroid是React Native为了适配Android 6.0及以上版本的动态权限问题而退出的API，仅对Android 平台有效。
  - check(): 检测用户是否授权过某个动态权权限。
  - request():弹出提示框向用户请求某项动态权限。
  - requestMultiple():弹出提示框向用户请求多个动态权限。
  
  #### 6.4.4 PushNotificationIOS
  
  
  
  ## 文献
  [React 基础 · React Native 中文网](https://reactnative.cn/docs/intro-react
  [深入 JSX – React](https://zh-hans.reactjs.org/docs/jsx-in-depth.html)
'''
linesHighlighted: [
  995
]
isStarred: false
isTrashed: false
