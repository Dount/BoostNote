createdAt: "2022-10-24T05:28:37.339Z"
updatedAt: "2022-12-02T05:39:24.555Z"
type: "MARKDOWN_NOTE"
folder: "bfd1eca2e356e7181dfa"
title: "React Natvie 学习"
tags: []
content: '''
  # React Natvie 学习
  [TOC]
  
  ## 第1章 React Native 背景知识
  
  ## 1.1 React Native 的诞生和发展
  
  1. 在React框架的基础上，React Native框架前台的javaScript代码通过调用封装的Android和iOS原生平台的代码来实现界面的渲染操作。
  
  2. React Native 使用JSX语法替代JavaScript语法，JSX是一种XML和JavaScript结合的扩展语法。
  
  3. React Native 框架底层使用的是JavaScriptCore引擎。
  
  ## 1.2 阿里巴巴 Weex 框架原理
  
  作为一个前端跨平台技术框架，Weex建立了一套源码转换以及原生端与JavaScript通信的机制。Weex框架表面上是一个前端客户端框架，但实际上它串联起了从本地开发、云端部署到资源分发的整个链路。
  
  具体来说，在开发阶段编写一个.we文件，然后使用Weex提供的weex-toolkit转换工具将.we文件转换为Js bundle,并将生成的JS bundle上传部署到云端，最后通过网络请求或预下发的方法加载至用户的移动客户端应用中。同时，集成了WeexSDK 的客户端接收到JS bundle文件后，调用本地的JavaScript引擎执行环境执行相应的JS bundle,并将执行过程中产生的各种命令发送到原生端进行界面渲染，整个工作流程如图：
  
  ![f358f12a.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\f358f12a.png)
  
  Weex框架中最核心的部分就是JavaScript Runtime.当需要执行渲染操作时：在iOS环境下，使用基于JavaScriptCore内核的iOS系统提供的JSContext;在Android 环境下使用基于JavaScriptCore内核的JavaScript引擎。
  
  当JS bundle从服务器下载完成之后，Weex的Android、iOS和HTML5 会运行相应的JavaScript引擎来执行JS bundle,同时向终端的渲染层发送渲染指令，并调用客户端的渲染引擎进行视图渲染、事件绑定和处理用户交互等操作。
  
  ## 1.3 谷歌Flutter
  
  Flutter 直接选择2D绘图引擎库Skia来渲染界面，而React Native和Weex使用JavaScript作为编程语言，使用平台自身引擎渲染界面。性能上Flutter无限接近原生。
  
  ![443d8135.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\443d8135.png)
  
  Flutter框架主要由Framework层和Engine层组成，基于Framework开发的App最终会运行在Engine层上。其中Engine是Flutter提供的独立虚拟机，正是由于它的存在，Flutter程序才能运行在不同的平台上，实现跨平台运行。
  
  Flutter使用Engine来绘制Widget(部件)，即Flutter显示的单元，并且Dart代码会通过AOT编译为平台的原生代码，进而与平台直接通信，不需要JavaScript引擎的桥接，也不需要原生平台的Dalvik虚拟机。
  
  ![c8a6f4d8.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\c8a6f4d8.png)
  Flutter的Widget采用现代响应式框架构建，而Widget是不可变的，仅支持一帧，并且每一帧上的内容不能直接更新，需要通过Widget的状态来间接更新。在Flutter中，无状态和有状态Widget的核心特性是相同的，Flutter会重新构建视图的每一帧，通过State对象，Flutter就可以跨帧存储状态数据并恢复它。
  
  ## 1.4 对比与分析
  ![ad6cc2be.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\ad6cc2be.png)
  
  React Native,Weex采用的技术方案大体相同，它们都使用JavaScript作为编程语言，然后通过中间层转换为原生组件，再利用原生渲染引擎执行渲染操作。Flutter直接使用Skia来渲染视图，并且Flutter Widget使用现代响应式框架来构建，和平台没有直接的关系。
  
  ## 第2章 React Native 入门基础
  
  1. React Native 开发工具WebStorm
  
  2. npm与npx的区别
  - npm 侧重于执行命令的，执行某个模块命令。虽然会自动安装模块，但是重在执行某个命令。
  - npm是一个node package安装工具。
  - npx是npm的高版本产物，安装npm时候就会安装npx
  - npx 侧重于安装或者卸载某个模块的。重在安装，并不具备执行某个模块的功能。 
  - npx的作用是先检查本地有没有安装某个package，如果没有去远程registry找，找到的话直接使用，不用下载到本地node-modules包里面，
  
  3. 初始化工程命令(需要翻墙)
  - npx react-native init XXXXX
  
  4. 工程目录文件夹
  ![ebe5bcb8.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\ebe5bcb8.png)
  
  ## 第3章 React Native 基础语法
  ### 3.1 React基础
  #### 3.1.1 组件
  在React中分为**函数式组件**,**Class组件**
  1. 在语法上区别：
  - 函数式组件是一个纯函数，它是需要接受props参数并且返回一个React元素就可以了。
  - 类组件是需要继承React.Component的，而且class组件需要创建render并且返回React元素，语法上来讲更复杂。
  
  2. 调用方式
  - 函数式组件可以直接调用，返回一个新的React元素；
  - 类组件在调用时是需要创建一个实例的，然后通过调用实例里的render方法来返回一个React元素。
  
  3. 状态管理
  - 函数式组件没有this,生命周期,state状态
  - 类组件有this,生命周期，有react hook作为状态
  
  4. 性能
  - 函数式组件不需要创建实例，渲染的时候就执行一下，得到返回的react元素后就直接把中间量全部都销毁。
  - 类组件需要创建类组件的实例，而且不能销毁。性能消耗比较大。
  
  函数式组件:
  ```
  import React from 'react';
  import { Text } from 'react-native';
  
  const Cat = () => {
    return (
      <Text>Hello, I am your cat!</Text>
    );
  }
  
  export default Cat;
  ```
  类组件
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  
  class Cat extends Component {
    render() {
      return (
        <Text>Hello, I am your cat!</Text>
      );
    }
  }
  
  export default Cat;
  ```
  
  #### 3.1.2 JSX 
  实际上，JSX仅仅只是React.createElement(component,props,.....children)函数的语法糖。
  ```
  <MyButton color="blue" shadowSize={2}>
    Click Me
  </MyButton>
  
  会编译为
  
  React.createElement(
    MyButton,
    {color: 'blue', shadowSize: 2},
    'Click Me'
  )
  ```
  1. React必须在作用域内
  由于JSX会编译为React.createElement调用形式，所以React库也必须包含在JSX代码作用域内。
  ```
  import React from 'react';
  import CustomButton from './CustomButton';
  ```
  
  2. 在JSX类型中使用点语法
  ```
  import React from 'react';
  
  const MyComponents = {
    DatePicker: function DatePicker(props) {
      return <div>Imagine a {props.color} datepicker here.</div>;
    }
  }
  
  function BlueDatePicker() {
    return <MyComponents.DatePicker color="blue" />;
  }
  
  ```
  3. 用户定义的组件必须以大写字母开头
  
  ```
  以小写字母开头的元素代表一个 HTML 内置组件，比如 <div>或者<span>会生成相应的字符串 'div' 或者 'span' 传递给 React.createElement（作为参数）。
  大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如<Foo/>会编译为 React.createElement(Foo)。
  
  import React from 'react';
  
  // 正确！组件需要以大写字母开头：
  function Hello(props) {
    // 正确！ 这种 <div> 的使用是合法的，因为 div 是一个有效的 HTML 标签：
    return <div>Hello {props.toWhat}</div>;
  }
  
  function HelloWorld() {
    // 正确！React 知道 <Hello /> 是一个组件，因为它是大写字母开头的：
    return <Hello toWhat="World" />;
  }
  ```
  4. 在运行时选择类型
  
  ```
  import React from 'react';
  import { PhotoStory, VideoStory } from './stories';
  
  const components = {
    photo: PhotoStory,
    video: VideoStory
  };
  
  function Story(props) {
    // 正确！JSX 类型可以是大写字母开头的变量。
    const SpecificStory = components[props.storyType];
    return <SpecificStory story={props.story} />;
  }
  ```
  #### 3.1.4 自定义组件
  我们把包含着其他组件的组件称为父组件或父容器。这里Cafe是一个父组件，而每个Cat则是子组件。
  ```
  import React from 'react';
  import { Text, TextInput, View } from 'react-native';
  
  const Cat = () => {
    return (
      <View>
        <Text>I am also a cat!</Text>
      </View>
    );
  }
  
  const Cafe = () => {
    return (
      <View>
        <Text>Welcome!</Text>
        <Cat />
        <Cat />
        <Cat />
      </View>
    );
  }
  
  export default Cafe;
  ```
  #### 3.1.5 props属性
  1. Props作为组件的参数可以实现定制的效果。
  ```
  import React from 'react';
  import { Text, View } from 'react-native';
  
  const Cat = (props) => {
    return (
      <View>
        <Text>Hello, I am {props.name}!</Text>
      </View>
    );
  }
  
  const Cafe = () => {
    return (
      <View>
        <Cat name="Maru" />
        <Cat name="Jellylorum" />
        <Cat name="Spot" />
      </View>
    );
  }
  
  export default Cafe;
  ```
  props作为父子组件沟通的桥梁，为组件之间的通信和传值提供了重要手段。
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import PropTypes from 'prop-types';
  
  class Child extends Component {
  
    constructor(props){
      super(props);
      this.state={
        counter:props.age||0
      }
    }
    render() {
      return (
        <Text>Hello, {this.props.name},{this.props.age}</Text>
      );
    }
  }
  Child.propTypes={
    name:PropTypes.string.isRequired,
    age:PropTypes.number
  }
  Child.defaultProps = {
    age:0
  }
  export default Child;
  ```
  如果父组件需要向子组件传递数据，只需要在组件中引入子组件，然后使用组件提供的props属性。
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import Child from './Child.js'
  
  class Cat extends Component {
  
    render() {
      return (
        <view>
        <Child name = "jack" age={30} />
        <Child name = "tom" age={20} />
        </view>
      );
    }
  }
  
  export default Cat;
  ```
  子组件props接收的数据格式由PropTypes进行检测，如果是必传参数，且还需要在组件之间进行数据传递时，props使用PropTypes来保证传递数据的类型和格式，当向props传入无效数据时，JavaScript的控制台会给出警告提示。
  
  2. if语句以及for循环不能在JSX中直接使用，但可以在JSX以外使用。
  ```
  function NumberDescriber(props) {
    let description;
    if (props.number % 2 == 0) {
      description = <strong>even</strong>;
    } else {
      description = <i>odd</i>;
    }
    return <div>{props.number} is an {description} number</div>;
  }
  ```
  3. Props默认值为True
  
  #### 3.1.6 state状态
  1. 函数式组件
  使用React的useState Hook来为组件添加状态。
  ```
  import React, { useState } from "react";
  import { Button, Text, View } from "react-native";
  
  const Cat = (props) => {
    const [isHungry, setIsHungry] = useState(true);
  
    return (
      <View>
        <Text>
          I am {props.name}, and I am {isHungry ? "hungry" : "full"}!
        </Text>
        <Button
          onPress={() => {
            setIsHungry(false);
          }}
          disabled={!isHungry}
          title={isHungry ? "Pour me some milk, please!" : "Thank you!"}
        />
      </View>
    );
  }
  
  const Cafe = () => {
    return (
      <>
        <Cat name="Munkustrap" />
        <Cat name="Spot" />
      </>
    );
  }
  
  export default Cafe;
  ```
  
  2. Class组件
  ```
  import React, { Component } from "react";
  import { Button, Text, View } from "react-native";
  
  class Cat extends Component {
    state = { isHungry: true };
  
    render() {
      return (
        <View>
          <Text>
            I am {this.props.name}, and I am
            {this.state.isHungry ? " hungry" : " full"}!
          </Text>
          <Button
            onPress={() => {
              this.setState({ isHungry: false });
            }}
            disabled={!this.state.isHungry}
            title={
              this.state.isHungry ? "Pour me some milk, please!" : "Thank you!"
            }
          />
        </View>
      );
    }
  }
  
  class Cafe extends Component {
    render() {
      return (
        <>
          <Cat name="Munkustrap" />
          <Cat name="Spot" />
        </>
      );
    }
  }
  
  export default  Cafe;
  ```
  
  ### 3.2 语法基础
  #### 3.2.1 let和const命令
  ```
  {
  let a = 10;
  var b = 1;
  }
  ```
  1. let 声明的变量只在let命令所在的代码块内有效。
  2. let 声明的变量不允许在相同作用域内重复声明。
  3. const 用于声明一个只读的常量，一旦声明，常量的值不能改变。
  4. const 声明的常量不可以重复声明。
  
  #### 3.2.2 类
  在ES6添加了对类的支持，引入了class关键字，新的class写法让对象的创建和继承更加直观，也让父类方法的调用、实例化、静态方法和构造函数等概念更加具象。
  ```
  class App extends Component{
    render(){
      return()
      <view></view>
    }
  }
  ```
  在ES6语法中，属性类型和默认属性则统一使用static修饰。
  ```
  class App extends React.Component{
    static defaultProps = {
      autoPlay : false
    };
    static propTypes = {
      autoPlay : React.PropTypes.bool.isRequired
    };
  }
  ```
  ### 3.3 Flexbox布局
  #### 3.3.1 Flexbox布局简介
  Flexbox布局的主要思想是让容器有能力使其子项目改变其宽度，高度，并以最佳方式填充可用空间。
  Flexbox布局属性分为**决定子组件属性**和**决定组件自身属性**
  决定子组件属性：flexwrap,alignltems,flexDirection
  决定组件自身属性:alignSelf和flex
  
  #### 3.3.2 Flex属性
  flex属性决定元素在主轴上如何填满可用区域。整个区域会根据每个元素设置的 flex 属性值被分割成多个部分。
  ```
  import React from "react";
  import { StyleSheet, Text, View } from "react-native";
  
  const Flex = () => {
    return (
      <View style={[styles.container, {
        // Try setting `flexDirection` to `"row"`.
        flexDirection: "column"
      }]}>
        <View style={[styles.style1]} />
        <View style={[styles.style2]} />
        <View style={[styles.style3]} />
      </View>
    );
  };
  
  const styles = StyleSheet.create({
    container: {
      flex: 1,
      padding: 20,
    },
    style1:{
      flex: 1,
      backgroundColor: "red",
    },
    style2:{
      flex: 2,
      backgroundColor: "darkorange",
    },
    style3:{
      flex: 3,
      backgroundColor: "green",
    },
      
  });
  
  export default Flex;
  ```
  #### FlexDirection属性
  FlexDirection属性表示布局中子组件的排列方向，取值包括column,column-reverse,row,row-reverse,默认值为column.
  ```
  import React, { useState } from "react";
  import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
  
  const FlexDirectionBasics = () => {
    
    return (
      <View style={styles.container}>
          <Text style={styles.view_one}>视图1</Text>
          <Text style={styles.view_two}>视图2</Text>
      </View>
    );
  };
  
  
  const styles = StyleSheet.create({
    container: {
      flexDirection :'column',
      flex:1,
      justifyContent:'center',
      alignItems:'center',
      backgroundColord:'#F5FCFF',
    },
    view_one:{
      height:200,
      width:200,
      textAlign:'center',
      fontSize:28,
      backgroundColor:'red',
    },
    view_two:{
      height:200,
      width:200,
      textAlign:'center',
      fontSize:28,
      backgroundColor:'green',
    },
    
  });
  
  export default FlexDirectionBasics;
  ```
  #### FlexWrap属性
  FlexWrap属性主要用于控制子组件是单行还是多行显示。取值包括wrap,nowrap,wrap-reverse.
  ```
  import React, { useState } from "react";
  import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
  
  const FlexDirectionBasics = () => {
    
    return (
      <View style={styles.container}>
          <Text style={styles.view}>视图1</Text>
          <Text style={styles.view}>视图2</Text>
          <Text style={styles.view}>视图3</Text>
      </View>
    );
  };
  
  
  const styles = StyleSheet.create({
    container: {
      flex:1,
      paddingTop:200,
      justifyContent:'center',
      alignItems:'center',
      backgroundColor:'#F5FCFF',
      flexDirection:'row',
      flexWrap:'wrap'
    },
    view:{
      height:150,
      width:150,
      alignSelf:'center',
      alignItems:'center',
      fontSize:28,
      backgroundColor:'red'
    },
    
  });
  
  export default FlexDirectionBasics;
  ```
  #### justify Content属性
  justifyContent定义在容器内部主轴方向上如何排布子组件
  
  - flex-start: 默认值，从容器主轴起始位置开始排布
  - flex-end: 从容器主轴末尾位置开始排布
  - center: 子组件居中排布
  - space-between: 子组件之间等间距，不会在主轴两端设置额外的边距
  - space-around: 子组件之间等间距，且主轴两边各留出1/2间距值
  - space-evenly: 子组件与主轴两边的边距均相等
  ```
  import React, { useState } from "react";
  import { StyleSheet, Text, TouchableOpacity, View } from "react-native";
  
  const FlexDirectionBasics = () => {
    
    return (
      <View style={styles.container}>
          <Text style={styles.view}>视图1</Text>
      </View>
    );
  };
  const styles = StyleSheet.create({
    container: {
      flex:1,
      backgroundColor:'#F5FCFF',
      justifyContent:'center',
      alignItems:'center',
      flexWrap:'wrap'
    },
    view:{
      height:150,
      width:150,
      textAlign:'center',
      fontSize:28,
      backgroundColor:'red'
    },
    
  });
  
  export default FlexDirectionBasics;
  ```
  #### Align Item属性
  alignItems定义在容器副轴(主轴交叉轴)方向上如何排布子组件。该效果与justifyContent是类似的。
  
  - stretch: 默认值，组件副轴方向尺寸，取该行整体的最大尺寸。此属性生效，对应组件在容器副轴方向不可设置固定尺寸值
  - flex-start: 从组件所在行的副轴方向起点开始布局
  - flex-end: 从组件所在行的副轴方向终点开始布局
  - center: 在组件所在行副轴方向居中
  - baseline: 在组件所在行的副轴方向基线对齐。每个子组件可以设置自身基线以便父容器用于布局
  
  #### Align Self属性
  alignItems定义可以让子组件在父容器中在副轴方向独立于整体的排布方式而拥有单独的排布方式。 取值与AlignItem 类似
  
  #### Align Content属性
  当子组件排布支持换行(flexWrap: true)时，通过alignContent属性定义多行内容在副轴方向上的排布方式。
  
  - flex-start: 副轴方向起点对齐
  - flex-end: 副轴方向终点对齐(终点指该行子组件最大的尺寸位置)
  - stretch: 副轴方向铺满整行(副轴方向设置固定尺寸，则此属性不生效)
  - center: 副轴方向居中排布
  - space-between: 贴紧两边，等行间距排布
  - space-around: 两边留白，等行间距。留白为行间距一半。
  
  ## 第4章 React技术详解
  ### 4.1 React简介
  ![51fb59e2.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\51fb59e2.png)
  在React框架中，为了解决页面元素的更新问题，React底层设计了一个虚拟DOM,此虚拟DOM与页面真是DOM进行映射，当数据变化时，React就会重新构建整个DOM树，并通过底层的diff算法找到DOM的差异部分，然后浏览器只需要更新变化的部分即可。虚拟DOM是React框架中一个比较核心的内容，是React出色性能的根本。
  
  在React框架中，有一个比较重要的概念，即数据的单向流动，数据默认从父节点传递到子节点。具体来说，父节点数据通过props传递到子节点，如果父节点的props值发生改变，那么其所有的子节点也会执行重新渲染操作。
  
  ### 4.2 高阶组件
  #### 4.2.1 定义和实现
  高阶组件，就是一个接收React组件作为参数，并返回一个新的React组件的组件。也就是说，高阶组件通过包裹被传入的React组件，经过一系列处理，最终返回一个相对增强的React组件。
  #### 4.2.2 分类
  #### 4.2.3 命名与参数
  
  ### 4.3 组件通信
  #### 4.4.1 父子组件通信
  - 父组件向子组件通信
  父组件通过props将值传递给子组件，子组件则通过this.props得到父组件传递的数据，当子组件接收到父组件传递的数据后再进行相应的处理。
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import Child from './Child.js'
  class Cat extends Component {
  constructor(props){
      super(props);
      this.state={
        parms:'fater send msg to child'
      }
    }
    render() {
      return (
        <view>
        <Child parms={this.state.parms} />
        </view>
      );
    }
  }
  export default Cat;
  ```
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  
  class Child extends Component {
  
    render() {
      return (
        <Text>{this.props.parms}</Text>
      );
    }
  }
  
  export default Child;
  ```
  - 子组件向父组件传递数据，可以使用回调函数和自定义时间两种方式，
  ```
  import React, { Component } from 'react';
  import { Text } from 'react-native';
  import Child from './Child.js'
  
  class Cat extends Component {
  
  constructor(props){
      super(props);
      this.state={}
    }
  
    onClickSon = (msgFromSon) =>{
       console.log(msgFromSon)
    }
    
    render() {
      return (
        <view>
        <Child onClickSon={this.onClickSon} />
        </view>
      );
    }
  }
  
  export default Cat;
  ```
  ```
  import React, { Component } from 'react';
  import { Text,TouchableOpacity} from 'react-native';
  
  class Child extends Component {
  
  render() {
      return (
        <TouchableOpacity onPress={()=>this.props.onClickSon('I am you son')}>
          <Text>david</Text>
        </TouchableOpacity>
      );
    }
  }
  
  export default Child;
  ```
  #### 4.4.2 跨级组件通信
  #### 4.4.3 非嵌套组件通信
  
  ### 4.5 事件处理
  #### 4.5.1 事件监听与处理
  #### 4.5.2 event事件与this关键字
  #### 4.5.3 EventEmitter在React Native中的应用
  
  ## 第5章 React Native组件详解
  ### 5.1 基础组件
  #### 5.1.1 Text
  - selectable:用户是否可以长按选择文本实现复制和粘贴操作，默认为false.
  - adjustisFontSizeToFit: 字体是否随着样式的限制而自动缩放，**仅对IOS有效**。
  - allowFontScaling:控制字体是否要根据系统的字体大小来缩放。
  - minimumFontScale:当adjustisFontSizeToFit为true时，可以使用此属性指定字体的最小缩放比，**仅对IOS有效**。
  - onLayout:当挂载或者布局发生变化后执行此函数。
  - onLongPress:当文本组件被长按以后触发此函数。
  - onPress:当文本组件被点击后调用此函数。
  - numberOfLines:用于设置文本最大显示行数，文本过长时会裁剪文本。
  - ellipsizeMode:当文本组件无法全部显示所需要显示的字符串时，此属性会指定省略号显示的位置。
  - selectionColor:文本被选择时的高亮颜色，**仅对Android有效**
  - suppressHighlighting:文本被按下时是否显示视觉效果，**仅对iOS有效**。
  - textShadowOffset: 字体阴影效果。
  - fontSize: 字体大小。
  - fontStyle: 字体样式，常见的取值有normal,itallic.
  - fontWeight: 字体粗细，支持normal,bold和100~900的取值。
  - lineHeight:文本行高度。
  - textAlign: 文本对齐方式，支持auto,left,right,center和justify取值。
  - textDecorationLine: 文本横线样式，支持的取值有none、underline、line-through和underline line-through样式。
  - textDecorationColor: 文本装饰线条的颜色。
  - textDecorationStyle: 文本装饰线条的自定义样式。
  - writingDirection: 文字显示的方向。
  - textAlignVertical:垂直方向上文本对齐的方式，支持auto,top,bottom和center方式。
  - letterSpacing:每个字符之间的距离。
  
  **Text组件默认使用的特有的文件布局，如果想要文本内容居中显示，还需要在Text组件外面再套一层View组件**
  #### 5.1.2 TextInput
  - allowFontScaling:控制字体是否需要根据系统的字体大小进行缩放。
  - autoCapitalize:控制是否需要将输入的字符切换为大写。
  - autoCorrect:是否关闭拼写自动修正。
  - autoFocus:是否自动获得焦点。
  - blurOnSubmit: 是否在文本框内容提交的时候失去焦点，单行输入框默认情况下为true，多行则为false.
  - caretHidden:是否隐藏光标。
  - clearButtonMode: 是否要在文本框右侧显示清除按钮，**仅在iOS的单行输入模式下有效**。
  - clearTextOnFocus: 是否在每次开始输入的时候清除文本框的内容。**仅对IOS有效** 
  - dataDetectorTypes: 将输入的内容转换为指定的数据类型，可选值有phoneNumber,link,address,calendarEvent,none和all.
  - defaultValue: 定义TextInput组件中的字符串默认值。
  - disableFullScreenUI:是否开启全屏文本输入模式，默认为false.
  - editable:控制文本框是否可编辑。
  - inlineImageLeft: 指定一个图片放之在输入框的左侧，**仅对Android有效**.图片必须放置在/android/app/src/main/res/drawable目录下。
  - inlineImagePadding: 给左侧的图片设置padding样式，**仅对Android有效**。
  - keyboardAppearance: 指定软键盘的颜色，**仅对iOS有效**。
  - keyboardType:指定弹出软键盘的类型，支持number-pad,decimal-pad,numeric,email-address和phone-pad等键盘类型。
  - maxLength:限制文本框中的字符个数。
  - multiline:控制文本框是否可以输入多行文字。
  - numberOfLines:输入框的行数，需要multiline属性为true时才有效。
  - onBlur:文本框失去焦点时的回调函数。
  - onChange:文本框内容发生变化时的回调函数，它的回调接收一个event参数，可以通过event.nativeEvent.text获取用户输入的内容。
  - onChangeText:文本框内容发生变化时的回调函数，onChangeText的回调函数返回的内容和onChange类型，不过onChangesText可以直接返回用户输入的内容。
  - onContentSizeChange:文本框内容长度发生变化时调用此函数。
  - onEndEditing:文本输入结束后的回调函数。
  - onFocus:文本输入框获取焦点时的回调函数。
  - onKeyPress:当指定的键被按下时的回调函数。
  - onLayout:当组件加载或者布局发生变化时调用。
  - onSelectionChange:长按选择文本内容，选择范围发生变化调用此函数。
  - onSubmitEditing:当软键盘的确定/提交按钮被按下时调用此函数。
  - placeholder:文本输入框的默认占位字符串。
  - placeholderTextColor:文本输入框占位字符串显示的文字颜色。
  - returnKeyLabel:是否显示软键盘的确认按钮，**仅对Android有效**。
  - returnKeyType:决定确定按钮显示的内容，支持done,go,next,search和send等取值。
  - secureTextEntry:是否显示文本框输入的文字，如果为true,可以实现类似密码的显示效果。
  - selection:设置选中文字的范围。
  - selectionColor:设备输入框高亮时的颜色，包括光标的颜色。
  - selectTextOnFocus:如果为true,获取焦时所有文字都会被选中。
  - spellCheck:是否禁用拼写检查的样式，**仅对iOS有效**
  
  #### 5.1.3 Image
  使用Image组件加载图片时只需要设置source属性即可，如果加载的是网络图片需要添加uri标识。
  
  Image组件的图片宽和高都为0，使用Image组件加载图片时需要为图片指定宽和高，否则图片无法显示。
  
  resizeMode 取值有5种，cover,contain,stretch,repeat,center.
  - cover 在保持图片宽度比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸。
  - contain 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸。
  - strectch 拉伸图片且不维持图片的宽高比，直到宽度和高度都刚好填满容器。
  - repeat 在维持原始尺寸的前提下，重复平铺图片直到填满容器。
  - center 居中且不拉伸的显示图片。
  
  除了支持一些常用的style样式外，image组件还支持以下常用属性。
  - blurRadius 为图片添加一个指定半径的模糊滤镜。
  - onLayout 当元素加载或者布局改变的时候调用此函数。
  - onLoad 图片加载成功后调用此回调函数。
  - onLoadEnd 图片加载结束后调用此回调函数，不论成功还是失败。
  - onLoadStart 开始加载图片时调用此函数。
  - source: 图片源数据，支持本地图片和网络图片。
  - onError:加载错误时的回调函数。
  - accessibilityLabel: 设置一段文字，当用户与图片交互时，读屏器会朗读设置的文字，**仅对IOS有效**.
  - accessible: 当此属性为true时，标识图片是一个启用了无障碍功能的元素，**仅对IOS有效**。
  - defaultSource: 默认显示的图片，仅对iOS有效。
  - onPartialLoad: 如果图片支持逐步加载，则在逐步加载的过程种会调用此方法,**仅对IOS有效**。
  
  #### 5.1.4 ActivityIndicator
  - animating: 是否需要显示指示器。默认为true.
  - color: 加载指示器的前景颜色。默认为灰色.
  - size: 指示器的大小。支持small和large两种值，对于Android来说还支持设定具体的数值。
  - hidesWhenStopped: 在animating为false的时候，决定是否隐藏指示器。
  
  #### 5.1.5 Switch
  - disabled 是否禁用此组件的交互。
  - onValueChange 当值发生改变时调用此回调函数。
  - ios_backgroundColor 当Switch组件为false或禁用切换时的默认背景颜色，**仅对iOS有效**。
  - thumbColor 开关按钮上图形按钮的背景颜色。
  - tintColor 开关按钮关闭时的边框颜色。
  - value 开关按钮是否被打开，默认为false。
  
  ### 5.2 容器组件
  #### 5.2.1 View组件
  - onStartShouldSetReponder: 设置视图是否需要响应touch start事件。
  - accessibilityHint: 可访问的提示内容，帮助用户进行正常操作。
  - accessible: 视图是否启用无障碍功能，默认情况下，所有可触摸操作的元素都是无障碍功能元素。
  - accessibilityLabel: 设置当用户与此元素交互时读屏器阅读的文字，这是针对视力障碍人士的辅助功能。
  - hitSlop:定义触摸事件在距离视图有多远以内可以触发。
  - onAccessibilityTap: 当accessible属性未true时，如果用户对一个已选中的无障碍元素做了一个双击手势，系统会调用此函数。
  - onLayout:当组件挂载或者布局发生变化时调用。
  - onMagicTap:当accessible属性为true时，如果用户做了一个双指轻触手势，系统会调用此函数。
  - onMoveShouldSetResponder:当视图发生滑动响应事件时就会调用此函数。
  - onMoveShouldSetResponderCapture:如果父视图想要阻止子视图响应滑动触摸事件，就可以设置此方法并返回true.
  - onResponderGrant:视图响应触摸事件时会执行此函数。
  - onResponderMode:当用户正在屏幕上移动手指时调用这个函数。
  - onResponderReject:一个响应器处于活跃状态时，将不会响应另一个视图的请求。
  - onResponderRelease:触摸事件结束时调用此函数。
  - onResponderTerminate:请求当前视图成为事件的响应者。
  - onResponderTerminationRequest:其他某个视图想要成为事件的响应者，并要求当前视图放弃对事件的响应时就会调用此函数，如果允许使放响应就返回true。
  - pointerEvents:控制当前视图是否可以作为触控事件的目标，取值有auto,none,box-none和box-only.
  - collapsable:如果一个View只用于布局它的子组件，则它可能从原生磨具树移除。将此属性设为false可以禁用这个优化，以确保对应视图在原生结构中存在。
  
  #### 5.2.2 ScrollView组件
  作为一个容器组件，ScrollView必须有一个确定的高度才能正常工作。如果不知道容器的准确高度，可以将ScrollView组件的样式设置为{flex:1},让其自动填充父容器的空余空间。
  - keyboardDismissMode: 控制用户拖拽滚动视图时是否需要隐藏软键盘，取值有none,on-drag和interactive。interactive仅对iOS有效。
  
  - keyboardShouldPersistTaps: 控制当界面有软键盘时点击Scrollview后是否需要收起软键盘，取值有never,always和handled。
  - onContentSizeChange: 在ScrollView内部可滚动内容发生变化时调用。
  - onMomentumScrollBegin: 滚动动画开始时调用此函数。
  - onMomentumScrollEnd:滚动动画结束时调用此函数。
  - onScroll：滚动过程中调用此函数，每帧最多调用一次。
  - onScrollBeginDrag:开始拖动视图时调用此函数。
  - onScrollEngDrag:停止拖动视图时调用此函数。
  - paginEnabled:当值为true时，滚动条会停在滚动视图指定的位置上，可以用于水平分页。
  - refreshControl: 用于垂直视图时提供下拉刷新功能。
  - scrollEnabled:控制内容是否可滚动。
  - showsHorizontalScrollIndicator:是否显示水平方向上的滚动条。
  - showsVerticalScrollIndicator:是否显示垂直方向上的滚动条。
  - stickyHeaderIndices:决定某个成员会在滚动之后固定在屏幕顶端。
  - overScrollMode:覆盖默认的overScroll模式，支持的取值有auto,always和never.
  - horizontal:设置ScrollView组件横向显示。
  - decelerationRate:设置视图滚动的速度。
  - directionalLockEnabled:锁定视图滚动的方向。
  - indicatorStyle:设置滚动条的样式，支持的取值有default、black和white.
  - scrollsToTop:点击状态栏的时候视图会滚动到顶部。
  - snapToAlignment:定义停驻点与滚动视图之间的关系，支持的取值有start,center和end.
  
  在React Native官方提供的组件中，FlatList组件也能够实现滚动效果。不同的是，FlatList只是惰性的渲染子元素，即子元素只在将要出现在屏幕中时才开始渲染，而ScrollView会把所有子元素一次性全部渲染出来，开发时可以根据需要合理地进行选取。
  
  #### 5.2.3 WebView组件
  #### 5.2.4 TouchableOpacity组件
  在React Native应用开发中，点击和触摸都是比较常见的交互行为，不过并不是所有的组件都支持点击事件。
  为了给这些不具备点击响应的组件绑定点击事件，React Native提供了Touchable系列组件。事实上，Touchable系列组件并不单指某一个组件，而是由TouchableWithoutFeedback,TouchableOpacity,TouchableHighlight和
  TouchableNativeFeedback组件组成。
  
  其中，TouchableWithoutFeedback不带反馈效果，其他3个组件都是带有触摸反馈效果的，可以理解为其他3个组件是TouchableWithoutFeedback组件的扩展，它们的具体含义和作用如下。
  - TouchableWithoutFeedback: 无反馈性触摸，用户点击时页面无任何视觉效果。
  - TouchableHighlight: 高亮触摸，在用户点击组件时产生高亮效果。
  - TouchableOpacity: 透明触摸，在用户点击组件时产生透明效果。
  - TouchableNativeFeedback: 仅适用于Android平台的触摸响应组件，会在用户点击后产生水波纹的视觉效果。
  
  TouchableOpacity组件提供了很多有用的属性和方法。
  - activeOpacity:设置用户点击组件时透明度值，取值范围为0到1，默认为0.2.
  - tvParallaxProperties: **此属性仅对AppleTV 有效**，主要用于控制Apple TV的视差的效果。
  - hasTVPreferredFocus: **此属性仅对AppleTV 有效**，判断是否获取焦点。
  - setOpacityTo(): 设置组件的不透明度值，伴随由过度动画。
  
  ### 5.3 列表组件
  #### 5.3.1 VirtualizedList组件
  #### 5.3.2 FlatList组件
  FlatList组件使用非常简单，FlatList组件适用于加载长列表数据，只需要给FlatList组件提供data和renderItem两个属性即可。data表示数据源，renderItem表示每行的绘制方法。
  - ItemSeparatorComponent:行与行之间的分割线，不会出现在第一行之间和最后一行之后。
  - ListEmptyComponent:列表的尾部组件，通常用于上拉加在操作。
  - ListHeaderComponent:列表的头部组件，通常用于下拉刷新操作。
  - columnWrapperStyle: 多列布局，如果设置此属性，则可以在每行容器上设置单独的样式。
  - data: data属性表示FlatList的数据源，目前只支持普通数组。如果需要使用其他特殊数据，则可以使用VirtualizedList组件。
  - extraData: 如果列表需要有除data以外的数据源，请在此属性中指定。
  - getItem: 获取每个Item对象。
  - getItemCount: 获取Item的数量
  - getItemLayout: 可选优化，用于避免动态测量内容尺寸带来的开销，不够前提是可以提前知道被包裹内容的高度。
  - horizontal:设置为true则变为水平布局模式，默认为垂直布局。
  - initialNumToRender:指定开始渲染的元素数量，最好刚刚够填满一个屏幕，这样可以保证用最短的时间将视图可见的内容呈现给用户。同时，首次渲染的元素不会再滑动过程中被卸载，从而保证用户在执行返回顶部的操作时，不需要重新渲染首批元素，提高渲染的效率。
  - initialScrollIndex:指定渲染开始的index.
  - keyExtractor:此函数用于为给定的item生成一个不重复的key.key的作用是使React能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。
  - legacylmplementation:设置为true,则使用旧的ListView方式实现。
  - numColumns:多列布局样式，只能在非水平模式下使用。组件内元素必须使等高的，并且暂时还无法支持瀑布流布局。
  - onEndReached: 当列表滚动到距离内容最底部、不足设定的距离时触发。
  - onEndReachedThreshold: 用于决定当内容距离容器的最底不还有设定的距离时触发此函数。
  - onRefresh: 设置此属性后，FlatList组件会在列表头部添加一个标准的RefreshControl控件，以便实现下拉刷新功能。
  - renderItem: 根据行数据data 渲染每一行的视图。
  - onViewableItemsChanged:在可见行元素变化时调用，可见范围和变化频率等参数的配置需要设置viewabilityconfig属性。
  - scrollToEnd: 滚动到底部，如果不设置getItemLayout属性，页面可能会比较卡顿。
  - scrollToIndex: 滚动到指定的列表位置，如果不设置getItemLayout属性，则无法跳转到当前可视区域以外的位置。
  - scrollToItem: 滚动到指定item的位置，如果不设置getItemLayout属性，页面可能会比较卡顿。
  - scrollToOffset: 滚动指定距离的位置。
  
  #### 5.3.3 SectionList组件
  SectionList是一个列表组件，不同于FlatList组件，SectionList组件主要用于开发列表分组，吸顶悬浮等功能。只需要提供renderItem、renderSectionHeader和sections等必要的属性。
  
  - ItemSeparatorComponent: 行与行之间的分隔线组件，不会出现第一行之前和最后一行之后。
  - ListEmptyComponent: 当列表为空时渲染，可以是一个React组件类，也可以是一个渲染函数或是一个已经渲染的某个元素。
  - SectionSeparatorComponent: 在每个section的顶部和底部渲染，有别于ItemSeparator Component,它仅在列表项之间渲染。
  - renderItem: 用来渲染每一个section中的每一个列表项视图。
  - renderSectionHeader: 用来渲染每个section的头部视图，再iOS设备上，headers元素默认会粘连在ScrollView视图的顶部。
  - sections:用来渲染视图的数据源，类似于FlatList中的data属性。
  - stickySectionHeadersEnabled：当section把它的前一个section的可视区推离
  
  核心函数：
  - scrollToLocation():将可视区内位于特定sectionIndex或itemIndex位置的列表项，滚动到可视区的指定位置。
  - recordInteraction():通知列表发生了某个事件，以便使列表重新计算可视区域。比如，当用户点击某个列表项或触发一个导航动作时，就可以调用这个方法。
  - flashScrollIndicators(): 只在滚动的时候短暂地显示滚动指示器。
  
  ### 5.4 平台组件
  #### 5.4.1 ViewPagerAndroid组件
  #### 5.4.2 SafeAreaView组件
  #### 5.4.3 segmentedControlIOS
  
  
  ## 第6章 React Native API
  ### 6.1 基础API
  #### 6.1.1 AppRegistry
  AppRegistry使应用程序JavaScript代码的运行入口，是最基本的API。
  通常，运行一个React Native应用大致会经历如下过程：应用程序的根组件使用AppRegistry.registerComponent()注册自己，然后原生系统加载应用的代码及资源包，并在加载完成之后调用AppRegistry.runApplication()来真正运行应用。
  
  除了registerComponent()方法外，AppRegistry还提供以下常用方法。
  - registerConfig():注册指定的配置。
  - registerRunnable(): 注册进程。
  - registerSection():注册一个切片。
  - getAppKeys():获取所有注册的线程。
  - getRegistry():获取所有注册的信息。
  - runApplication():启动React Native应用。
  - unmountAppLicationComponentAtRootTag():销毁应用。
  
  #### 6.1.2 AppState
  在React Native开发中，经常会遇到前后台状态切换的场景。为了监控应用的运行状态，React Native提供了AppState.通过AppState开发者可以很容易地获取应用的当前状态。
  
  在AppState中，应用的状态被分为active,background和inactive.
  - active 表示应用处于前台运行状态。
  - background 表示应用处于后台运行中。
  - inactive 表示应用处于前后台切换过程中或处在系统的多任务视图中。
  
  AppState还支持事件监听，事件监听需要用到addEventLiatener()和removeEventListener两个方法。
  
  #### 6.1.3 NetInfo
  
  #### 6.1.4 AsyncStorage
  AsyncStorage是一个异步、持久化的数据存储API,它以键值对的方式保存数据，其作用等价于iOS的NSUserDefaluts或Android的SharedPreferences.由于AsyncStorage的操作是全局的，所以官方建议开发者先对AsyncStorage进行封装后再使用，而不是直接使用。方法如下：
  - getItem(): 根据键值来获取结果，并将获取的结果返回给回调函数。
  - setItem(): 根据键值来保存value的值，完成后调用回调函数。
  - removeItem():根据键值删除某个值，并将结果返回给回调函数。
  - mergeItem():将已有的值和新的值进行合并，合并的结果会返回给回调函数。
  - clear():清除所有的AsyncStorage保存的数据。
  - getAllKeys(): 获取所有本应该用可以访问的数据，并将结果返回给回调函数。
  - flushGetRequests():清除所有进行中的查询操作。
  - multiGet():获取key所包含的所有字段的值，并将结果以回调函数的方式传递给一个键值数组。
  - multiRemove(): 删除所有key字段名数组中的数据，并将结果返回给回调函数。
  - multiMerge():将输入的值和已有的值合并，合并的对象要求是数组格式，合并的结果会返回给回调函数。
  
  #### 6.1.5 DeviceEventEmitter
  在移动应用开发中，如果两个相互独立的组件或进程之间要进行通信，最简单的方式就是使用广播。DeviceEventEmitter是React Native官方提供的用以实现事件发送和接收的API,其作用类似于原生系统的广播
  
  DeviceEventEmitter.addlistener()方法注册需要监听的事件，而事件发送方则使用DevcieEventEmitter.emit函数发送事件。DeviceEventEmitter.remove()方法用来移除监听事件。
  
  ### 6.2 屏幕相关API
  #### 6.2.1 Dimensions
  Dimensions是官方提供的一个用于获取屏幕尺寸的API,主要用于帮助开发者获取屏幕的宽和高的信息。Dimensions的使用比较简单，只需要使用get()方法即可获取宽和高的信息。
  除了get()方法外，Dimensions还提供了如下几个方法。
  - set():设置屏幕的宽高数据。
  - addEventListener():添加屏幕事件监听处理，当Dimensions对象内的属性改变时触发。
  - removeEventListener():移除屏幕事件监听处理。
  
  #### 6.2.2 PixelRatio
  PixelRatio是一个用于获取设备像素密度的API.所谓设备像素，指的是物理像素和设备独立像素之间的比值。事实上，React Native中，使用PixelRatio.get()方法即可获取设备的像素密度。
  
  | 设备像素密度 | 设备|
  | ---- | ------- |
  | 1    | mdpi Android 设备     | 
  | 1.5   | hdpi Android 设备    | 
  | 2  | iPhone4/5s/5c/5s/6/7/8以及xhdpi Android设备    |
  | 3    | 6Plus/6sPlus/7Plus/X/XS/Max 以及xxhdpi Android设备| 
  | 3.5    | Nexus 6/Pixel XL,2XL Android设备 | 
  
  为了让一个图片在不同分辨率的设备上显示相同的效果，就需要使用PixelRatio.getPixelSizeForLayoutSize()方法对图片进行适配。
  除getPixelSizeForLayoutSize()方法外，还提供了如下几个方法。
  - get():获取设备的像素密度。
  - getFontScale():返回字体大小缩放比例。
  - roundToNearestPixel():将布局代下设置为与整数想
  
  ### 6.3 动画API
  #### 6.3.1 requestAnimationFrame
  #### 6.3.2 LayoutAnimation
  #### 6.3.3 Animated
  
  ### 6.4 平台API
  #### 6.4.1 BackHandler
  BackHandler 用于监听Android设备返回事件的API。
  通过addEventListener方法添加事件监听和使用，removeEventListener方法移除事件监听。对于Android环境来说，如果要退出应用，还可以使用BackHandler提供的exitApp()方法。
  
  #### 6.4.2 PermissionsAndroid
  PermissionsAndroid是React Native为了适配Android 6.0及以上版本的动态权限问题而退出的API，仅对Android 平台有效。
  - check(): 检测用户是否授权过某个动态权权限。
  - request():弹出提示框向用户请求某项动态权限。
  - requestMultiple():弹出提示框向用户请求多个动态权限。
  
  #### 6.4.4 PushNotificationIOS
  PushNotificationIOS是React Native官方提供的本地推送通知API，其作用类似于原生iOS系统的NSNotification.借助此API,开发者可以穷送地实现诸如权限控制以及修改应用图标角标数的任务。
  
  ## 第7章 React Native 开发进阶
  ### 7.1 组件生命周期详解
  #### 7.1.1 组件生命周期基础知识
  在React Native应用开发中，组件的生命周期指组件初始化并挂载到虚拟DOM为开始。到组件从虚拟DOM卸载为终结的整个过程，整个生命周期如图7-1所示。
  ![faa0f351.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\faa0f351.png)
  在React Native组件的生命周期大体可以分为3个阶段，即挂载,更新,卸载。其中，挂载和更新阶段都会调用render方法绘制视图。
  
  挂载阶段是指从组件的实例被创建到将其插入DOM的过程。挂载阶段涉及的生命周期方法如下：
  - defaultPros(): 此阶段主要用于初始化一些默认属性，在ES6语法中，则统一使用static成员来定义。
  - constructor(): 此方法是组件的构造方法，可以在此阶段对组件的一些状态进行初始化。不同于defaultProps(),此方法定义的变量可以通过this.setState进行修改。
  - componentWillMount():在挂载前被立即调用。它在render()方法之前被执行，因此在此方法中设置state不会导致重新渲染。
  - render():此方法主要用于渲染组件，返回JSX或其它组件构成DOM.同时，此方法应尽量保持纯净，只渲染组件不修改状态。
  - componentDidMount():此方法在挂载结束之后立即调用，即在render()方法后被执行。开发者可以在此方法中获取元素或者子组件，也可以在此方法中执行网络请求操作。
  
  更新阶段是指应用程序正常运行起来。更新阶段涉及的生命周期函数如下：
  - componentWillReceiveProps(): 在挂载的组件接收到新的props时被调用。它接收一个Object类型的参数nextProps，然后调用this.setState()来更新组件的状态。
  
  - shouldComponentUpdate(): 当组件接收到新的props或state时此方法就会被调用。此方法默认返回true,用来保证数据变化时组件能够重新渲染。当然，开发者也可以重载此方法来决定组件是否需要执行重新渲染。
  
  - componentWillUpdate(): 如果shouldComponentUpdate()方法返回为true,则此方法会在组件重新渲染前被调用。
  
  - componentDidUpdate(): 在组件重新渲染完成后被调用，可以在此函数中得到渲染完成之后的通知。
  
  销毁阶段是指组件从挂载阶段到将其从DOM中删除的过程，是组件生命周期的终点。
  - componentWillUnmount(): 在组件卸载和销毁之前被立即调用。可以在此方法中执行必要的清理工作，如关掉计时器，取消网络请求和清除创建的DOM元素等。
  
  在组件的整个生命周期中，每一个生命周期函数并不是只被调用一次，有的生命周期函数在真个生命周期阶段可能被调用多次。
  
  ![74c2a419.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\74c2a419.png)
  
  #### 7.1.2 虚拟DOM
  React中的组件并不是真实的DOM节点，而是存在于内存之中的一种数据结构，叫作虚拟DOM上。
  再将实际发生变动的部分反映在真实DOM上，而这一过程的核心就是**DOMdiff**算法(深度优优先遍历)。它可以减少不必要的DOM渲染，极大地提高组件的渲染性能。
  ```
  <ul class="list">
  <li>item1</li>
  <li>item2</li>
  </ul>
  ```
  现在，假如将代码中的内容item2修改为item3.根据虚拟DOM局部刷新的原理，当数据发生改变时，必然引起DOM树结构的改变。此时系统会构建一个新的虚拟DOM树，并将其与之前的虚拟DOM树进行对比，然后将变化的部分通知给真实的DOM树，进而刷新界面。
  
  在React 开发中，直接操作DOM通常是很慢的，而JavaScript对象操作却很快。之所以比较快，是因为使用JavaScript对象可以很容易地表示DOM节点。DOM节点通常由标签、属性和子节点组成。
  
  #### 7.1.3 虚拟DOM与生命周期
  ![15f67b6e.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\15f67b6e.png)
  
  ### 7.2 状态管理
  #### 7.2.1 Flux
  #### 7.2.2 Redux
  #### 7.2.3 MobX
  #### 7.2.4 MobX与Redux的对比
  
  ### 7.3 第三方库
  #### 7.3.1 NativeBase
  #### 7.3.2 React-native-elements
  #### 7.3.3 React-navigation
  #### 7.3.4 react-native-snap-carousel
  #### 7.3.5 react-native-image-picker
  #### 7.3.6 react-native-video
  
  ### 7.4 自定义组件
  #### 7.4.1 组件的导入和导出
  #### 7.4.2 自定义弹框组件
  #### 7.4.3 自定义单选组件
  #### 7.4.4 自定义评分组件
  
  ## 第8章 网络与通信
  ### 8.1 网络请求
  #### 8.1.1 XMLHTTPRequest
  XMLHTTP是Ajax网页开发技术的重要组成部分，除了支持XML格式之外，XMLHTTP还支持其它格式的数据，如JSON或纯文本。XMLHttpRequset则可以向服务器发送请求并接收数据，是用于在后台与服务器交换数据的对象。
  
  XMLHttpRequest对象提供了完全访问HTTP的能力，开发者可以使用它实现POST和GET请求。XMLHttpRequest可以同步或异步地返回Web服务器的响应,并且能够以文本或者DOM文档的方式返回响应数据。
  #### 8.1.2 Fetch
  Fetch是一种简化XMLHttpRequest网络请求操作的API。
  Fetch使用Promise方式回调请求结果。Promise是ES6的核心内容之一，可以有效地解决多层级链式调用问题。目前，几乎所有的现代浏览器都支持Fetch请求。
  
  Fetch发送请求
  ```
  fetch('https://mywebsite.com/mydata.json');
  ```
  Fetch还有可选的第二个参数，可以用来定制HTTP请求一些参数。你可以指定header参数，或者指定使用POST方法，又或是提交数据等。
  ```
  fetch('https://mywebsite.com/endpoint/', {
    method: 'POST',
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      firstParam: 'yourValue',
      secondParam: 'yourOtherValue'
    })
  });
  ```
  处理服务器的响应数据
  Promise方式：
  ```
  function getMoviesFromApiAsync() {
    return fetch(
      'https://facebook.github.io/react-native/movies.json'
    )
      .then((response) => response.json())
      .then((responseJson) => {
        return responseJson.movies;
      })
      .catch((error) => {
        console.error(error);
      });
  }
  ```
  async/await方式：
  ```
  // 注意这个方法前面有async关键字
  async function getMoviesFromApi() {
    try {
      // 注意这里的await语句，其所在的函数必须有async关键字声明
      let response = await fetch(
        'https://facebook.github.io/react-native/movies.json'
      );
      let responseJson = await response.json();
      return responseJson.movies;
    } catch (error) {
      console.error(error);
    }
  }
  ```
  #### 8.1.3 async-await
  async函数主要由两部分构成，即async和await。async-await是generator函数的语法糖，async函数使用async关键字进行标识，函数内部使用await来表示异步。相较于普通的generator语法。async函数对以下4点进行了改进。
  - 内置执行器: generator函数的执行必须依靠执行器，而async函数自带执行器，调用方式跟普通函数的调用一样。
  - 更广的适用性: co模块约定，yield命令后面只能是thunk函数或Promise对象，而async函数的await命令后面则可以是Promise或者原始类型的值。
  - **返回值为Promise**：async函数的返回值是Promise对象，比generator函数返回的iterator对象方便，可以直接使用then函数调用返回的结果。
  
  async函数使用async关键字进行修饰，函数内部使用await来表示异步，并最终返回一个Promise对象。同时，async函数返回的值会成为then()方法回调函数的参数。
  ```
  async function fun1(){
      console.log('Promise');
      return new Promise(function(resolve,reject){
          resolve('Promise')
      })
  }
  ```
  await也是一个修饰符，只能放在async定义的函数内。可以理解为等待。
  await修饰的如果是Promise对象可以获取Promise中返回的内容，且取到值后语句才会往下执行。
  如果不是Promise对象把整个非Promise的东西当做await表达式的结果。
  ```
  Promise对象
  async function fun(){
      let a = await 1;
      let b = await new Promise((resolve,reject)=>{
          setTimeout(function(){
              resolve('setTimeout')
          },3000)
      })
      let c = await function(){
          return 'function'
      }()
      console.log(a,b,c)
  }
  fun(); // 3秒后输出： 1 "setTimeout" "function"
  
  非Promise对象
  function log(time){
      setTimeout(function(){
          console.log(time);
          return 1;
      },time)
  }
  async function fun(){
      let a = await log(1000);
      let b = await log(3000);
      let c = log(2000);
      console.log(a);
      console.log(1)
  }
  fun();
  ```
  async/await的正确用法
  ```
  // 定义一个异步函数，3秒后才能获取到值(类似操作数据库)
  function getSomeThing(){
      return new Promise((resolve,reject)=>{
          setTimeout(()=>{
              resolve('获取成功')
          },3000)
      })
  }
  
  async function test(){
      let a = await getSomeThing();
      console.log(a)
  }
  test(); // 3秒后输出：获取成功
  ```
  ### 8.2 Promise
  在JavaScript的世界中，所有代码都是单线程执行的，这是因为JavaScript主要的运用场景是浏览器，
  浏览器本身是典型的GUI工作线程。GUI工作线程在绝大多数系统中都被实现为事件处理。为了避免造成线程阻塞，JavaScript被设计成单线程工作方式。
  
  所谓单线程，是指一个浏览器进程中只有一个执行线程，同一时刻内只会有一段代码被执行。因为这一特性，导致JavaScript的所有网络操作，浏览器事件都必须是异步执行的。异步执行可以使用回调函数实现。
  ```
  new Promise( function(resolve, reject) {...} /* executor */  );
  ```
  Pending: 进行时，但是无法知道处理进度，只能知道目前是在处理这次异步操作。
  Resolved: 已完成，又称Fulfilled，表示异步操作结果正确回调方法。
  Rejected: 已失败，表示处理中途抛出异常，或者处理结果不正确回调方法。
  
  Promise 使用方式1
  ```
  var promise = new Promise((resolve, reject) =>{
    //这里是异步处理方法，最终得到data结果，
    //然后根据data的status属性决定处理结果是否正确。
    if(data.status == true){
      resolve(data);
    }else{
      reject(error);
    }
  });
  
  ```
  Promise 使用方式2
  ```
  promise.then((data)=>{
    //这里处理resolve回调方法
  },(error)=>{
    //这里处理reject回调方法
  });
  ```
  Promise 使用方式3
  ```
  promise.then((data)=>{
    //这里处理resolve回调方法
  }).catch((error)=>{
    //这里处理reject回调方法
  });
  ```
  用Promise封装一个HTTP/HTTPS轮子
  ```
  static get(url){
    return new Promise((resolve, reject) =>{
      fetch(url).then((response)=>response.json())
      .then((responseData) => {
      if(responseData.c && responseData.c == 10000){
        resolve(responseData.d);
      }else{
        reject(new Error(responseData.d));
      }
      }).catch((error) => {
        reject(new Error('网路异常'));
      }).done();
    });
  }
  ```
  Promise 链式处理
  ![53bbdb7d.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\53bbdb7d.png)
  Promise在执行then或者catch方法时会再返回一个Promise对象，所以可以再次执行then或者catch方法。
  ```
  doubleUp(value) { 
    return value * 2;
  }
  increment(value) { 
    return value + 1;
  }
  output(value) { 
    console.log(value);// => (1 + 1) * 2;
  }
  var promise = Promise.resolve(1);
  promise.then(increment)
  .then(doubleUp)
  .then(output)
  .catch(function(error){ 
    // promise chain中出现异常的时候会被调用 console.error(error); 
  });
  ```
  如果想then或者catch方法后不再又链式方法可以在最后增加一个done()方法，这个方法不会再返回Promise对象，也就无法再增加执行then或者catch方法了。
  
  ### 8.3 与原生交互
  #### 8.3.1 与原生Android 交互
  通常，React Native的JavaScript层调用原生代码模块包含以下几个步骤。
  - 在Android 项目中通过原生代码实现提供相应的原生功能。
  - 在Android 项目中注册编写好的功能模块。
  - 在React Native项目中使用JavaScript代码调用Android平台功能。
  
  创建一个新的 Java 类并命名为ToastModule.java并继承ReactContextBaseJavaModule
  ```
  package com.your-app-name;
  import android.widget.Toast;
  import com.facebook.react.bridge.NativeModule;
  import com.facebook.react.bridge.ReactApplicationContext;
  import com.facebook.react.bridge.ReactContext;
  import com.facebook.react.bridge.ReactContextBaseJavaModule;
  import com.facebook.react.bridge.ReactMethod;
  import java.util.Map;
  import java.util.HashMap;
  
  public class ToastModule extends ReactContextBaseJavaModule {
    private static ReactApplicationContext reactContext;
    private static final String DURATION_SHORT_KEY = "SHORT";
    private static final String DURATION_LONG_KEY = "LONG";
  
    public ToastModule(ReactApplicationContext context) {
      super(context);
      reactContext = context;
    }
  }
  ```
  ReactContextBaseJavaModule要求派生类实现getName方法。这个函数用于返回一个字符串名字，这个名字在 JavaScript 端标记这个模块。这里我们把这个模块叫做ToastExample，这样就可以在 JavaScript 中通过NativeModules.ToastExample访问到这个模块。
  ```
    @Override
    public String getName() {
      return "ToastExample";
    }
  ```
  一个可选的方法getContants返回了需要导出给 JavaScript 使用的常量。它并不一定需要实现，但在定义一些可以被 JavaScript 同步访问到的预定义的值时非常有用。
  ```
    @Override
    public Map<String, Object> getConstants() {
      final Map<String, Object> constants = new HashMap<>();
      constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);
      constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);
      return constants;
    }
  ```
  要导出一个方法给 JavaScript 使用，Java 方法需要使用注解@ReactMethod。方法的返回类型必须为void。React Native 的跨语言访问是异步进行的，所以想要给 JavaScript 返回一个值的唯一办法是使用回调函数或者发送事件
  ```
  @ReactMethod
    public void show(String message, int duration) {
      Toast.makeText(getReactApplicationContext(), message, duration).show();
    }
  ```
  在 Java 这边要做的最后一件事就是注册这个模块。我们需要在应用的 Package 类的createNativeModules方法中添加这个模块。如果模块没有被注册，它也无法在 JavaScript 中被访问到。
  ```
  package com.your-app-name;
  import com.facebook.react.ReactPackage;
  import com.facebook.react.bridge.NativeModule;
  import com.facebook.react.bridge.ReactApplicationContext;
  import com.facebook.react.uimanager.ViewManager;
  
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.List;
  
  public class CustomToastPackage implements ReactPackage {
    @Override
    public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {
      return Collections.emptyList();
    }
    @Override
    public List<NativeModule> createNativeModules(
                                ReactApplicationContext reactContext) {
      List<NativeModule> modules = new ArrayList<>();
      modules.add(new ToastModule(reactContext));
      return modules;
    }
  }
  ```
  这个 package 需要在MainApplication.java文件的getPackages方法中提供。这个文件位于你的 react-native 应用文件夹的 android 目录中。具体路径是: android/app/src/main/java/com/your-app-name/MainApplication.java
  ```
  // MainApplication.java
  ...
  import com.your-app-name.CustomToastPackage; // <-- 引入你自己的包
  ...
  protected List<ReactPackage> getPackages() {
    @SuppressWarnings("UnnecessaryLocalVariable")
    List<ReactPackage> packages = new PackageList(this).getPackages();
    // Packages that cannot be autolinked yet can be added manually here, for example:
    // packages.add(new MyReactNativePackage());
    packages.add(new CustomToastPackage()); // <-- 添加这一行，类名替换成你的Package类的名字 name.
    return packages;
  }
  ```
  #### 8.3.2 与原生IOS交互
  只需要在原生IOS工程中创建一个Module类并实现RCTBridgeModule协议即可。
  
  #### 8.3.3 事件交互
  除了主动调用原生模态暴露的方法外，React Native还支持使用事件监听的方式来进行数据传递。使用事件监听方式接收原生平台传递过来的数据方面，Android使用的是DeviceEventEmitter,iOS则使用的是NativeEventEmitter。
  
  ```
  import com.facebook.react.modules.core.DeviceEventManagerModule;
  import com.facebook.react.bridge.WritableMap;
  import com.facebook.react.bridge.Arguments;
  private void sendEvent(ReactContext reactContext,
                         String eventName,
                         @Nullable WritableMap params) {
    reactContext
        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
        .emit(eventName, params);
  }
  @ReactMethod
  public void addListener(String eventName) {
  }
  @ReactMethod
  public void removeListeners(Integer count) {
  }
  
  WritableMap params = Arguments.createMap();
  params.putString("eventProperty", "someValue");
  sendEvent(reactContext, "EventReminder", params);
  ```
  JavaScript模块可以通过使用NativeEventEmitter模块来监听事件:
  
  ```
  import { NativeEventEmitter, NativeModules } from 'react-native';
    componentDidMount() {
      const eventEmitter = new NativeEventEmitter(NativeModules.ToastExample);
      this.eventListener = eventEmitter.addListener('EventReminder', (event) => {
         console.log(event.eventProperty) // "someValue"
      });
    }
    componentWillUnmount() {
      this.eventListener.remove(); // 组件卸载时记得移除监听事件
    }
  ```
  ## 第9章 服务器开发基础
  ### 9.1 Node.js开发
  ### 9.2 RESTful API
  ### 9.3 ExPress框架
  ### 9.4 开发服务器接口
  ## 第10章 服务器开发基础
  ### 10.1 软件测试
  ### 10.2 React Native单元测试
  ### 10.3 Jest
  ## 第11章 应用发布与热更新
  ### 11.1 iOS应用发布
  ### 11.2 Android应用发布
  ### 11.3 热更新详解
  #### 11.3.1 热更新基础知识
  再原生Android开发中，可以使用Tinker、AndFix和Qzone等热更新框架完成代码更新。而对于原生iOS开发来说，则可以使用Aspects等热修复框架来完成代码的热更新。
  
  与原生应用采用的热更新技术不同，React Native天生九具备热更新特性，可以很方便地通过服务器动态更新JavaScript代码来实现应用的热更新。
  
  ![a77f823f.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\a77f823f.png)
  
  ![5924fd77.png](:storage\\76dd87ce-02ef-4922-975c-ba0304cd62a6\\5924fd77.png)
  
  热更新操作需要经历以下几个步骤：
  - 部署热更新服务，添加客户端版本配置。
  - 客户端执行热更新检测，判断是否需要更新。
  - 如果需要更新，则可以从服务器端下载资源文件差分包，然后再本地执行资源的合并操作并执行合并文件的加载操作；如果不需要更新，则直接加载内置的资源文件。
  
  目前，React Native提供的热更新方案中，比较成熟的有Pushy和微软推出的CodePush.
  
  
  #### 11.3.2 应用启动过程
  - 由React Native将JavaScript的资源打包。
  - 执行run命令时系统会默认启动一个基于Node.js的React Native服务，并且此服务运行在本地，监听的默认端口号是8081.
  - 当应用请求本地的index.ios.bundle资源时，就会从React Native服务实时获取最新的JavaScript资源。
  - 当JavaScript资源发生变化时，React Native会重新执行打包操作，并通过原生应用重新加载。
  
  #### 11.3.3 热更新示例
  
  ### 11.4 CodePush
  #### 11.4.1 CodePush 简介
  作为一个移动跨平台应用开发框架，React Native 虽然提供了动态更新的基础，但是动态更新方案并不完善。因为一个完整的热更新方案，除了客户端的支持外，还需要服务器端的支持。好在微软开发的CodePush技术框架，填补了React Native应用在动态更新方面的空白，开发者也可以使用它完成代码的热修复。
  
  CodePush是微软开发的一套云服务器技术，可以用于实现Cordova和React Native应用的热更新。借助CodePush云服务器，开发者可以直接部署移动应用更新，并快速实现代码的热更新。
  
  CodePush作为一个中央仓库，开发者可以实时推送更新，然后客户端可以在应用启动时查询更新。这样一来，不需要重新打包发布、审核和安装应用，就可以轻松解决应用的缺陷或添加新特性。
  
  #### 11.4.2 CodePush 安装与账号注册
  
  #### 11.4.3 集成CodePush SDK
  
  #### 11.4.4 手动集成CodePush SDK
  
  #### 11.4.5 iOS应用热更新
  
  #### 11.4.6 Android应用热更新
  
  
  ## 文献
  [React 基础 · React Native 中文网](https://reactnative.cn/docs/intro-react
  [深入 JSX – React](https://zh-hans.reactjs.org/docs/jsx-in-depth.html)
  [史上最全React-Native第三方库 - 掘金](https://juejin.cn/post/7046016631788535816)
  [React-Native第三方库](https://reactnative.directory/)
  [【React Native】Promise的简单使用 - 简书](https://www.jianshu.com/p/1b333b21f644)
'''
linesHighlighted: [
  995
  1421
]
isStarred: false
isTrashed: false
