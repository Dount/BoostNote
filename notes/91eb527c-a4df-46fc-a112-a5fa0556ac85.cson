createdAt: "2019-08-01T08:19:03.915Z"
updatedAt: "2020-10-27T13:46:28.614Z"
type: "MARKDOWN_NOTE"
folder: "a829d630b1a42b272c49"
title: "volatile 关键字的理解"
tags: []
content: '''
  ## volatile 关键字的理解
  
  [深入理解Java中的volatile关键字-HollisChuang's Blog](https://www.hollischuang.com/archives/2648)
  [再有人问你volatile是什么，把这篇文章也发给他。-HollisChuang's Blog](https://www.hollischuang.com/archives/2673)
  ### volatile的原理
  
  在java内存模型中，为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。
  
  对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的命令，将这个缓存中的变量回写到系统主存中。
  
  **缓存一致性协议:** 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。
  
  所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。
  
  ### volatile的可见性
  可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
  
  Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。
  
  java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。
  
  ### volatile的有序性
  由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add->save 有可能被优化成load->save->add 这就是可能存在有序性问题。
  
  volatile除了可以保证数据的可见性，还可以禁止指令重排优化等。
  
  对于普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。
  
  volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行，这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load->add->save的执行顺序就是:load,add,save
  
  ### volatile的原子性
  原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。
  
  线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。
  
  在用到synchronized的时候，提到过，为了保证原子性，需要通过字节码指令monitorenter和monitorexit,但是volatile和这两个指令之间是没有任何关系的。
  
  所以,volatile是不能保证原子性的。
  
  
'''
linesHighlighted: []
isStarred: false
isTrashed: true
